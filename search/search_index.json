{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"wdadaptivepy","text":"<p>A python wrapper for the Workday Adaptive Planning API, providing an easy-to-use library to create, read, update, and delete data, metadata, and other information within Adaptive. Overview</p> <p>Workday Adaptive Planning is a cloud-based planning, reporting, and analysis solution. This library simplifies interacting with the Adaptive Planning API via a Pythonic interface.</p>"},{"location":"getting_started/ConnectingtoAdaptive/","title":"Connecting to an Adaptive Instance","text":"<p>To connect to your Adaptive instance you will need to call the AdaptiveConnection function in Adpativepy</p>"},{"location":"getting_started/ConnectingtoAdaptive/#step-1-import-adaptivepy","title":"Step 1: Import Adaptivepy","text":"<pre><code>from wdadaptivepy import AdaptiveConnection\n</code></pre>"},{"location":"getting_started/ConnectingtoAdaptive/#step-2-set-up-your-connection-parameters","title":"Step 2: Set up your connection parameters","text":"<pre><code>username = \"\"  # Provide your username\npassword = \"\"  # Provide your password\n</code></pre>"},{"location":"getting_started/ConnectingtoAdaptive/#step-3-connect-to-your-adaptive-instance","title":"Step 3: Connect to your adaptive instance","text":"<pre><code>adaptive = AdaptiveConnection(\n    login=username,\n    password=password,\n    # instance_code=None,  # Optional\n    # locale=\"en_US\",  # Optional\n    # caller_name=\"AdaptivePY\",  # Optional\n    # xml_api_version=40)  # Optional\n</code></pre> <p>Note that this simple example will not return anything. It is simply connecting to your instance. See other examples in the documentation to display outputs.</p>"},{"location":"getting_started/GetData/","title":"How to Get Data","text":""},{"location":"getting_started/GetData/#step-1-import-adaptivepy-and-pretty-print-to-show-results","title":"Step 1: Import Adaptivepy and pretty print (to show results)","text":"<pre><code>from wdadaptivepy import AdaptiveConnection\nimport pprint\n</code></pre>"},{"location":"getting_started/GetData/#step-2-set-up-your-connection-parameters","title":"Step 2: Set up your connection parameters","text":"<pre><code>username = \"\"  # Provide your username\npassword = \"\"  # Provide your password\n</code></pre>"},{"location":"getting_started/GetData/#step-3-connect-to-your-adaptive-instance","title":"Step 3: Connect to your adaptive instance","text":"<pre><code>adaptive = AdaptiveConnection(\n    login=username,\n    password=password\n    )\n</code></pre>"},{"location":"getting_started/GetData/#step-4-define-the-version","title":"Step 4: Define the version","text":"<pre><code>version = adaptive.versions.get_all()[0]  # adaptive.versions.Version(code=\"Actuals\")\n</code></pre>"},{"location":"getting_started/GetData/#step-5-define-the-account-and-the-account-filter","title":"Step 5: Define the account and the account filter","text":"<pre><code>accounts = adaptive.accounts.get_all()\naccount_filter = AccountFilter(account=accounts[0].get_descendents())\n</code></pre>"},{"location":"getting_started/GetData/#step-6-define-the-time-and-time-filter","title":"Step 6: Define the time and time filter","text":"<pre><code>adaptive_time = adaptive.time.get_all()\nstart_period = [period for period in adaptive_time[0].period if period.code == \"01/2020\"][0]\nend_period = [period for period in adaptive_time[0].period if period.code == \"01/2026\"][0]\ntime_filter = TimeFilter(start=start_period, end=end_period)\n</code></pre>"},{"location":"getting_started/GetData/#step-7-define-the-data-filter-and-then-get-the-data","title":"Step 7: Define the data filter and then get the data","text":"<pre><code>data_filter = ExportDataFilter(accounts=account_filter, time=time_filter)\ndata = adaptive.data.get_data(version=version, data_filter=data_filter)\n</code></pre>"},{"location":"getting_started/GetData/#sample-output","title":"Sample Output","text":"<p><code>{'Account Code': '1110_CA_PettyCash',   'Account Name': '1110 Petty Cash',   'Amount': 0.0,   'Level Code': 'BC - 91',   'Level Name': 'Sales - North',   'Period Code': '05/2024'}</code></p>"},{"location":"getting_started/GetDataFromModeledSheet/","title":"How to Get data from Modeled Sheet","text":""},{"location":"getting_started/GetDataFromModeledSheet/#step-1-import-adaptivepy-and-pretty-print-to-show-results","title":"Step 1: Import Adaptivepy and pretty print (to show results)","text":"<pre><code>from wdadaptivepy import AdaptiveConnection\nimport pprint\n</code></pre>"},{"location":"getting_started/GetDataFromModeledSheet/#step-2-set-up-your-connection-parameters","title":"Step 2: Set up your connection parameters","text":"<pre><code>username = \"\"  # Provide your username\npassword = \"\"  # Provide your password\n</code></pre>"},{"location":"getting_started/GetDataFromModeledSheet/#step-3-connect-to-your-adaptive-instance","title":"Step 3: Connect to your adaptive instance","text":"<pre><code>adaptive = AdaptiveConnection(\n    login=username,\n    password=password\n    )\n</code></pre>"},{"location":"getting_started/GetDataFromModeledSheet/#step-4-get-data-from-modeled-sheet","title":"Step 4: Get data from modeled sheet","text":""},{"location":"getting_started/GetDataFromModeledSheet/#only-using-required-parameters","title":"(only using required parameters)","text":"<pre><code>modData = adaptive.data.from_modeled_sheet(\n    \"MyModeledSheet\",\n    \"Workforce Planning\")\n</code></pre>"},{"location":"getting_started/GetDataFromModeledSheet/#step-5-display-results","title":"Step 5: Display results","text":"<pre><code>pprint.pprint(modData)\n</code></pre>"},{"location":"getting_started/GetDataFromModeledSheet/#sample-output","title":"Sample Output","text":"<pre><code>[{'Allocations &gt;': '',\n  'Bonus %': 'None',\n  'Comments': 'My comments',\n[{'Allocations &gt;': '',\n  'Bonus %': 'None',\n  'Comments': 'My comments',\n  'Commission Target': '',\n  'End Date': '8/30/2025',\n  'Health Benefits': 'Plan 1',\n  'Hr/Week': '',\n  'InternalID': 'S24704',\n  'IsParent': '',\n  'Level': 'BC - 91',\n  'MA_Pay Rate': '9000.000000000',\n  'Name': 'John Doe',\n  'ParentID': '',\n  'Pay Raise %': '15.000000000',\n  'Pension Plan': 'Defined Contribution A',\n  'Per': 'Hr',\n  'Raise Date': '8/29/2025',\n  'Residence for Tax': 'NJ - New Jersey',\n  'Start Date': '8/28/2025',\n  'Title': 'Account Executive'}]\n</code></pre>"},{"location":"getting_started/Levels.GetAll/","title":"How to Retrieve All Levels","text":""},{"location":"getting_started/Levels.GetAll/#step-1-import-adaptivepy-and-pretty-print-to-show-results","title":"Step 1: Import Adaptivepy and pretty print (to show results)","text":"<pre><code>from wdadaptivepy import AdaptiveConnection\nimport pprint\n</code></pre>"},{"location":"getting_started/Levels.GetAll/#step-2-set-up-your-connection-parameters","title":"Step 2: Set up your connection parameters","text":"<pre><code>username = \"\"  # Provide your username\npassword = \"\"  # Provide your password\n</code></pre>"},{"location":"getting_started/Levels.GetAll/#step-3-connect-to-your-adaptive-instance","title":"Step 3: Connect to your adaptive instance","text":"<pre><code>adaptive = AdaptiveConnection(\n    login=username,\n    password=password\n    )\n</code></pre>"},{"location":"getting_started/Levels.GetAll/#step-4-use-the-get_all-function","title":"Step 4: Use the get_all function","text":"<pre><code>all_levels = adaptive.levels.get_all()\n</code></pre>"},{"location":"getting_started/Levels.GetAll/#step-5-display-results","title":"Step 5: Display Results","text":"<pre><code>pprint.pprint(all_levels)\n</code></pre>"},{"location":"getting_started/Levels.GetAll/#example-of-output","title":"Example of output","text":"<pre><code> Level(id=207,\n       code='BC - 75',\n       name='Production',\n       display_name='Production',\n       currency='INR',\n       publish_currency=None,\n       short_name='',\n       available_start=None,\n       available_end=None,\n       is_importable=None,\n       workflow_status=None,\n       is_elimination=False,\n       is_linked=False,\n       has_children=None,\n       description='')\n</code></pre>"},{"location":"getting_started/Levels.GetAncestors/","title":"How to Retrieve Level Ancestors","text":""},{"location":"getting_started/Levels.GetAncestors/#step-1-import-adaptivepy-and-pretty-print-to-show-results","title":"Step 1: Import Adaptivepy and pretty print (to show results)","text":"<pre><code>from wdadaptivepy import AdaptiveConnection\nimport pprint\n</code></pre>"},{"location":"getting_started/Levels.GetAncestors/#step-2-set-up-your-connection-parameters","title":"Step 2: Set up your connection parameters","text":"<pre><code>username = \"\"  # Provide your username\npassword = \"\"  # Provide your password\n</code></pre>"},{"location":"getting_started/Levels.GetAncestors/#step-3-connect-to-your-adaptive-instance","title":"Step 3: Connect to your adaptive instance","text":"<pre><code>adaptive = AdaptiveConnection(\n    login=username,\n    password=password\n    )\n</code></pre>"},{"location":"getting_started/Levels.GetAncestors/#step-4-use-the-get_all-function","title":"Step 4: Use the get_all function","text":"<pre><code>all_levels = adaptive.levels.get_all()\n</code></pre>"},{"location":"getting_started/Levels.GetAncestors/#step-5-choose-the-level","title":"Step 5: Choose the level","text":"<pre><code>level = adaptive.levels[10]\n</code></pre>"},{"location":"getting_started/Levels.GetAncestors/#step-6-get-ancestors","title":"Step 6: Get ancestors","text":"<pre><code>ancestors = level.get_ancestors()\n</code></pre>"},{"location":"getting_started/Levels.GetAncestors/#step-7-display-results","title":"Step 7: Display results","text":"<pre><code>pprint.pprint(ancestors)\n</code></pre>"},{"location":"getting_started/Levels.GetAncestors/#example-of-output","title":"Example of output","text":"<pre><code>[Level(id=165,\n       code='BC - 111',\n       name='United States',\n       display_name='United States',\n       currency='USD',\n       publish_currency=None,\n       short_name='US',\n       available_start=None,\n       available_end=None,\n       is_importable=None,\n       workflow_status=None,\n       is_elimination=False,\n       is_linked=False,\n       has_children=True,\n       description=''),\n Level(id=164,\n       code='BC - 70',\n       name='Operations - company A',\n       display_name='Operations - company A',\n       currency='USD',\n       publish_currency=None,\n       short_name='Ops',\n       available_start=None,\n       available_end=None,\n       is_importable=None,\n       workflow_status=None,\n       is_elimination=True,\n       is_linked=False,\n       has_children=True,\n       description=''),\n Level(id=201,\n       code='BC - 52',\n       name='Company A (100% owned)',\n       display_name='Company A (100% owned)',\n       currency='USD',\n       publish_currency=None,\n       short_name='Co.A',\n       available_start=None,\n       available_end=None,\n       is_importable=None,\n       workflow_status=None,\n       is_elimination=False,\n       is_linked=False,\n       has_children=True,\n       description=''),\n Level(id=1,\n       code='Total Company',\n       name='Total Company',\n       display_name='Total Company',\n       currency='USD',\n       publish_currency=None,\n       short_name='TotalCo',\n       available_start=None,\n       available_end=None,\n       is_importable=None,\n       workflow_status=None,\n       is_elimination=True,\n       is_linked=False,\n       has_children=True,\n       description='')]\n</code></pre>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 or greater</li> </ul>"},{"location":"getting_started/installation/#basic-installation","title":"Basic Installation","text":"<p><code>wdadaptivepy</code> is available on Python Package Index (PyPI), the standard Python package repository.</p> <pre><code>pip install wdadaptivepy\n</code></pre>"},{"location":"getting_started/installation/#recommended-installation","title":"Recommended Installation","text":"<p>The recommended way to install <code>wdadaptivepy</code> is via uv. However, it can be installed via <code>pip</code> as well.</p> uvpip <pre><code>mkdir myProject\ncd myProject\nuv init\nuv add wdadaptivepy\n</code></pre> <pre><code>mkdir myProject\ncd myProject\npython3 -m venv .venv  # or `python -m venv .venv`\nsource .venv/bin/activate # Windows should be `.venv\\Scripts\\activate`\npip install wdadaptivepy\n</code></pre>"},{"location":"getting_started/installation/#additional-features","title":"Additional Features","text":""},{"location":"getting_started/installation/#workday-authentication","title":"Workday Authentication","text":"<p><code>wdadaptivepy</code> supports authenticating via Workday, but it requires an additional package.</p> uvpip <pre><code>uv add wdadaptivepy[workday]\n</code></pre> <pre><code>pip install wdadaptivepy[workday]\n</code></pre>"},{"location":"news/","title":"News","text":""},{"location":"news/alpha-release/","title":"Alpha Release","text":"<p>This is the text for the alpha release.</p> <p>All the text here appears in the alpha release message.</p>"},{"location":"news/beta-release/","title":"Beta Release","text":"<p>This is the text for the beta release.</p> <p>Lorem ipsum dolor sit amet, consectetur</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>wdadaptivepy<ul> <li>connectors<ul> <li>xml_api<ul> <li>constants</li> <li>exceptions</li> <li>xml_api</li> </ul> </li> </ul> </li> <li>main</li> <li>models<ul> <li>account</li> <li>attribute</li> <li>attribute_value</li> <li>base</li> <li>currency</li> <li>data</li> <li>dimension</li> <li>dimension_value</li> <li>exceptions</li> <li>group</li> <li>level</li> <li>list</li> <li>permission_set</li> <li>time</li> <li>user</li> <li>version</li> </ul> </li> <li>services<ul> <li>accounts</li> <li>attribute_values</li> <li>attributes</li> <li>currencies</li> <li>data</li> <li>dimension_values</li> <li>dimensions</li> <li>groups</li> <li>levels</li> <li>permission_sets</li> <li>time</li> <li>users</li> <li>versions</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/wdadaptivepy/__init__/","title":"init","text":"<p>wdadaptivepy main entry imports.</p>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.Account","title":"<code>Account</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierarchialAttributedMetadata</code></p> <p>wdadaptivepy model for Adaptive's Accounts.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Account ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Account Code</p> <code>name</code> <code>str | None</code> <p>Adaptive Account Name</p> <code>account_type_code</code> <code>str | None</code> <p>Adaptive Account Type Code</p> <code>description</code> <code>str | None</code> <p>Adaptive Account Description</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Account Short Name</p> <code>time_stratum</code> <code>str | None</code> <p>Adaptive Account Time Stratum</p> <code>display_as</code> <code>str | None</code> <p>Adaptive Account Dispay As</p> <code>is_assumption</code> <code>bool | None</code> <p>Adaptive Account Is Assumption</p> <code>suppress_zeroes</code> <code>bool | None</code> <p>Adaptive Account Suprress Zeroes</p> <code>is_default_root</code> <code>bool | None</code> <p>Adaptive Account Is Default Root</p> <code>decimal_precision</code> <code>str | None</code> <p>Adaptive Account Decimal Precision</p> <code>plan_by</code> <code>str | None</code> <p>Adaptive Account Plan By</p> <code>exchange_rate_type</code> <code>str | None</code> <p>Adaptive Account Exchange Rate Type</p> <code>is_importable</code> <code>bool | None</code> <p>Adaptive Account Is Importable</p> <code>balance_type</code> <code>str | None</code> <p>Adaptive Account Balance Type</p> <code>data_entry_type</code> <code>str | None</code> <p>Adaptive Account Data Entry Type</p> <code>time_roll_up</code> <code>str | None</code> <p>Adaptive Account Time Roll Up</p> <code>time_weight_acct_id</code> <code>str | None</code> <p>Adaptive Account Time Weight Account ID</p> <code>has_salary_detail</code> <code>bool | None</code> <p>Adaptive Account Has Salary Detail</p> <code>data_privacy</code> <code>str | None</code> <p>Adaptive Account Data Privacy</p> <code>sub_type</code> <code>str | None</code> <p>Adaptive Account Sub Type</p> <code>start_expanded</code> <code>bool | None</code> <p>Adaptive Account Start Expanded</p> <code>is_breakback_eligible</code> <code>bool | None</code> <p>Aadaptive Account Is Breakback Eligibile</p> <code>level_dim_rollup</code> <code>str | None</code> <p>Adaptive Account Level Dim Rollup</p> <code>rollup_text</code> <code>str | None</code> <p>Adaptive Account Rollup Text</p> <code>enable_actuals</code> <code>bool | None</code> <p>Adaptive Account Enable Actuals</p> <code>is_group</code> <code>bool | None</code> <p>Adaptive Account Is Group</p> <code>is_intercompany</code> <code>bool | None</code> <p>Adaptive Account Is Intercompany</p> <code>formula</code> <code>str | None</code> <p>Adaptive Account Formula</p> <code>is_linked</code> <code>bool | None</code> <p>Adaptive Account Is Linked</p> <code>is_system</code> <code>bool | None</code> <p>Adaptive Account Is System</p> <code>owning_sheet_id</code> <code>str | None</code> <p>Adaptive Account Owning Sheet ID</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy Account XML tags</p> Source code in <code>src/wdadaptivepy/models/account.py</code> <pre><code>@dataclass(eq=False)\nclass Account(HierarchialAttributedMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Accounts.\n\n    Attributes:\n        id: Adaptive Account ID\n        code: Adaptive Account Code\n        name: Adaptive Account Name\n        account_type_code: Adaptive Account Type Code\n        description: Adaptive Account Description\n        short_name: Adaptive Account Short Name\n        time_stratum: Adaptive Account Time Stratum\n        display_as: Adaptive Account Dispay As\n        is_assumption: Adaptive Account Is Assumption\n        suppress_zeroes: Adaptive Account Suprress Zeroes\n        is_default_root: Adaptive Account Is Default Root\n        decimal_precision: Adaptive Account Decimal Precision\n        plan_by: Adaptive Account Plan By\n        exchange_rate_type: Adaptive Account Exchange Rate Type\n        is_importable: Adaptive Account Is Importable\n        balance_type: Adaptive Account Balance Type\n        data_entry_type: Adaptive Account Data Entry Type\n        time_roll_up: Adaptive Account Time Roll Up\n        time_weight_acct_id: Adaptive Account Time Weight Account ID\n        has_salary_detail: Adaptive Account Has Salary Detail\n        data_privacy: Adaptive Account Data Privacy\n        sub_type: Adaptive Account Sub Type\n        start_expanded: Adaptive Account Start Expanded\n        is_breakback_eligible: Aadaptive Account Is Breakback Eligibile\n        level_dim_rollup: Adaptive Account Level Dim Rollup\n        rollup_text: Adaptive Account Rollup Text\n        enable_actuals: Adaptive Account Enable Actuals\n        is_group: Adaptive Account Is Group\n        is_intercompany: Adaptive Account Is Intercompany\n        formula: Adaptive Account Formula\n        is_linked: Adaptive Account Is Linked\n        is_system: Adaptive Account Is System\n        owning_sheet_id: Adaptive Account Owning Sheet ID\n        __xml_tags: wdadaptivepy Account XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    account_type_code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"accountTypeCode\",\n            \"xml_read\": \"accountTypeCode\",\n            \"xml_update\": \"accountTypeCode\",\n            \"xml_delete\": \"accountTypeCode\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    time_stratum: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"timeStratum\",\n            \"xml_read\": \"timeStratum\",\n            \"xml_update\": \"timeStratum\",\n            \"xml_delete\": \"timeStratum\",\n        },\n    )\n    display_as: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayAs\",\n            \"xml_read\": \"displayAs\",\n            \"xml_update\": \"displayAs\",\n            \"xml_delete\": \"displayAs\",\n        },\n    )\n    is_assumption: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isAssumption\",\n            \"xml_read\": \"isAssumption\",\n            \"xml_update\": \"isAssumption\",\n            \"xml_delete\": \"isAssumption\",\n        },\n    )\n    suppress_zeroes: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"suppressZeroes\",\n            \"xml_read\": \"suppressZeroes\",\n            \"xml_update\": \"suppressZeroes\",\n            \"xml_delete\": \"suppressZeroes\",\n        },\n    )\n    is_default_root: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isDefaultRoot\",\n            \"xml_read\": \"isDefaultRoot\",\n            \"xml_update\": \"isDefaultRoot\",\n            \"xml_delete\": \"isDefaultRoot\",\n        },\n    )\n    decimal_precision: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"decimalPrecision\",\n            \"xml_read\": \"decimalPrecision\",\n            \"xml_update\": \"decimalPrecision\",\n            \"xml_delete\": \"decimalPrecision\",\n        },\n    )\n    plan_by: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"planBy\",\n            \"xml_read\": \"planBy\",\n            \"xml_update\": \"planBy\",\n            \"xml_delete\": \"planBy\",\n        },\n    )\n    exchange_rate_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"exchangeRateType\",\n            \"xml_read\": \"exchangeRateType\",\n            \"xml_update\": \"exchangeRateType\",\n            \"xml_delete\": \"exchangeRateType\",\n        },\n    )\n    is_importable: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isImportable\",\n            \"xml_read\": \"isImportable\",\n            \"xml_update\": \"isImportable\",\n            \"xml_delete\": \"isImportable\",\n        },\n    )\n    balance_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"balanceType\",\n            \"xml_read\": \"balanceType\",\n            \"xml_update\": \"balanceType\",\n            \"xml_delete\": \"balanceType\",\n        },\n    )\n    data_entry_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"dataEntryType\",\n            \"xml_read\": \"dataEntryType\",\n            \"xml_update\": \"dataEntryType\",\n            \"xml_delete\": \"dataEntryType\",\n        },\n    )\n    time_roll_up: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"timeRollUp\",\n            \"xml_read\": \"timeRollUp\",\n            \"xml_update\": \"timeRollUp\",\n            \"xml_delete\": \"timeRollUp\",\n        },\n    )\n    time_weight_acct_id: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"timeWeightAcctId\",\n            \"xml_read\": \"timeWeightAcctId\",\n            \"xml_update\": \"timeWeightAcctId\",\n            \"xml_delete\": \"timeWeightAcctId\",\n        },\n    )\n    has_salary_detail: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"hasSalaryDetail\",\n            \"xml_read\": \"hasSalaryDetail\",\n            \"xml_update\": \"hasSalaryDetail\",\n            \"xml_delete\": \"hasSalaryDetail\",\n        },\n    )\n    data_privacy: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"dataPrivacy\",\n            \"xml_read\": \"dataPrivacy\",\n            \"xml_update\": \"dataPrivacy\",\n            \"xml_delete\": \"dataPrivacy\",\n        },\n    )\n    sub_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"subType\",\n            \"xml_read\": \"subType\",\n            \"xml_update\": \"subType\",\n            \"xml_delete\": \"subType\",\n        },\n    )\n    start_expanded: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"startExpanded\",\n            \"xml_read\": \"startExpanded\",\n            \"xml_update\": \"startExpanded\",\n            \"xml_delete\": \"startExpanded\",\n        },\n    )\n    is_breakback_eligible: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isBreakbackEligible\",\n            \"xml_read\": \"isBreakbackEligible\",\n            \"xml_update\": \"isBreakbackEligible\",\n            \"xml_delete\": \"isBreakbackEligible\",\n        },\n    )\n    level_dim_rollup: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"levelDimRollup\",\n            \"xml_read\": \"levelDimRollup\",\n            \"xml_update\": \"levelDimRollup\",\n            \"xml_delete\": \"levelDimRollup\",\n        },\n    )\n    rollup_text: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"rollupText\",\n            \"xml_read\": \"rollupText\",\n            \"xml_update\": \"rollupText\",\n            \"xml_delete\": \"rollupText\",\n        },\n    )\n    enable_actuals: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"enableActuals\",\n            \"xml_read\": \"enableActuals\",\n            \"xml_update\": \"enableActuals\",\n            \"xml_delete\": \"enableActuals\",\n        },\n    )\n    is_group: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isGroup\",\n            \"xml_read\": \"isGroup\",\n            \"xml_update\": \"isGroup\",\n            \"xml_delete\": \"isGroup\",\n        },\n    )\n    is_intercompany: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isIntercompany\",\n            \"xml_read\": \"isIntercompany\",\n            \"xml_update\": \"isIntercompany\",\n            \"xml_delete\": \"isIntercompany\",\n        },\n    )\n    formula: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"formula\",\n            \"xml_read\": \"formula\",\n            \"xml_update\": \"formula\",\n            \"xml_delete\": \"formula\",\n        },\n    )\n    is_linked: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isLinked\",\n            \"xml_read\": \"isLinked\",\n            \"xml_update\": \"isLinked\",\n            \"xml_delete\": \"isLinked\",\n        },\n    )\n    is_system: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isSystem\",\n            \"xml_read\": \"isSystem\",\n            \"xml_update\": \"isSystem\",\n            \"xml_delete\": \"isSystem\",\n        },\n    )\n    owning_sheet_id: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"owningSheetId\",\n            \"xml_read\": \"owningSheetId\",\n            \"xml_update\": \"owningSheetId\",\n            \"xml_delete\": \"owningSheetId\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"accounts\",\n        \"xml_create_tag\": \"account\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"accounts\",\n        \"xml_read_tag\": \"account\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"accounts\",\n        \"xml_update_tag\": \"account\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"accounts\",\n        \"xml_delete_tag\": \"account\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.AdaptiveConnection","title":"<code>AdaptiveConnection</code>  <code>dataclass</code>","text":"<p>wdadaptivepy client for connection to Adaptive.</p> <p>Attributes:</p> Name Type Description <code>login</code> <code>str</code> <p>Adaptive Login</p> <code>password</code> <code>str</code> <p>Adaptive Password</p> <code>instance_code</code> <code>str | None</code> <p>Adaptive Instance Code</p> <code>caller_name</code> <code>str</code> <p>Adaptive Caller Name</p> <code>locale</code> <code>str | None</code> <p>Adaptive Locale</p> <code>xml_api_version</code> <code>int</code> <p>Adaptive XML API Version</p> <code>accounts</code> <code>AccountService</code> <p>wdadaptivepy AccountService</p> <code>attributes</code> <code>AttributeService</code> <p>wdadaptivepy AttributeService</p> <code>attribute_values</code> <code>AttributeValueService</code> <p>wdadaptivepy AttributeValueService</p> <code>currencies</code> <code>CurrencyService</code> <p>wdadaptivepy CurrencyService</p> <code>data</code> <code>DataService</code> <p>wdadaptivepy DataService</p> <code>dimensions</code> <code>DimensionService</code> <p>wdadaptivepy DimensionService</p> <code>dimension_values</code> <code>DimensionValueService</code> <p>wdadaptivepy DimensionValueService</p> <code>groups</code> <code>GroupService</code> <p>wdadaptivepy GroupService</p> <code>levels</code> <code>LevelService</code> <p>wdadaptivepy LevelService</p> <code>permission_sets</code> <code>PermissionSetService</code> <p>wdadaptivepy PermissionSetService</p> <code>time</code> <code>TimeService</code> <p>wdadaptivepy TimeService</p> <code>users</code> <code>UserService</code> <p>wdadaptivepy UserService</p> <code>versions</code> <code>VersionService</code> <p>wdadaptivepy VersionService</p> Source code in <code>src/wdadaptivepy/main.py</code> <pre><code>@dataclass\nclass AdaptiveConnection:\n    \"\"\"wdadaptivepy client for connection to Adaptive.\n\n    Attributes:\n        login: Adaptive Login\n        password: Adaptive Password\n        instance_code: Adaptive Instance Code\n        caller_name: Adaptive Caller Name\n        locale: Adaptive Locale\n        xml_api_version: Adaptive XML API Version\n        accounts (AccountService): wdadaptivepy AccountService\n        attributes (AttributeService): wdadaptivepy AttributeService\n        attribute_values (AttributeValueService): wdadaptivepy AttributeValueService\n        currencies (CurrencyService): wdadaptivepy CurrencyService\n        data (DataService): wdadaptivepy DataService\n        dimensions (DimensionService): wdadaptivepy DimensionService\n        dimension_values (DimensionValueService): wdadaptivepy DimensionValueService\n        groups (GroupService): wdadaptivepy GroupService\n        levels (LevelService): wdadaptivepy LevelService\n        permission_sets (PermissionSetService): wdadaptivepy PermissionSetService\n        time (TimeService): wdadaptivepy TimeService\n        users (UserService): wdadaptivepy UserService\n        versions (VersionService): wdadaptivepy VersionService\n\n    \"\"\"\n\n    login: str\n    password: str\n    instance_code: str | None = None\n    caller_name: str = DEFAULT_CALLER_NAME\n    locale: str | None = None\n    xml_api_version: int = MINIMUM_VERSION\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Clean up AdaptiveConnection instance.\"\"\"\n        self.__xml_api = XMLApi(\n            login=self.login,\n            password=self.password,\n            locale=self.locale,\n            instance_code=self.instance_code,\n            caller_name=self.caller_name,\n            version=self.xml_api_version,\n        )\n\n        self.accounts = AccountService(xml_api=self.__xml_api)\n        self.attributes = AttributeService(xml_api=self.__xml_api)\n        self.attribute_values = AttributeValueService(xml_api=self.__xml_api)\n        self.currencies = CurrencyService(xml_api=self.__xml_api)\n        self.data = DataService(xml_api=self.__xml_api)\n        self.dimensions = DimensionService(xml_api=self.__xml_api)\n        self.dimension_values = DimensionValueService(xml_api=self.__xml_api)\n        self.groups = GroupService(xml_api=self.__xml_api)\n        self.levels = LevelService(xml_api=self.__xml_api)\n        self.permission_sets = PermissionSetService(xml_api=self.__xml_api)\n        self.time = TimeService(xml_api=self.__xml_api)\n        self.users = UserService(xml_api=self.__xml_api)\n        self.versions = VersionService(xml_api=self.__xml_api)\n\n    def __setattr__(self, name: str, value: Any, /) -&gt; None:  # NOQA: ANN401\n        \"\"\"Force data to appropriate data type.\n\n        Args:\n            name: Name of field to modify\n            value: Value to modify\n\n        Raises:\n            RuntimeError: Unexpected value\n\n        \"\"\"\n        if getattr(self, \"_AdaptiveConnection__xml_api\", None):\n            if getattr(self.__xml_api, name.removeprefix(\"xml_api_\"), None):\n                setattr(self.__xml_api, name.removeprefix(\"xml_api_\"), value)\n            if getattr(self.__xml_api, name, None):\n                setattr(self.__xml_api, name, value)\n        super().__setattr__(name, value)\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.AdaptiveConnection.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Clean up AdaptiveConnection instance.</p> Source code in <code>src/wdadaptivepy/main.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Clean up AdaptiveConnection instance.\"\"\"\n    self.__xml_api = XMLApi(\n        login=self.login,\n        password=self.password,\n        locale=self.locale,\n        instance_code=self.instance_code,\n        caller_name=self.caller_name,\n        version=self.xml_api_version,\n    )\n\n    self.accounts = AccountService(xml_api=self.__xml_api)\n    self.attributes = AttributeService(xml_api=self.__xml_api)\n    self.attribute_values = AttributeValueService(xml_api=self.__xml_api)\n    self.currencies = CurrencyService(xml_api=self.__xml_api)\n    self.data = DataService(xml_api=self.__xml_api)\n    self.dimensions = DimensionService(xml_api=self.__xml_api)\n    self.dimension_values = DimensionValueService(xml_api=self.__xml_api)\n    self.groups = GroupService(xml_api=self.__xml_api)\n    self.levels = LevelService(xml_api=self.__xml_api)\n    self.permission_sets = PermissionSetService(xml_api=self.__xml_api)\n    self.time = TimeService(xml_api=self.__xml_api)\n    self.users = UserService(xml_api=self.__xml_api)\n    self.versions = VersionService(xml_api=self.__xml_api)\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.AdaptiveConnection.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>Force data to appropriate data type.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of field to modify</p> required <code>value</code> <code>Any</code> <p>Value to modify</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Unexpected value</p> Source code in <code>src/wdadaptivepy/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any, /) -&gt; None:  # NOQA: ANN401\n    \"\"\"Force data to appropriate data type.\n\n    Args:\n        name: Name of field to modify\n        value: Value to modify\n\n    Raises:\n        RuntimeError: Unexpected value\n\n    \"\"\"\n    if getattr(self, \"_AdaptiveConnection__xml_api\", None):\n        if getattr(self.__xml_api, name.removeprefix(\"xml_api_\"), None):\n            setattr(self.__xml_api, name.removeprefix(\"xml_api_\"), value)\n        if getattr(self.__xml_api, name, None):\n            setattr(self.__xml_api, name, value)\n    super().__setattr__(name, value)\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.Attribute","title":"<code>Attribute</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Attributes.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Attribute ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Attribute Name</p> <code>display_name_type</code> <code>str | None</code> <p>Adaptive Attribute Display Name Type</p> <code>attribute_type</code> <code>str | None</code> <p>Adaptive Attribute Type</p> <code>auto_create</code> <code>bool | None</code> <p>Adaptive Attribute Auto Create</p> <code>keep_sorted</code> <code>bool | None</code> <p>Adaptive Attribute Keep Sorted</p> <code>dimension_id</code> <code>int | None</code> <p>Adaptive Attribute Dimension ID</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy Attribute XML tags</p> Source code in <code>src/wdadaptivepy/models/attribute.py</code> <pre><code>@dataclass(eq=False)\nclass Attribute(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Attributes.\n\n    Attributes:\n        id: Adaptive Attribute ID\n        name: Adaptive Attribute Name\n        display_name_type: Adaptive Attribute Display Name Type\n        attribute_type: Adaptive Attribute Type\n        auto_create: Adaptive Attribute Auto Create\n        keep_sorted: Adaptive Attribute Keep Sorted\n        dimension_id: Adaptive Attribute Dimension ID\n        __xml_tags: wdadaptivepy Attribute XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    display_name_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayNameType\",\n            \"xml_read\": \"displayNameType\",\n            \"xml_update\": \"displayNameType\",\n            \"xml_delete\": \"displayNameType\",\n        },\n    )\n    attribute_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"type\",\n            \"xml_read\": \"type\",\n            \"xml_update\": \"type\",\n            \"xml_delete\": \"type\",\n        },\n    )\n    auto_create: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"autoCreate\",\n            \"xml_read\": \"autoCreate\",\n            \"xml_update\": \"autoCreate\",\n            \"xml_delete\": \"autoCreate\",\n        },\n    )\n    keep_sorted: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"keepSorted\",\n            \"xml_read\": \"keepSorted\",\n            \"xml_update\": \"keepSorted\",\n            \"xml_delete\": \"keepSorted\",\n        },\n    )\n    dimension_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"dimensionId\",\n            \"xml_read\": \"dimensionId\",\n            \"xml_update\": \"dimensionId\",\n            \"xml_delete\": \"dimensionId\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"attributes\",\n        \"xml_create_tag\": \"attribute\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"attributes\",\n        \"xml_read_tag\": \"attribute\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"attributes\",\n        \"xml_update_tag\": \"attribute\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"attributes\",\n        \"xml_delete_tag\": \"attribute\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.AttributeValue","title":"<code>AttributeValue</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierchialMetadata</code></p> <p>wdadaptivepy model for Adaptive's Attribute Values.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Attribute Value ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Attribute Value Code</p> <code>name</code> <code>str | None</code> <p>Adaptive Attribute Value Name</p> <code>display_name</code> <code>str | None</code> <p>Adaptive Attribute Value Display Name</p> <code>description</code> <code>str | None</code> <p>Adaptive Attribute Value Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy Attribute Value XML tags</p> Source code in <code>src/wdadaptivepy/models/attribute_value.py</code> <pre><code>@dataclass(eq=False)\nclass AttributeValue(HierchialMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Attribute Values.\n\n    Attributes:\n        id: Adaptive Attribute Value ID\n        code: Adaptive Attribute Value Code\n        name: Adaptive Attribute Value Name\n        display_name: Adaptive Attribute Value Display Name\n        description: Adaptive Attribute Value Description\n        __xml_tags: wdadaptivepy Attribute Value XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    display_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayName\",\n            \"xml_read\": \"displayName\",\n            \"xml_update\": \"displayName\",\n            \"xml_delete\": \"displayName\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"attribute\",\n        \"xml_create_tag\": \"attributeValue\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"attribute\",\n        \"xml_read_tag\": \"attributeValue\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"attribute\",\n        \"xml_update_tag\": \"attributeValue\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"attribute\",\n        \"xml_delete_tag\": \"attributeValue\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.Dimension","title":"<code>Dimension</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Dimensions.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Dimension ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Dimension Name</p> <code>code</code> <code>str | None</code> <p>Adaptive Dimension Code</p> <code>display_name_type</code> <code>str | None</code> <p>ADaptive Dimension Display Name Type</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Dimension Short Name</p> <code>auto_create</code> <code>bool | None</code> <p>Adaptive Dimension Auto Create</p> <code>list_dimension</code> <code>bool | None</code> <p>Adaptive Dimension List Dimension</p> <code>keep_sorted</code> <code>bool | None</code> <p>Adaptive Dimension Keep Sorted</p> <code>use_on_levels</code> <code>bool | None</code> <p>Adaptive Dimension Use On Levels</p> <code>seq_no</code> <code>str | None</code> <p>Adaptive Dimension Sequence Number</p> <code>description</code> <code>str | None</code> <p>Adaptive Dimension Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/dimension.py</code> <pre><code>@dataclass(eq=False)\nclass Dimension(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Dimensions.\n\n    Attributes:\n        id: Adaptive Dimension ID\n        name: Adaptive Dimension Name\n        code: Adaptive Dimension Code\n        display_name_type: ADaptive Dimension Display Name Type\n        short_name: Adaptive Dimension Short Name\n        auto_create: Adaptive Dimension Auto Create\n        list_dimension: Adaptive Dimension List Dimension\n        keep_sorted: Adaptive Dimension Keep Sorted\n        use_on_levels: Adaptive Dimension Use On Levels\n        seq_no: Adaptive Dimension Sequence Number\n        description: Adaptive Dimension Description\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    display_name_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayNameType\",\n            \"xml_read\": \"displayNameType\",\n            \"xml_update\": \"displayNameType\",\n            \"xml_delete\": \"displayNameType\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    auto_create: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"autoCreate\",\n            \"xml_read\": \"autoCreate\",\n            \"xml_update\": \"autoCreate\",\n            \"xml_delete\": \"autoCreate\",\n        },\n    )\n    list_dimension: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"listDimension\",\n            \"xml_read\": \"listDimension\",\n            \"xml_update\": \"listDimension\",\n            \"xml_delete\": \"listDimension\",\n        },\n    )\n    keep_sorted: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"keepSorted\",\n            \"xml_read\": \"keepSorted\",\n            \"xml_update\": \"keepSorted\",\n            \"xml_delete\": \"keepSorted\",\n        },\n    )\n    use_on_levels: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"useOnLevels\",\n            \"xml_read\": \"useOnLevels\",\n            \"xml_update\": \"useOnLevels\",\n            \"xml_delete\": \"useOnLevels\",\n        },\n    )\n    seq_no: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"seqNo\",\n            \"xml_read\": \"seqNo\",\n            \"xml_update\": \"seqNo\",\n            \"xml_delete\": \"seqNo\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"dimensions\",\n        \"xml_create_tag\": \"dimension\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"dimensions\",\n        \"xml_read_tag\": \"dimension\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"dimensions\",\n        \"xml_update_tag\": \"dimension\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"dimensions\",\n        \"xml_delete_tag\": \"dimension\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.DimensionValue","title":"<code>DimensionValue</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierarchialAttributedMetadata</code></p> <p>wdadaptivepy model for Adaptive's Dimension Values.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Dimension Value ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Dimension Value Code</p> <code>name</code> <code>str | None</code> <p>Adaptive Dimension Value Name</p> <code>display_name</code> <code>str | None</code> <p>Adaptive Dimension Value Display Name</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Dimension Value Short Name</p> <code>description</code> <code>str | None</code> <p>Adaptive Dimension Value Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/dimension_value.py</code> <pre><code>@dataclass(eq=False)\nclass DimensionValue(HierarchialAttributedMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Dimension Values.\n\n    Attributes:\n        id: Adaptive Dimension Value ID\n        code: Adaptive Dimension Value Code\n        name: Adaptive Dimension Value Name\n        display_name: Adaptive Dimension Value Display Name\n        short_name: Adaptive Dimension Value Short Name\n        description: Adaptive Dimension Value Description\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    display_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayName\",\n            \"xml_read\": \"displayName\",\n            \"xml_update\": \"displayName\",\n            \"xml_delete\": \"displayName\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"dimension\",\n        \"xml_create_tag\": \"dimensionValue\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"dimension\",\n        \"xml_read_tag\": \"dimensionValue\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"dimension\",\n        \"xml_update_tag\": \"dimensionValue\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"dimension\",\n        \"xml_delete_tag\": \"dimensionValue\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.Group","title":"<code>Group</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Groups.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Group ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Group Name</p> <code>is_global</code> <code>bool | None</code> <p>Adaptive Group Is Global</p> <code>owner_id</code> <code>str | None</code> <p>Adaptive Group Owner ID</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/group.py</code> <pre><code>@dataclass(eq=False)\nclass Group(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Groups.\n\n    Attributes:\n        id: Adaptive Group ID\n        name: Adaptive Group Name\n        is_global: Adaptive Group Is Global\n        owner_id: Adaptive Group Owner ID\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    is_global: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isGlobal\",\n            \"xml_read\": \"isGlobal\",\n            \"xml_update\": \"isGlobal\",\n            \"xml_delete\": \"isGlobal\",\n        },\n    )\n    owner_id: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"ownerId\",\n            \"xml_read\": \"ownerId\",\n            \"xml_update\": \"ownerId\",\n            \"xml_delete\": \"ownerId\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"groups\",\n        \"xml_create_tag\": \"group\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"groups\",\n        \"xml_read_tag\": \"group\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"groups\",\n        \"xml_update_tag\": \"group\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"groups\",\n        \"xml_delete_tag\": \"group\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.Level","title":"<code>Level</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierarchialAttributedMetadata</code></p> <p>wdadaptivepy model for Adaptive's Levels.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Level ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Level Code</p> <code>name</code> <code>str | None</code> <p>Adaptive Level Name</p> <code>display_name</code> <code>str | None</code> <p>Adaptive Level Display Name</p> <code>currency</code> <code>str | None</code> <p>Adaptive Level Currency</p> <code>publish_currency</code> <code>str | None</code> <p>Adaptive Level Publish Currency</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Level Short Name</p> <code>available_start</code> <code>str | None</code> <p>Adaptive Level Available Start</p> <code>available_end</code> <code>str | None</code> <p>Adaptive Level Available End</p> <code>is_importable</code> <code>bool | None</code> <p>Adaptive Level Is Importable</p> <code>workflow_status</code> <code>str | None</code> <p>Adaptive Level Workfalow Status</p> <code>is_elimination</code> <code>bool | None</code> <p>Adaptive Level Is Elimination</p> <code>is_linked</code> <code>bool | None</code> <p>Adaptive Level Is Linked</p> <code>has_children</code> <code>bool | None</code> <p>Adaptive Level Has Children</p> <code>description</code> <code>str | None</code> <p>Adaptive Level Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/level.py</code> <pre><code>@dataclass(eq=False)\nclass Level(HierarchialAttributedMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Levels.\n\n    Attributes:\n        id: Adaptive Level ID\n        code: Adaptive Level Code\n        name: Adaptive Level Name\n        display_name: Adaptive Level Display Name\n        currency: Adaptive Level Currency\n        publish_currency: Adaptive Level Publish Currency\n        short_name: Adaptive Level Short Name\n        available_start: Adaptive Level Available Start\n        available_end: Adaptive Level Available End\n        is_importable: Adaptive Level Is Importable\n        workflow_status: Adaptive Level Workfalow Status\n        is_elimination: Adaptive Level Is Elimination\n        is_linked: Adaptive Level Is Linked\n        has_children: Adaptive Level Has Children\n        description: Adaptive Level Description\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    display_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayName\",\n            \"xml_read\": \"displayName\",\n            \"xml_update\": \"displayName\",\n            \"xml_delete\": \"displayName\",\n        },\n    )\n    currency: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"currency\",\n            \"xml_read\": \"currency\",\n            \"xml_update\": \"currency\",\n            \"xml_delete\": \"currency\",\n        },\n    )\n    publish_currency: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"publishCurrency\",\n            \"xml_read\": \"publishCurrency\",\n            \"xml_update\": \"publishCurrency\",\n            \"xml_delete\": \"publishCurrency\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    available_start: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"availableStart\",\n            \"xml_read\": \"availableStart\",\n            \"xml_update\": \"availableStart\",\n            \"xml_delete\": \"availableStart\",\n        },\n    )\n    available_end: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"availableEnd\",\n            \"xml_read\": \"availableEnd\",\n            \"xml_update\": \"availableEnd\",\n            \"xml_delete\": \"availableEnd\",\n        },\n    )\n    is_importable: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isImportable\",\n            \"xml_read\": \"isImportable\",\n            \"xml_update\": \"isImportable\",\n            \"xml_delete\": \"isImportable\",\n        },\n    )\n    workflow_status: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"workflowStatus\",\n            \"xml_read\": \"workflowStatus\",\n            \"xml_update\": \"workflowStatus\",\n            \"xml_delete\": \"workflowStatus\",\n        },\n    )\n    is_elimination: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isElimination\",\n            \"xml_read\": \"isElimination\",\n            \"xml_update\": \"isElimination\",\n            \"xml_delete\": \"isElimination\",\n        },\n    )\n    is_linked: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isLinked\",\n            \"xml_read\": \"isLinked\",\n            \"xml_update\": \"isLinked\",\n            \"xml_delete\": \"isLinked\",\n        },\n    )\n    has_children: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"hasChildren\",\n            \"xml_read\": \"hasChildren\",\n            \"xml_update\": \"hasChildren\",\n            \"xml_delete\": \"hasChildren\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"levels\",\n        \"xml_create_tag\": \"level\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"levels\",\n        \"xml_read_tag\": \"level\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"levels\",\n        \"xml_update_tag\": \"level\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"levels\",\n        \"xml_delete_tag\": \"level\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.MetadataAttribute","title":"<code>MetadataAttribute</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>Attributes of BaseMetadata members.</p> <p>Attributes:</p> Name Type Description <code>attribute_id</code> <code>int | None</code> <p>Adaptive Attribute ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Attribute Name</p> <code>value_id</code> <code>int | None</code> <p>Adaptive Attribute Value ID</p> <code>value</code> <code>str | None</code> <p>Adaptive Attribute Value Name</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@dataclass(eq=False)\nclass MetadataAttribute(BaseMetadata):\n    \"\"\"Attributes of BaseMetadata members.\n\n    Attributes:\n        attribute_id: Adaptive Attribute ID\n        name: Adaptive Attribute Name\n        value_id: Adaptive Attribute Value ID\n        value: Adaptive Attribute Value Name\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    attribute_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"attributeId\",\n            \"xml_read\": \"attributeId\",\n            \"xml_update\": \"\",\n            \"xml_delete\": \"attributeId\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    value_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"valueId\",\n            \"xml_update\": \"\",\n            \"xml_delete\": \"\",\n        },\n    )\n    value: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"value\",\n            \"xml_read\": \"value\",\n            \"xml_update\": \"value\",\n            \"xml_delete\": \"value\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"attributes\",\n        \"xml_create_tag\": \"attribute\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"attributes\",\n        \"xml_read_tag\": \"attribute\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"attributes\",\n        \"xml_update_tag\": \"attribute\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"attributes\",\n        \"xml_delete_tag\": \"attribute\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.Period","title":"<code>Period</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierchialMetadata</code></p> <p>wdadaptivepy model for Adaptive's Periods.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>Adaptive Period Code</p> <code>label</code> <code>str | None</code> <p>Adaptive Period Label</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Period Short Name</p> <code>stratum_id</code> <code>int | None</code> <p>Adaptive Period Stratum ID</p> <code>id</code> <code>int | None</code> <p>Adaptive Period ID</p> <code>start</code> <code>str | None</code> <p>Adaptive Period Start</p> <code>end</code> <code>str | None</code> <p>Adaptive Period End</p> <code>legacy_report_time_id</code> <code>int | None</code> <p>Adaptive Period Legacy Report Time ID</p> <code>legacy_sheet_time_id</code> <code>int | None</code> <p>Adaptive Period Legacy Sheet Time ID</p> <code>locales</code> <code>MetadataList[TimeLocale]</code> <p>Adaptive Period Locales</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/time.py</code> <pre><code>@dataclass(eq=False)\nclass Period(HierchialMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Periods.\n\n    Attributes:\n        code: Adaptive Period Code\n        label: Adaptive Period Label\n        short_name: Adaptive Period Short Name\n        stratum_id: Adaptive Period Stratum ID\n        id: Adaptive Period ID\n        start: Adaptive Period Start\n        end: Adaptive Period End\n        legacy_report_time_id: Adaptive Period Legacy Report Time ID\n        legacy_sheet_time_id: Adaptive Period Legacy Sheet Time ID\n        locales: Adaptive Period Locales\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    label: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"label\",\n            \"xml_read\": \"label\",\n            \"xml_update\": \"label\",\n            \"xml_delete\": \"label\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    stratum_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"stratumId\",\n            \"xml_read\": \"stratumId\",\n            \"xml_update\": \"stratumId\",\n            \"xml_delete\": \"stratumId\",\n        },\n    )\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    start: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"start\",\n            \"xml_read\": \"start\",\n            \"xml_update\": \"start\",\n            \"xml_delete\": \"start\",\n        },\n    )\n    end: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"end\",\n            \"xml_read\": \"end\",\n            \"xml_update\": \"end\",\n            \"xml_delete\": \"end\",\n        },\n    )\n    legacy_report_time_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"legacyReportTimeId\",\n            \"xml_read\": \"legacyReportTimeId\",\n            \"xml_update\": \"legacyReportTimeId\",\n            \"xml_delete\": \"legacyReportTimeId\",\n        },\n    )\n    legacy_sheet_time_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"legacySheetTimeId\",\n            \"xml_read\": \"legacySheetTimeId\",\n            \"xml_update\": \"legacySheetTimeId\",\n            \"xml_delete\": \"legacySheetTimeId\",\n        },\n    )\n    locales: MetadataList[TimeLocale] = field(\n        default_factory=MetadataList[TimeLocale],\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"locales\",\n            \"xml_read\": \"locales\",\n            \"xml_update\": \"locales\",\n            \"xml_delete\": \"locales\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"periods\",\n        \"xml_create_tag\": \"period\",\n        \"xml_create_children\": {\"locales\": TimeLocale},\n        \"xml_read_parent_tag\": \"time\",\n        \"xml_read_tag\": \"period\",\n        \"xml_read_children\": {\"locales\": TimeLocale},\n        \"xml_update_parent_tag\": \"periods\",\n        \"xml_update_tag\": \"period\",\n        \"xml_update_children\": {\"locales\": TimeLocale},\n        \"xml_delete_parent_tag\": \"periods\",\n        \"xml_delete_tag\": \"period\",\n        \"xml_delete_children\": {\"locales\": TimeLocale},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.PermissionSet","title":"<code>PermissionSet</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Permission Sets.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Permission Set ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Permission Set Name</p> <code>permissions</code> <code>str | None</code> <p>Adaptive Permission Set Permissions</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/permission_set.py</code> <pre><code>@dataclass(eq=False)\nclass PermissionSet(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Permission Sets.\n\n    Attributes:\n        id: Adaptive Permission Set ID\n        name: Adaptive Permission Set Name\n        permissions: Adaptive Permission Set Permissions\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    permissions: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"permissions\",\n            \"xml_read\": \"permissions\",\n            \"xml_update\": \"permissions\",\n            \"xml_delete\": \"permissions\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"permission_sets\",\n        \"xml_create_tag\": \"permission_set\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"permission_sets\",\n        \"xml_read_tag\": \"permission_set\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"permission_sets\",\n        \"xml_update_tag\": \"permission_set\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"permission_sets\",\n        \"xml_delete_tag\": \"permission_set\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.Stratum","title":"<code>Stratum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierchialMetadata</code></p> <p>wdadaptivepy model for Adaptive's Stratum.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>Adaptive Stratum Code</p> <code>label</code> <code>str | None</code> <p>Adaptive Stratum Label</p> <code>short_name</code> <code>str | None</code> <p>ADaptive Stratum Short Name</p> <code>id</code> <code>int | None</code> <p>Adaptive Stratum ID</p> <code>in_use</code> <code>bool | None</code> <p>Adaptive Stratum In Use</p> <code>is_default</code> <code>bool | None</code> <p>Adaptive Stratum Is Default</p> <code>locales</code> <code>MetadataList[TimeLocale]</code> <p>Adaptive Stratum Locales</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/time.py</code> <pre><code>@dataclass(eq=False)\nclass Stratum(HierchialMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Stratum.\n\n    Attributes:\n        code: Adaptive Stratum Code\n        label: Adaptive Stratum Label\n        short_name: ADaptive Stratum Short Name\n        id: Adaptive Stratum ID\n        in_use: Adaptive Stratum In Use\n        is_default: Adaptive Stratum Is Default\n        locales: Adaptive Stratum Locales\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    label: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"label\",\n            \"xml_read\": \"label\",\n            \"xml_update\": \"label\",\n            \"xml_delete\": \"label\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    in_use: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"inUse\",\n            \"xml_read\": \"inUse\",\n            \"xml_update\": \"inUse\",\n            \"xml_delete\": \"inUse\",\n        },\n    )\n    is_default: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isDefault\",\n            \"xml_read\": \"isDefault\",\n            \"xml_update\": \"isDefault\",\n            \"xml_delete\": \"isDefault\",\n        },\n    )\n    locales: MetadataList[TimeLocale] = field(\n        default_factory=MetadataList[TimeLocale],\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"locales\",\n            \"xml_read\": \"locales\",\n            \"xml_update\": \"locales\",\n            \"xml_delete\": \"locales\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"stratums\",\n        \"xml_create_tag\": \"stratum\",\n        \"xml_create_children\": {\"locales\": TimeLocale},\n        \"xml_read_parent_tag\": \"time\",\n        \"xml_read_tag\": \"stratum\",\n        \"xml_read_children\": {\"locales\": TimeLocale},\n        \"xml_update_parent_tag\": \"stratums\",\n        \"xml_update_tag\": \"stratum\",\n        \"xml_update_children\": {\"locales\": TimeLocale},\n        \"xml_delete_parent_tag\": \"stratums\",\n        \"xml_delete_tag\": \"stratum\",\n        \"xml_delete_children\": {\"locales\": TimeLocale},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.Time","title":"<code>Time</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Time.</p> <p>Attributes:</p> Name Type Description <code>is_custom</code> <code>bool | None</code> <p>Adaptive Time Is Custom</p> <code>q_first_month</code> <code>int | None</code> <p>Adaptive Time Quarter First Month</p> <code>last_month_is_fy</code> <code>bool | None</code> <p>Adaptive Time Last Month Is Fiscal Year</p> <code>seq_no</code> <code>str | None</code> <p>Adaptive Time Sequence Number</p> <code>stratum</code> <code>MetadataList[Stratum]</code> <p>Adaptive Time Stratum</p> <code>period</code> <code>MetadataList[Period]</code> <p>Adaptive Time Period</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/time.py</code> <pre><code>@dataclass(eq=False)\nclass Time(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Time.\n\n    Attributes:\n        is_custom: Adaptive Time Is Custom\n        q_first_month: Adaptive Time Quarter First Month\n        last_month_is_fy: Adaptive Time Last Month Is Fiscal Year\n        seq_no: Adaptive Time Sequence Number\n        stratum: Adaptive Time Stratum\n        period: Adaptive Time Period\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    is_custom: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isCustom\",\n            \"xml_read\": \"isCustom\",\n            \"xml_update\": \"isCustom\",\n            \"xml_delete\": \"isCustom\",\n        },\n    )\n    q_first_month: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"qFirstMonth\",\n            \"xml_read\": \"qFirstMonth\",\n            \"xml_update\": \"qFirstMonth\",\n            \"xml_delete\": \"qFirstMonth\",\n        },\n    )\n    last_month_is_fy: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"lastMonthIsFy\",\n            \"xml_read\": \"lastMonthIsFy\",\n            \"xml_update\": \"lastMonthIsFy\",\n            \"xml_delete\": \"lastMonthIsFy\",\n        },\n    )\n    seq_no: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"seqNo\",\n            \"xml_read\": \"seqNo\",\n            \"xml_update\": \"seqNo\",\n            \"xml_delete\": \"seqNo\",\n        },\n    )\n    stratum: MetadataList[Stratum] = field(\n        default_factory=MetadataList[Stratum],\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"stratum\",\n            \"xml_read\": \"stratum\",\n            \"xml_update\": \"stratum\",\n            \"xml_delete\": \"stratum\",\n        },\n    )\n    period: MetadataList[Period] = field(\n        default_factory=MetadataList[Period],\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"period\",\n            \"xml_read\": \"period\",\n            \"xml_update\": \"period\",\n            \"xml_delete\": \"period\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"times\",\n        \"xml_create_tag\": \"time\",\n        \"xml_create_children\": {\"stratum\": Stratum, \"period\": Period},\n        \"xml_read_parent_tag\": \"times\",\n        \"xml_read_tag\": \"time\",\n        \"xml_read_children\": {\"stratum\": Stratum, \"period\": Period},\n        \"xml_update_parent_tag\": \"times\",\n        \"xml_update_tag\": \"time\",\n        \"xml_update_children\": {\"stratum\": Stratum, \"period\": Period},\n        \"xml_delete_parent_tag\": \"times\",\n        \"xml_delete_tag\": \"time\",\n        \"xml_delete_children\": {\"stratum\": Stratum, \"period\": Period},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.User","title":"<code>User</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Users.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive User ID</p> <code>guid</code> <code>str | None</code> <p>Adaptive User GUID</p> <code>login</code> <code>str | None</code> <p>Adaptive User Login</p> <code>email</code> <code>str | None</code> <p>Adaptive User Email</p> <code>name</code> <code>str | None</code> <p>Adaptive User Name</p> <code>position</code> <code>str | None</code> <p>Adaptive User Position</p> <code>permission_set_ids</code> <code>list[int] | None</code> <p>Adaptive User Permission Set IDs</p> <code>alternate_email</code> <code>str | None</code> <p>Adaptive User Alternate Email</p> <code>saml_fed_id</code> <code>str | None</code> <p>Adaptive User SAML Federation ID</p> <code>time_zone</code> <code>str | None</code> <p>Adaptive User Time Zone</p> <code>homepage</code> <code>str | None</code> <p>Adaptive User Homepage</p> <code>country</code> <code>str | None</code> <p>Adaptive User Country</p> <code>us_state</code> <code>str | None</code> <p>Adaptive User US State</p> <code>perspective</code> <code>str | None</code> <p>Adaptive User Perspective</p> <code>perspective_name</code> <code>str | None</code> <p>Adaptive User Perspective Name</p> <code>dashboard</code> <code>str | None</code> <p>Adaptive User Dashboard</p> <code>dashboard_name</code> <code>str | None</code> <p>Adaptive User Dashboard Name</p> <code>netsuite_login</code> <code>str | None</code> <p>Adaptive User NetSuite Login</p> <code>salesforce_login</code> <code>str | None</code> <p>Adaptive User Salesforce Login</p> <code>created_date</code> <code>datetime | None</code> <p>Adaptive User Created Date</p> <code>last_login</code> <code>datetime | None</code> <p>Adaptive User Last Login</p> <code>failed_attempts</code> <code>int | None</code> <p>Adaptive User Failed Attempts</p> <code>locked</code> <code>bool | None</code> <p>Adaptive User Locked</p> <code>subscriptions</code> <code>Subscription | None</code> <p>Adaptive User Subscriptions</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/user.py</code> <pre><code>@dataclass(eq=False)\nclass User(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Users.\n\n    Attributes:\n        id: Adaptive User ID\n        guid: Adaptive User GUID\n        login: Adaptive User Login\n        email: Adaptive User Email\n        name: Adaptive User Name\n        position: Adaptive User Position\n        permission_set_ids: Adaptive User Permission Set IDs\n        alternate_email: Adaptive User Alternate Email\n        saml_fed_id: Adaptive User SAML Federation ID\n        time_zone: Adaptive User Time Zone\n        homepage: Adaptive User Homepage\n        country: Adaptive User Country\n        us_state: Adaptive User US State\n        perspective: Adaptive User Perspective\n        perspective_name: Adaptive User Perspective Name\n        dashboard: Adaptive User Dashboard\n        dashboard_name:Adaptive User Dashboard Name\n        netsuite_login: Adaptive User NetSuite Login\n        salesforce_login: Adaptive User Salesforce Login\n        created_date: Adaptive User Created Date\n        last_login: Adaptive User Last Login\n        failed_attempts: Adaptive User Failed Attempts\n        locked: Adaptive User Locked\n        subscriptions: Adaptive User Subscriptions\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    guid: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"guid\",\n            \"xml_read\": \"guid\",\n            \"xml_update\": \"guid\",\n            \"xml_delete\": \"guid\",\n        },\n    )\n    login: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"login\",\n            \"xml_read\": \"login\",\n            \"xml_update\": \"login\",\n            \"xml_delete\": \"login\",\n        },\n    )\n    email: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"email\",\n            \"xml_read\": \"email\",\n            \"xml_update\": \"email\",\n            \"xml_delete\": \"email\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    position: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"position\",\n            \"xml_read\": \"position\",\n            \"xml_update\": \"position\",\n            \"xml_delete\": \"position\",\n        },\n    )\n    permission_set_ids: list[int] | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_list_or_none,\n            \"xml_parser\": int_list_to_str,\n            \"xml_create\": \"permissionSetIds\",\n            \"xml_read\": \"permissionSetIds\",\n            \"xml_update\": \"permissionSetIds\",\n            \"xml_delete\": \"permissionSetIds\",\n        },\n    )\n    alternate_email: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"alternateEmail\",\n            \"xml_read\": \"alternateEmail\",\n            \"xml_update\": \"alternateEmail\",\n            \"xml_delete\": \"alternateEmail\",\n        },\n    )\n    saml_fed_id: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"samlFedId\",\n            \"xml_read\": \"samlFedId\",\n            \"xml_update\": \"samlFedId\",\n            \"xml_delete\": \"samlFedId\",\n        },\n    )\n    time_zone: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"timeZone\",\n            \"xml_read\": \"timeZone\",\n            \"xml_update\": \"timeZone\",\n            \"xml_delete\": \"timeZone\",\n        },\n    )\n    homepage: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"homepage\",\n            \"xml_read\": \"homepage\",\n            \"xml_update\": \"homepage\",\n            \"xml_delete\": \"homepage\",\n        },\n    )\n    country: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"country\",\n            \"xml_read\": \"country\",\n            \"xml_update\": \"country\",\n            \"xml_delete\": \"country\",\n        },\n    )\n    us_state: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"usState\",\n            \"xml_read\": \"usState\",\n            \"xml_update\": \"usState\",\n            \"xml_delete\": \"usState\",\n        },\n    )\n    perspective: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"perspective\",\n            \"xml_read\": \"perspective\",\n            \"xml_update\": \"perspective\",\n            \"xml_delete\": \"perspective\",\n        },\n    )\n    perspective_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"perspectiveName\",\n            \"xml_read\": \"perspectiveName\",\n            \"xml_update\": \"perspectiveName\",\n            \"xml_delete\": \"perspectiveName\",\n        },\n    )\n    dashboard: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"dashboard\",\n            \"xml_read\": \"dashboard\",\n            \"xml_update\": \"dashboard\",\n            \"xml_delete\": \"dashboard\",\n        },\n    )\n    dashboard_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"dashboardName\",\n            \"xml_read\": \"dashboardName\",\n            \"xml_update\": \"dashboardName\",\n            \"xml_delete\": \"dashboardName\",\n        },\n    )\n    netsuite_login: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"netsuiteLogin\",\n            \"xml_read\": \"netsuiteLogin\",\n            \"xml_update\": \"netsuiteLogin\",\n            \"xml_delete\": \"netsuiteLogin\",\n        },\n    )\n    salesforce_login: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"salesforceLogin\",\n            \"xml_read\": \"salesforceLogin\",\n            \"xml_update\": \"salesforceLogin\",\n            \"xml_delete\": \"salesforceLogin\",\n        },\n    )\n    created_date: datetime | None = field(\n        default=None,\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"createdDate\",\n            \"xml_read\": \"createdDate\",\n            \"xml_update\": \"createdDate\",\n            \"xml_delete\": \"createdDate\",\n        },\n    )\n    last_login: datetime | None = field(\n        default=None,\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"lastLogin\",\n            \"xml_read\": \"lastLogin\",\n            \"xml_update\": \"lastLogin\",\n            \"xml_delete\": \"lastLogin\",\n        },\n    )\n    failed_attempts: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"failedAttempts\",\n            \"xml_read\": \"failedAttempts\",\n            \"xml_update\": \"failedAttempts\",\n            \"xml_delete\": \"failedAttempts\",\n        },\n    )\n    locked: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"locked\",\n            \"xml_read\": \"locked\",\n            \"xml_update\": \"locked\",\n            \"xml_delete\": \"locked\",\n        },\n    )\n    subscriptions: Subscription | None = field(\n        default=None,\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"subscriptions\",\n            \"xml_read\": \"subscriptions\",\n            \"xml_update\": \"subscriptions\",\n            \"xml_delete\": \"subscriptions\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"users\",\n        \"xml_create_tag\": \"user\",\n        \"xml_create_children\": {\"subscriptions\": Subscription},\n        \"xml_read_parent_tag\": \"users\",\n        \"xml_read_tag\": \"user\",\n        \"xml_read_children\": {\"subscriptions\": Subscription},\n        \"xml_update_parent_tag\": \"users\",\n        \"xml_update_tag\": \"user\",\n        \"xml_update_children\": {\"subscriptions\": Subscription},\n        \"xml_delete_parent_tag\": \"users\",\n        \"xml_delete_tag\": \"user\",\n        \"xml_delete_children\": {\"subscriptions\": Subscription},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/__init__/#wdadaptivepy.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierchialMetadata</code></p> <p>wdadaptivepy model for Adaptive's Versions.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Version ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Version Name</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Version Short Name</p> <code>version_type</code> <code>str | None</code> <p>Adaptive Version Type</p> <code>is_virtual</code> <code>bool | None</code> <p>Adaptive Version Is Virtual</p> <code>description</code> <code>str | None</code> <p>Adaptive Version Description</p> <code>is_default_version</code> <code>bool | None</code> <p>Adaptive Version Is Default Version</p> <code>is_locked</code> <code>bool | None</code> <p>Adaptive Version Is Locked</p> <code>has_audit_trail</code> <code>bool | None</code> <p>Adaptive Version Has Audit Trail</p> <code>enabled_for_workflow</code> <code>bool | None</code> <p>Adaptive Version Enabled for Workflow</p> <code>is_importable</code> <code>bool | None</code> <p>Adaptive Version Is Importable</p> <code>start_ver</code> <code>str | None</code> <p>Adaptive Version Start of Version</p> <code>end_ver</code> <code>str | None</code> <p>Adaptive Version End of Version</p> <code>start_scroll</code> <code>str | None</code> <p>Adaptive Version Start Scroll</p> <code>completed_values_thru</code> <code>str | None</code> <p>Adaptive Version Complted Values Through</p> <code>left_scroll</code> <code>str | None</code> <p>Adaptive Version Left Scroll</p> <code>start_plan</code> <code>str | None</code> <p>Adaptive Version Start Plan</p> <code>end_plan</code> <code>str | None</code> <p>ADaptive Version End Plan</p> <code>lock_leading</code> <code>str | None</code> <p>Adaptive Version Lock Leading</p> <code>is_predictive</code> <code>bool | None</code> <p>Adaptive Version Is Predictive</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/version.py</code> <pre><code>@dataclass(eq=False)\nclass Version(HierchialMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Versions.\n\n    Attributes:\n        id: Adaptive Version ID\n        name: Adaptive Version Name\n        short_name: Adaptive Version Short Name\n        version_type: Adaptive Version Type\n        is_virtual: Adaptive Version Is Virtual\n        description: Adaptive Version Description\n        is_default_version: Adaptive Version Is Default Version\n        is_locked: Adaptive Version Is Locked\n        has_audit_trail: Adaptive Version Has Audit Trail\n        enabled_for_workflow: Adaptive Version Enabled for Workflow\n        is_importable: Adaptive Version Is Importable\n        start_ver: Adaptive Version Start of Version\n        end_ver: Adaptive Version End of Version\n        start_scroll: Adaptive Version Start Scroll\n        completed_values_thru: Adaptive Version Complted Values Through\n        left_scroll: Adaptive Version Left Scroll\n        start_plan: Adaptive Version Start Plan\n        end_plan: ADaptive Version End Plan\n        lock_leading: Adaptive Version Lock Leading\n        is_predictive: Adaptive Version Is Predictive\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    version_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"type\",\n            \"xml_read\": \"type\",\n            \"xml_update\": \"type\",\n            \"xml_delete\": \"type\",\n        },\n    )\n    is_virtual: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isVirtual\",\n            \"xml_read\": \"isVirtual\",\n            \"xml_update\": \"isVirtual\",\n            \"xml_delete\": \"isVirtual\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    is_default_version: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isDefaultVersion\",\n            \"xml_read\": \"isDefaultVersion\",\n            \"xml_update\": \"isDefaultVersion\",\n            \"xml_delete\": \"isDefaultVersion\",\n        },\n    )\n    is_locked: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isLocked\",\n            \"xml_read\": \"isLocked\",\n            \"xml_update\": \"isLocked\",\n            \"xml_delete\": \"isLocked\",\n        },\n    )\n    has_audit_trail: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"hasAuditTrail\",\n            \"xml_read\": \"hasAuditTrail\",\n            \"xml_update\": \"hasAuditTrail\",\n            \"xml_delete\": \"hasAuditTrail\",\n        },\n    )\n    enabled_for_workflow: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"enabledForWorkflow\",\n            \"xml_read\": \"enabledForWorkflow\",\n            \"xml_update\": \"enabledForWorkflow\",\n            \"xml_delete\": \"enabledForWorkflow\",\n        },\n    )\n    is_importable: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isImportable\",\n            \"xml_read\": \"isImportable\",\n            \"xml_update\": \"isImportable\",\n            \"xml_delete\": \"isImportable\",\n        },\n    )\n    start_ver: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"startVer\",\n            \"xml_read\": \"startVer\",\n            \"xml_update\": \"startVer\",\n            \"xml_delete\": \"startVer\",\n        },\n    )\n    end_ver: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"endVer\",\n            \"xml_read\": \"endVer\",\n            \"xml_update\": \"endVer\",\n            \"xml_delete\": \"endVer\",\n        },\n    )\n    start_scroll: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"startScroll\",\n            \"xml_read\": \"startScroll\",\n            \"xml_update\": \"startScroll\",\n            \"xml_delete\": \"startScroll\",\n        },\n    )\n    completed_values_thru: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"completedValuesThru\",\n            \"xml_read\": \"completedValuesThru\",\n            \"xml_update\": \"completedValuesThru\",\n            \"xml_delete\": \"completedValuesThru\",\n        },\n    )\n    left_scroll: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"leftScroll\",\n            \"xml_read\": \"leftScroll\",\n            \"xml_update\": \"leftScroll\",\n            \"xml_delete\": \"leftScroll\",\n        },\n    )\n    start_plan: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"startPlan\",\n            \"xml_read\": \"startPlan\",\n            \"xml_update\": \"startPlan\",\n            \"xml_delete\": \"startPlan\",\n        },\n    )\n    end_plan: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"endPlan\",\n            \"xml_read\": \"endPlan\",\n            \"xml_update\": \"endPlan\",\n            \"xml_delete\": \"endPlan\",\n        },\n    )\n    lock_leading: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"lockLeading\",\n            \"xml_read\": \"lockLeading\",\n            \"xml_update\": \"lockLeading\",\n            \"xml_delete\": \"lockLeading\",\n        },\n    )\n    is_predictive: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isPredictive\",\n            \"xml_read\": \"isPredictive\",\n            \"xml_update\": \"isPredictive\",\n            \"xml_delete\": \"isPredictive\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"versions\",\n        \"xml_create_tag\": \"version\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"versions\",\n        \"xml_read_tag\": \"version\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"versions\",\n        \"xml_update_tag\": \"version\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"versions\",\n        \"xml_delete_tag\": \"version\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/main/","title":"main","text":"<p>wdadaptivepy main entry.</p>"},{"location":"reference/wdadaptivepy/main/#wdadaptivepy.main.AdaptiveConnection","title":"<code>AdaptiveConnection</code>  <code>dataclass</code>","text":"<p>wdadaptivepy client for connection to Adaptive.</p> <p>Attributes:</p> Name Type Description <code>login</code> <code>str</code> <p>Adaptive Login</p> <code>password</code> <code>str</code> <p>Adaptive Password</p> <code>instance_code</code> <code>str | None</code> <p>Adaptive Instance Code</p> <code>caller_name</code> <code>str</code> <p>Adaptive Caller Name</p> <code>locale</code> <code>str | None</code> <p>Adaptive Locale</p> <code>xml_api_version</code> <code>int</code> <p>Adaptive XML API Version</p> <code>accounts</code> <code>AccountService</code> <p>wdadaptivepy AccountService</p> <code>attributes</code> <code>AttributeService</code> <p>wdadaptivepy AttributeService</p> <code>attribute_values</code> <code>AttributeValueService</code> <p>wdadaptivepy AttributeValueService</p> <code>currencies</code> <code>CurrencyService</code> <p>wdadaptivepy CurrencyService</p> <code>data</code> <code>DataService</code> <p>wdadaptivepy DataService</p> <code>dimensions</code> <code>DimensionService</code> <p>wdadaptivepy DimensionService</p> <code>dimension_values</code> <code>DimensionValueService</code> <p>wdadaptivepy DimensionValueService</p> <code>groups</code> <code>GroupService</code> <p>wdadaptivepy GroupService</p> <code>levels</code> <code>LevelService</code> <p>wdadaptivepy LevelService</p> <code>permission_sets</code> <code>PermissionSetService</code> <p>wdadaptivepy PermissionSetService</p> <code>time</code> <code>TimeService</code> <p>wdadaptivepy TimeService</p> <code>users</code> <code>UserService</code> <p>wdadaptivepy UserService</p> <code>versions</code> <code>VersionService</code> <p>wdadaptivepy VersionService</p> Source code in <code>src/wdadaptivepy/main.py</code> <pre><code>@dataclass\nclass AdaptiveConnection:\n    \"\"\"wdadaptivepy client for connection to Adaptive.\n\n    Attributes:\n        login: Adaptive Login\n        password: Adaptive Password\n        instance_code: Adaptive Instance Code\n        caller_name: Adaptive Caller Name\n        locale: Adaptive Locale\n        xml_api_version: Adaptive XML API Version\n        accounts (AccountService): wdadaptivepy AccountService\n        attributes (AttributeService): wdadaptivepy AttributeService\n        attribute_values (AttributeValueService): wdadaptivepy AttributeValueService\n        currencies (CurrencyService): wdadaptivepy CurrencyService\n        data (DataService): wdadaptivepy DataService\n        dimensions (DimensionService): wdadaptivepy DimensionService\n        dimension_values (DimensionValueService): wdadaptivepy DimensionValueService\n        groups (GroupService): wdadaptivepy GroupService\n        levels (LevelService): wdadaptivepy LevelService\n        permission_sets (PermissionSetService): wdadaptivepy PermissionSetService\n        time (TimeService): wdadaptivepy TimeService\n        users (UserService): wdadaptivepy UserService\n        versions (VersionService): wdadaptivepy VersionService\n\n    \"\"\"\n\n    login: str\n    password: str\n    instance_code: str | None = None\n    caller_name: str = DEFAULT_CALLER_NAME\n    locale: str | None = None\n    xml_api_version: int = MINIMUM_VERSION\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Clean up AdaptiveConnection instance.\"\"\"\n        self.__xml_api = XMLApi(\n            login=self.login,\n            password=self.password,\n            locale=self.locale,\n            instance_code=self.instance_code,\n            caller_name=self.caller_name,\n            version=self.xml_api_version,\n        )\n\n        self.accounts = AccountService(xml_api=self.__xml_api)\n        self.attributes = AttributeService(xml_api=self.__xml_api)\n        self.attribute_values = AttributeValueService(xml_api=self.__xml_api)\n        self.currencies = CurrencyService(xml_api=self.__xml_api)\n        self.data = DataService(xml_api=self.__xml_api)\n        self.dimensions = DimensionService(xml_api=self.__xml_api)\n        self.dimension_values = DimensionValueService(xml_api=self.__xml_api)\n        self.groups = GroupService(xml_api=self.__xml_api)\n        self.levels = LevelService(xml_api=self.__xml_api)\n        self.permission_sets = PermissionSetService(xml_api=self.__xml_api)\n        self.time = TimeService(xml_api=self.__xml_api)\n        self.users = UserService(xml_api=self.__xml_api)\n        self.versions = VersionService(xml_api=self.__xml_api)\n\n    def __setattr__(self, name: str, value: Any, /) -&gt; None:  # NOQA: ANN401\n        \"\"\"Force data to appropriate data type.\n\n        Args:\n            name: Name of field to modify\n            value: Value to modify\n\n        Raises:\n            RuntimeError: Unexpected value\n\n        \"\"\"\n        if getattr(self, \"_AdaptiveConnection__xml_api\", None):\n            if getattr(self.__xml_api, name.removeprefix(\"xml_api_\"), None):\n                setattr(self.__xml_api, name.removeprefix(\"xml_api_\"), value)\n            if getattr(self.__xml_api, name, None):\n                setattr(self.__xml_api, name, value)\n        super().__setattr__(name, value)\n</code></pre>"},{"location":"reference/wdadaptivepy/main/#wdadaptivepy.main.AdaptiveConnection.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Clean up AdaptiveConnection instance.</p> Source code in <code>src/wdadaptivepy/main.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Clean up AdaptiveConnection instance.\"\"\"\n    self.__xml_api = XMLApi(\n        login=self.login,\n        password=self.password,\n        locale=self.locale,\n        instance_code=self.instance_code,\n        caller_name=self.caller_name,\n        version=self.xml_api_version,\n    )\n\n    self.accounts = AccountService(xml_api=self.__xml_api)\n    self.attributes = AttributeService(xml_api=self.__xml_api)\n    self.attribute_values = AttributeValueService(xml_api=self.__xml_api)\n    self.currencies = CurrencyService(xml_api=self.__xml_api)\n    self.data = DataService(xml_api=self.__xml_api)\n    self.dimensions = DimensionService(xml_api=self.__xml_api)\n    self.dimension_values = DimensionValueService(xml_api=self.__xml_api)\n    self.groups = GroupService(xml_api=self.__xml_api)\n    self.levels = LevelService(xml_api=self.__xml_api)\n    self.permission_sets = PermissionSetService(xml_api=self.__xml_api)\n    self.time = TimeService(xml_api=self.__xml_api)\n    self.users = UserService(xml_api=self.__xml_api)\n    self.versions = VersionService(xml_api=self.__xml_api)\n</code></pre>"},{"location":"reference/wdadaptivepy/main/#wdadaptivepy.main.AdaptiveConnection.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>Force data to appropriate data type.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of field to modify</p> required <code>value</code> <code>Any</code> <p>Value to modify</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Unexpected value</p> Source code in <code>src/wdadaptivepy/main.py</code> <pre><code>def __setattr__(self, name: str, value: Any, /) -&gt; None:  # NOQA: ANN401\n    \"\"\"Force data to appropriate data type.\n\n    Args:\n        name: Name of field to modify\n        value: Value to modify\n\n    Raises:\n        RuntimeError: Unexpected value\n\n    \"\"\"\n    if getattr(self, \"_AdaptiveConnection__xml_api\", None):\n        if getattr(self.__xml_api, name.removeprefix(\"xml_api_\"), None):\n            setattr(self.__xml_api, name.removeprefix(\"xml_api_\"), value)\n        if getattr(self.__xml_api, name, None):\n            setattr(self.__xml_api, name, value)\n    super().__setattr__(name, value)\n</code></pre>"},{"location":"reference/wdadaptivepy/connectors/__init__/","title":"init","text":"<p>Adaptive API connections.</p>"},{"location":"reference/wdadaptivepy/connectors/__init__/#wdadaptivepy.connectors.XMLApi","title":"<code>XMLApi</code>  <code>dataclass</code>","text":"<p>Class to handle all XML API related methods.</p> <p>Attributes:</p> Name Type Description <code>login</code> <code>str</code> <p>Adaptive username/login</p> <code>password</code> <code>str</code> <p>Adaptive password</p> <code>locale</code> <code>str | None</code> <p>Locale for text translations and data formats</p> <code>instance_code</code> <code>str | None</code> <p>Adaptive tenant/instance code</p> <code>caller_name</code> <code>str</code> <p>Identifier used within Adaptive's logs</p> <code>version</code> <code>int</code> <p>Version of Adaptive's XML API</p> Source code in <code>src/wdadaptivepy/connectors/xml_api/xml_api.py</code> <pre><code>@dataclass\nclass XMLApi:\n    \"\"\"Class to handle all XML API related methods.\n\n    Attributes:\n        login: Adaptive username/login\n        password: Adaptive password\n        locale: Locale for text translations and data formats\n        instance_code: Adaptive tenant/instance code\n        caller_name: Identifier used within Adaptive's logs\n        version: Version of Adaptive's XML API\n\n    \"\"\"\n\n    login: str\n    password: str\n    locale: str | None = None  # add default Locale and make it an enum\n    instance_code: str | None = None\n    caller_name: str = DEFAULT_CALLER_NAME\n    version: int = MINIMUM_VERSION\n\n    def __generate_xml_call(\n        self,\n        method: str,\n        payload: ET.Element | Sequence[ET.Element] | None,\n    ) -&gt; ET.Element:\n        call = ET.Element(\n            \"call\",\n            attrib={\"method\": method, \"callerName\": self.caller_name},\n        )\n        credentials = ET.Element(\n            \"credentials\",\n            attrib={\n                \"login\": self.login,\n                \"password\": self.password,\n            },\n        )\n        if self.locale:\n            credentials.attrib[\"locale\"] = self.locale\n        if self.instance_code:\n            credentials.attrib[\"instanceCode\"] = self.instance_code\n        call.append(credentials)\n        if payload is not None:\n            if isinstance(payload, ET.Element):\n                call.append(payload)\n            elif isinstance(payload, Sequence):\n                if not all(isinstance(element, ET.Element) for element in payload):\n                    error_message = \"Expected XML Element Tree Element\"\n                    raise TypeError(error_message)\n                call.extend(payload)\n        return call\n\n    def preview_xml_request(\n        self,\n        method: str,\n        payload: ET.Element | Sequence[ET.Element] | None,\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate XML call body (does not send to Adaptive) for review.\n\n        Args:\n            method: Adaptive XML API name\n            payload: Body of XML API call\n            hide_password: Hide password from output\n\n        Returns:\n            XML Element of API call\n\n        \"\"\"\n        call = self.__generate_xml_call(method, payload)\n        credentials = call.find(\"credentials\")\n        if hide_password is True and credentials is not None:\n            credentials.attrib[\"password\"] = \"*\" * len(credentials.attrib[\"password\"])\n        return call\n\n    def make_xml_request(\n        self,\n        method: str,\n        payload: ET.Element | Sequence[ET.Element] | None,\n    ) -&gt; ET.Element:\n        \"\"\"Send API call to Adaptive.\n\n        Args:\n            method: Adaptive XML API name\n            payload:Body of XML API call\n\n        Returns:\n            XML Element of API response\n\n        Raises:\n            InvalidCredentialsError: Exception indicating the credentials are invalid\n            FailedRequestError: Exception indicating the API request was unsuccessful\n\n        \"\"\"\n        call = self.__generate_xml_call(method, payload)\n\n        request_headers = {\"Content-Type\": \"application/xml\"}\n        response = requests.post(\n            url=BASE_URL + \"v\" + str(MINIMUM_VERSION),\n            data=ET.tostring(call),\n            headers=request_headers,\n            timeout=(10, 30 * 60),\n        )\n\n        tree = ET.fromstring(text=response.text)  # NOQA: S314\n\n        messages = tree.find(path=\"messages\")\n        if messages is not None:\n            for message in messages.findall(path=\"message\"):\n                if (\n                    \"key\" in message.attrib\n                    and message.attrib[\"key\"] == \"error-authentication-failure\"\n                ):\n                    error_message = (\n                        \"The provided credentials are either incorrect \"\n                        \"or the associated account does not \"\n                        \"have access to the requested resource\"\n                    )\n                    raise InvalidCredentialsError(error_message)\n        if \"success\" in tree.attrib and tree.attrib[\"success\"] != \"true\":\n            raise FailedRequestError(\n                message=\"The API request failed to complete successfully\",\n                method=method,\n            )\n\n        return tree\n</code></pre>"},{"location":"reference/wdadaptivepy/connectors/__init__/#wdadaptivepy.connectors.XMLApi.make_xml_request","title":"<code>make_xml_request(method, payload)</code>","text":"<p>Send API call to Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Adaptive XML API name</p> required <code>payload</code> <code>Element | Sequence[Element] | None</code> <p>Body of XML API call</p> required <p>Returns:</p> Type Description <code>Element</code> <p>XML Element of API response</p> <p>Raises:</p> Type Description <code>InvalidCredentialsError</code> <p>Exception indicating the credentials are invalid</p> <code>FailedRequestError</code> <p>Exception indicating the API request was unsuccessful</p> Source code in <code>src/wdadaptivepy/connectors/xml_api/xml_api.py</code> <pre><code>def make_xml_request(\n    self,\n    method: str,\n    payload: ET.Element | Sequence[ET.Element] | None,\n) -&gt; ET.Element:\n    \"\"\"Send API call to Adaptive.\n\n    Args:\n        method: Adaptive XML API name\n        payload:Body of XML API call\n\n    Returns:\n        XML Element of API response\n\n    Raises:\n        InvalidCredentialsError: Exception indicating the credentials are invalid\n        FailedRequestError: Exception indicating the API request was unsuccessful\n\n    \"\"\"\n    call = self.__generate_xml_call(method, payload)\n\n    request_headers = {\"Content-Type\": \"application/xml\"}\n    response = requests.post(\n        url=BASE_URL + \"v\" + str(MINIMUM_VERSION),\n        data=ET.tostring(call),\n        headers=request_headers,\n        timeout=(10, 30 * 60),\n    )\n\n    tree = ET.fromstring(text=response.text)  # NOQA: S314\n\n    messages = tree.find(path=\"messages\")\n    if messages is not None:\n        for message in messages.findall(path=\"message\"):\n            if (\n                \"key\" in message.attrib\n                and message.attrib[\"key\"] == \"error-authentication-failure\"\n            ):\n                error_message = (\n                    \"The provided credentials are either incorrect \"\n                    \"or the associated account does not \"\n                    \"have access to the requested resource\"\n                )\n                raise InvalidCredentialsError(error_message)\n    if \"success\" in tree.attrib and tree.attrib[\"success\"] != \"true\":\n        raise FailedRequestError(\n            message=\"The API request failed to complete successfully\",\n            method=method,\n        )\n\n    return tree\n</code></pre>"},{"location":"reference/wdadaptivepy/connectors/__init__/#wdadaptivepy.connectors.XMLApi.preview_xml_request","title":"<code>preview_xml_request(method, payload, *, hide_password=True)</code>","text":"<p>Generate XML call body (does not send to Adaptive) for review.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Adaptive XML API name</p> required <code>payload</code> <code>Element | Sequence[Element] | None</code> <p>Body of XML API call</p> required <code>hide_password</code> <code>bool</code> <p>Hide password from output</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML Element of API call</p> Source code in <code>src/wdadaptivepy/connectors/xml_api/xml_api.py</code> <pre><code>def preview_xml_request(\n    self,\n    method: str,\n    payload: ET.Element | Sequence[ET.Element] | None,\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate XML call body (does not send to Adaptive) for review.\n\n    Args:\n        method: Adaptive XML API name\n        payload: Body of XML API call\n        hide_password: Hide password from output\n\n    Returns:\n        XML Element of API call\n\n    \"\"\"\n    call = self.__generate_xml_call(method, payload)\n    credentials = call.find(\"credentials\")\n    if hide_password is True and credentials is not None:\n        credentials.attrib[\"password\"] = \"*\" * len(credentials.attrib[\"password\"])\n    return call\n</code></pre>"},{"location":"reference/wdadaptivepy/connectors/xml_api/__init__/","title":"init","text":"<p>Class for Adaptive XML API.</p> <p>Exposes functions to allow wdadaptivepy to utilize Adaptive's XML API</p>"},{"location":"reference/wdadaptivepy/connectors/xml_api/__init__/#wdadaptivepy.connectors.xml_api.XMLApi","title":"<code>XMLApi</code>  <code>dataclass</code>","text":"<p>Class to handle all XML API related methods.</p> <p>Attributes:</p> Name Type Description <code>login</code> <code>str</code> <p>Adaptive username/login</p> <code>password</code> <code>str</code> <p>Adaptive password</p> <code>locale</code> <code>str | None</code> <p>Locale for text translations and data formats</p> <code>instance_code</code> <code>str | None</code> <p>Adaptive tenant/instance code</p> <code>caller_name</code> <code>str</code> <p>Identifier used within Adaptive's logs</p> <code>version</code> <code>int</code> <p>Version of Adaptive's XML API</p> Source code in <code>src/wdadaptivepy/connectors/xml_api/xml_api.py</code> <pre><code>@dataclass\nclass XMLApi:\n    \"\"\"Class to handle all XML API related methods.\n\n    Attributes:\n        login: Adaptive username/login\n        password: Adaptive password\n        locale: Locale for text translations and data formats\n        instance_code: Adaptive tenant/instance code\n        caller_name: Identifier used within Adaptive's logs\n        version: Version of Adaptive's XML API\n\n    \"\"\"\n\n    login: str\n    password: str\n    locale: str | None = None  # add default Locale and make it an enum\n    instance_code: str | None = None\n    caller_name: str = DEFAULT_CALLER_NAME\n    version: int = MINIMUM_VERSION\n\n    def __generate_xml_call(\n        self,\n        method: str,\n        payload: ET.Element | Sequence[ET.Element] | None,\n    ) -&gt; ET.Element:\n        call = ET.Element(\n            \"call\",\n            attrib={\"method\": method, \"callerName\": self.caller_name},\n        )\n        credentials = ET.Element(\n            \"credentials\",\n            attrib={\n                \"login\": self.login,\n                \"password\": self.password,\n            },\n        )\n        if self.locale:\n            credentials.attrib[\"locale\"] = self.locale\n        if self.instance_code:\n            credentials.attrib[\"instanceCode\"] = self.instance_code\n        call.append(credentials)\n        if payload is not None:\n            if isinstance(payload, ET.Element):\n                call.append(payload)\n            elif isinstance(payload, Sequence):\n                if not all(isinstance(element, ET.Element) for element in payload):\n                    error_message = \"Expected XML Element Tree Element\"\n                    raise TypeError(error_message)\n                call.extend(payload)\n        return call\n\n    def preview_xml_request(\n        self,\n        method: str,\n        payload: ET.Element | Sequence[ET.Element] | None,\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate XML call body (does not send to Adaptive) for review.\n\n        Args:\n            method: Adaptive XML API name\n            payload: Body of XML API call\n            hide_password: Hide password from output\n\n        Returns:\n            XML Element of API call\n\n        \"\"\"\n        call = self.__generate_xml_call(method, payload)\n        credentials = call.find(\"credentials\")\n        if hide_password is True and credentials is not None:\n            credentials.attrib[\"password\"] = \"*\" * len(credentials.attrib[\"password\"])\n        return call\n\n    def make_xml_request(\n        self,\n        method: str,\n        payload: ET.Element | Sequence[ET.Element] | None,\n    ) -&gt; ET.Element:\n        \"\"\"Send API call to Adaptive.\n\n        Args:\n            method: Adaptive XML API name\n            payload:Body of XML API call\n\n        Returns:\n            XML Element of API response\n\n        Raises:\n            InvalidCredentialsError: Exception indicating the credentials are invalid\n            FailedRequestError: Exception indicating the API request was unsuccessful\n\n        \"\"\"\n        call = self.__generate_xml_call(method, payload)\n\n        request_headers = {\"Content-Type\": \"application/xml\"}\n        response = requests.post(\n            url=BASE_URL + \"v\" + str(MINIMUM_VERSION),\n            data=ET.tostring(call),\n            headers=request_headers,\n            timeout=(10, 30 * 60),\n        )\n\n        tree = ET.fromstring(text=response.text)  # NOQA: S314\n\n        messages = tree.find(path=\"messages\")\n        if messages is not None:\n            for message in messages.findall(path=\"message\"):\n                if (\n                    \"key\" in message.attrib\n                    and message.attrib[\"key\"] == \"error-authentication-failure\"\n                ):\n                    error_message = (\n                        \"The provided credentials are either incorrect \"\n                        \"or the associated account does not \"\n                        \"have access to the requested resource\"\n                    )\n                    raise InvalidCredentialsError(error_message)\n        if \"success\" in tree.attrib and tree.attrib[\"success\"] != \"true\":\n            raise FailedRequestError(\n                message=\"The API request failed to complete successfully\",\n                method=method,\n            )\n\n        return tree\n</code></pre>"},{"location":"reference/wdadaptivepy/connectors/xml_api/__init__/#wdadaptivepy.connectors.xml_api.XMLApi.make_xml_request","title":"<code>make_xml_request(method, payload)</code>","text":"<p>Send API call to Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Adaptive XML API name</p> required <code>payload</code> <code>Element | Sequence[Element] | None</code> <p>Body of XML API call</p> required <p>Returns:</p> Type Description <code>Element</code> <p>XML Element of API response</p> <p>Raises:</p> Type Description <code>InvalidCredentialsError</code> <p>Exception indicating the credentials are invalid</p> <code>FailedRequestError</code> <p>Exception indicating the API request was unsuccessful</p> Source code in <code>src/wdadaptivepy/connectors/xml_api/xml_api.py</code> <pre><code>def make_xml_request(\n    self,\n    method: str,\n    payload: ET.Element | Sequence[ET.Element] | None,\n) -&gt; ET.Element:\n    \"\"\"Send API call to Adaptive.\n\n    Args:\n        method: Adaptive XML API name\n        payload:Body of XML API call\n\n    Returns:\n        XML Element of API response\n\n    Raises:\n        InvalidCredentialsError: Exception indicating the credentials are invalid\n        FailedRequestError: Exception indicating the API request was unsuccessful\n\n    \"\"\"\n    call = self.__generate_xml_call(method, payload)\n\n    request_headers = {\"Content-Type\": \"application/xml\"}\n    response = requests.post(\n        url=BASE_URL + \"v\" + str(MINIMUM_VERSION),\n        data=ET.tostring(call),\n        headers=request_headers,\n        timeout=(10, 30 * 60),\n    )\n\n    tree = ET.fromstring(text=response.text)  # NOQA: S314\n\n    messages = tree.find(path=\"messages\")\n    if messages is not None:\n        for message in messages.findall(path=\"message\"):\n            if (\n                \"key\" in message.attrib\n                and message.attrib[\"key\"] == \"error-authentication-failure\"\n            ):\n                error_message = (\n                    \"The provided credentials are either incorrect \"\n                    \"or the associated account does not \"\n                    \"have access to the requested resource\"\n                )\n                raise InvalidCredentialsError(error_message)\n    if \"success\" in tree.attrib and tree.attrib[\"success\"] != \"true\":\n        raise FailedRequestError(\n            message=\"The API request failed to complete successfully\",\n            method=method,\n        )\n\n    return tree\n</code></pre>"},{"location":"reference/wdadaptivepy/connectors/xml_api/__init__/#wdadaptivepy.connectors.xml_api.XMLApi.preview_xml_request","title":"<code>preview_xml_request(method, payload, *, hide_password=True)</code>","text":"<p>Generate XML call body (does not send to Adaptive) for review.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Adaptive XML API name</p> required <code>payload</code> <code>Element | Sequence[Element] | None</code> <p>Body of XML API call</p> required <code>hide_password</code> <code>bool</code> <p>Hide password from output</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML Element of API call</p> Source code in <code>src/wdadaptivepy/connectors/xml_api/xml_api.py</code> <pre><code>def preview_xml_request(\n    self,\n    method: str,\n    payload: ET.Element | Sequence[ET.Element] | None,\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate XML call body (does not send to Adaptive) for review.\n\n    Args:\n        method: Adaptive XML API name\n        payload: Body of XML API call\n        hide_password: Hide password from output\n\n    Returns:\n        XML Element of API call\n\n    \"\"\"\n    call = self.__generate_xml_call(method, payload)\n    credentials = call.find(\"credentials\")\n    if hide_password is True and credentials is not None:\n        credentials.attrib[\"password\"] = \"*\" * len(credentials.attrib[\"password\"])\n    return call\n</code></pre>"},{"location":"reference/wdadaptivepy/connectors/xml_api/constants/","title":"constants","text":"<p>Constants used for Adaptive's XML API.</p>"},{"location":"reference/wdadaptivepy/connectors/xml_api/exceptions/","title":"exceptions","text":"<p>Exceptions for Adaptive XML API.</p>"},{"location":"reference/wdadaptivepy/connectors/xml_api/exceptions/#wdadaptivepy.connectors.xml_api.exceptions.FailedRequestError","title":"<code>FailedRequestError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for unsuccessful XML API calls.</p> <p>Attributes:</p> Name Type Description <code>method</code> <p>Adaptive XML API name</p> Source code in <code>src/wdadaptivepy/connectors/xml_api/exceptions.py</code> <pre><code>class FailedRequestError(Exception):\n    \"\"\"Exception for unsuccessful XML API calls.\n\n    Attributes:\n        method: Adaptive XML API name\n\n    \"\"\"\n\n    def __init__(self, message: str, method: str) -&gt; None:\n        \"\"\"Generate Exception for unsuccessful XML API calls.\n\n        Args:\n            message: Exception message\n            method: Adaptive XML API name\n\n        \"\"\"\n        super().__init__(message, method)\n        self.method = method\n</code></pre>"},{"location":"reference/wdadaptivepy/connectors/xml_api/exceptions/#wdadaptivepy.connectors.xml_api.exceptions.FailedRequestError.__init__","title":"<code>__init__(message, method)</code>","text":"<p>Generate Exception for unsuccessful XML API calls.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Exception message</p> required <code>method</code> <code>str</code> <p>Adaptive XML API name</p> required Source code in <code>src/wdadaptivepy/connectors/xml_api/exceptions.py</code> <pre><code>def __init__(self, message: str, method: str) -&gt; None:\n    \"\"\"Generate Exception for unsuccessful XML API calls.\n\n    Args:\n        message: Exception message\n        method: Adaptive XML API name\n\n    \"\"\"\n    super().__init__(message, method)\n    self.method = method\n</code></pre>"},{"location":"reference/wdadaptivepy/connectors/xml_api/exceptions/#wdadaptivepy.connectors.xml_api.exceptions.InvalidCredentialsError","title":"<code>InvalidCredentialsError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for invalid Adaptive credentials.</p> Source code in <code>src/wdadaptivepy/connectors/xml_api/exceptions.py</code> <pre><code>class InvalidCredentialsError(Exception):\n    \"\"\"Exception for invalid Adaptive credentials.\"\"\"\n</code></pre>"},{"location":"reference/wdadaptivepy/connectors/xml_api/xml_api/","title":"xml_api","text":"<p>Class to connect to Adaptive's XML API.</p>"},{"location":"reference/wdadaptivepy/connectors/xml_api/xml_api/#wdadaptivepy.connectors.xml_api.xml_api.XMLApi","title":"<code>XMLApi</code>  <code>dataclass</code>","text":"<p>Class to handle all XML API related methods.</p> <p>Attributes:</p> Name Type Description <code>login</code> <code>str</code> <p>Adaptive username/login</p> <code>password</code> <code>str</code> <p>Adaptive password</p> <code>locale</code> <code>str | None</code> <p>Locale for text translations and data formats</p> <code>instance_code</code> <code>str | None</code> <p>Adaptive tenant/instance code</p> <code>caller_name</code> <code>str</code> <p>Identifier used within Adaptive's logs</p> <code>version</code> <code>int</code> <p>Version of Adaptive's XML API</p> Source code in <code>src/wdadaptivepy/connectors/xml_api/xml_api.py</code> <pre><code>@dataclass\nclass XMLApi:\n    \"\"\"Class to handle all XML API related methods.\n\n    Attributes:\n        login: Adaptive username/login\n        password: Adaptive password\n        locale: Locale for text translations and data formats\n        instance_code: Adaptive tenant/instance code\n        caller_name: Identifier used within Adaptive's logs\n        version: Version of Adaptive's XML API\n\n    \"\"\"\n\n    login: str\n    password: str\n    locale: str | None = None  # add default Locale and make it an enum\n    instance_code: str | None = None\n    caller_name: str = DEFAULT_CALLER_NAME\n    version: int = MINIMUM_VERSION\n\n    def __generate_xml_call(\n        self,\n        method: str,\n        payload: ET.Element | Sequence[ET.Element] | None,\n    ) -&gt; ET.Element:\n        call = ET.Element(\n            \"call\",\n            attrib={\"method\": method, \"callerName\": self.caller_name},\n        )\n        credentials = ET.Element(\n            \"credentials\",\n            attrib={\n                \"login\": self.login,\n                \"password\": self.password,\n            },\n        )\n        if self.locale:\n            credentials.attrib[\"locale\"] = self.locale\n        if self.instance_code:\n            credentials.attrib[\"instanceCode\"] = self.instance_code\n        call.append(credentials)\n        if payload is not None:\n            if isinstance(payload, ET.Element):\n                call.append(payload)\n            elif isinstance(payload, Sequence):\n                if not all(isinstance(element, ET.Element) for element in payload):\n                    error_message = \"Expected XML Element Tree Element\"\n                    raise TypeError(error_message)\n                call.extend(payload)\n        return call\n\n    def preview_xml_request(\n        self,\n        method: str,\n        payload: ET.Element | Sequence[ET.Element] | None,\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate XML call body (does not send to Adaptive) for review.\n\n        Args:\n            method: Adaptive XML API name\n            payload: Body of XML API call\n            hide_password: Hide password from output\n\n        Returns:\n            XML Element of API call\n\n        \"\"\"\n        call = self.__generate_xml_call(method, payload)\n        credentials = call.find(\"credentials\")\n        if hide_password is True and credentials is not None:\n            credentials.attrib[\"password\"] = \"*\" * len(credentials.attrib[\"password\"])\n        return call\n\n    def make_xml_request(\n        self,\n        method: str,\n        payload: ET.Element | Sequence[ET.Element] | None,\n    ) -&gt; ET.Element:\n        \"\"\"Send API call to Adaptive.\n\n        Args:\n            method: Adaptive XML API name\n            payload:Body of XML API call\n\n        Returns:\n            XML Element of API response\n\n        Raises:\n            InvalidCredentialsError: Exception indicating the credentials are invalid\n            FailedRequestError: Exception indicating the API request was unsuccessful\n\n        \"\"\"\n        call = self.__generate_xml_call(method, payload)\n\n        request_headers = {\"Content-Type\": \"application/xml\"}\n        response = requests.post(\n            url=BASE_URL + \"v\" + str(MINIMUM_VERSION),\n            data=ET.tostring(call),\n            headers=request_headers,\n            timeout=(10, 30 * 60),\n        )\n\n        tree = ET.fromstring(text=response.text)  # NOQA: S314\n\n        messages = tree.find(path=\"messages\")\n        if messages is not None:\n            for message in messages.findall(path=\"message\"):\n                if (\n                    \"key\" in message.attrib\n                    and message.attrib[\"key\"] == \"error-authentication-failure\"\n                ):\n                    error_message = (\n                        \"The provided credentials are either incorrect \"\n                        \"or the associated account does not \"\n                        \"have access to the requested resource\"\n                    )\n                    raise InvalidCredentialsError(error_message)\n        if \"success\" in tree.attrib and tree.attrib[\"success\"] != \"true\":\n            raise FailedRequestError(\n                message=\"The API request failed to complete successfully\",\n                method=method,\n            )\n\n        return tree\n</code></pre>"},{"location":"reference/wdadaptivepy/connectors/xml_api/xml_api/#wdadaptivepy.connectors.xml_api.xml_api.XMLApi.make_xml_request","title":"<code>make_xml_request(method, payload)</code>","text":"<p>Send API call to Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Adaptive XML API name</p> required <code>payload</code> <code>Element | Sequence[Element] | None</code> <p>Body of XML API call</p> required <p>Returns:</p> Type Description <code>Element</code> <p>XML Element of API response</p> <p>Raises:</p> Type Description <code>InvalidCredentialsError</code> <p>Exception indicating the credentials are invalid</p> <code>FailedRequestError</code> <p>Exception indicating the API request was unsuccessful</p> Source code in <code>src/wdadaptivepy/connectors/xml_api/xml_api.py</code> <pre><code>def make_xml_request(\n    self,\n    method: str,\n    payload: ET.Element | Sequence[ET.Element] | None,\n) -&gt; ET.Element:\n    \"\"\"Send API call to Adaptive.\n\n    Args:\n        method: Adaptive XML API name\n        payload:Body of XML API call\n\n    Returns:\n        XML Element of API response\n\n    Raises:\n        InvalidCredentialsError: Exception indicating the credentials are invalid\n        FailedRequestError: Exception indicating the API request was unsuccessful\n\n    \"\"\"\n    call = self.__generate_xml_call(method, payload)\n\n    request_headers = {\"Content-Type\": \"application/xml\"}\n    response = requests.post(\n        url=BASE_URL + \"v\" + str(MINIMUM_VERSION),\n        data=ET.tostring(call),\n        headers=request_headers,\n        timeout=(10, 30 * 60),\n    )\n\n    tree = ET.fromstring(text=response.text)  # NOQA: S314\n\n    messages = tree.find(path=\"messages\")\n    if messages is not None:\n        for message in messages.findall(path=\"message\"):\n            if (\n                \"key\" in message.attrib\n                and message.attrib[\"key\"] == \"error-authentication-failure\"\n            ):\n                error_message = (\n                    \"The provided credentials are either incorrect \"\n                    \"or the associated account does not \"\n                    \"have access to the requested resource\"\n                )\n                raise InvalidCredentialsError(error_message)\n    if \"success\" in tree.attrib and tree.attrib[\"success\"] != \"true\":\n        raise FailedRequestError(\n            message=\"The API request failed to complete successfully\",\n            method=method,\n        )\n\n    return tree\n</code></pre>"},{"location":"reference/wdadaptivepy/connectors/xml_api/xml_api/#wdadaptivepy.connectors.xml_api.xml_api.XMLApi.preview_xml_request","title":"<code>preview_xml_request(method, payload, *, hide_password=True)</code>","text":"<p>Generate XML call body (does not send to Adaptive) for review.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Adaptive XML API name</p> required <code>payload</code> <code>Element | Sequence[Element] | None</code> <p>Body of XML API call</p> required <code>hide_password</code> <code>bool</code> <p>Hide password from output</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML Element of API call</p> Source code in <code>src/wdadaptivepy/connectors/xml_api/xml_api.py</code> <pre><code>def preview_xml_request(\n    self,\n    method: str,\n    payload: ET.Element | Sequence[ET.Element] | None,\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate XML call body (does not send to Adaptive) for review.\n\n    Args:\n        method: Adaptive XML API name\n        payload: Body of XML API call\n        hide_password: Hide password from output\n\n    Returns:\n        XML Element of API call\n\n    \"\"\"\n    call = self.__generate_xml_call(method, payload)\n    credentials = call.find(\"credentials\")\n    if hide_password is True and credentials is not None:\n        credentials.attrib[\"password\"] = \"*\" * len(credentials.attrib[\"password\"])\n    return call\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/","title":"init","text":"<p>wdadaptivepy data models.</p>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.Account","title":"<code>Account</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierarchialAttributedMetadata</code></p> <p>wdadaptivepy model for Adaptive's Accounts.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Account ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Account Code</p> <code>name</code> <code>str | None</code> <p>Adaptive Account Name</p> <code>account_type_code</code> <code>str | None</code> <p>Adaptive Account Type Code</p> <code>description</code> <code>str | None</code> <p>Adaptive Account Description</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Account Short Name</p> <code>time_stratum</code> <code>str | None</code> <p>Adaptive Account Time Stratum</p> <code>display_as</code> <code>str | None</code> <p>Adaptive Account Dispay As</p> <code>is_assumption</code> <code>bool | None</code> <p>Adaptive Account Is Assumption</p> <code>suppress_zeroes</code> <code>bool | None</code> <p>Adaptive Account Suprress Zeroes</p> <code>is_default_root</code> <code>bool | None</code> <p>Adaptive Account Is Default Root</p> <code>decimal_precision</code> <code>str | None</code> <p>Adaptive Account Decimal Precision</p> <code>plan_by</code> <code>str | None</code> <p>Adaptive Account Plan By</p> <code>exchange_rate_type</code> <code>str | None</code> <p>Adaptive Account Exchange Rate Type</p> <code>is_importable</code> <code>bool | None</code> <p>Adaptive Account Is Importable</p> <code>balance_type</code> <code>str | None</code> <p>Adaptive Account Balance Type</p> <code>data_entry_type</code> <code>str | None</code> <p>Adaptive Account Data Entry Type</p> <code>time_roll_up</code> <code>str | None</code> <p>Adaptive Account Time Roll Up</p> <code>time_weight_acct_id</code> <code>str | None</code> <p>Adaptive Account Time Weight Account ID</p> <code>has_salary_detail</code> <code>bool | None</code> <p>Adaptive Account Has Salary Detail</p> <code>data_privacy</code> <code>str | None</code> <p>Adaptive Account Data Privacy</p> <code>sub_type</code> <code>str | None</code> <p>Adaptive Account Sub Type</p> <code>start_expanded</code> <code>bool | None</code> <p>Adaptive Account Start Expanded</p> <code>is_breakback_eligible</code> <code>bool | None</code> <p>Aadaptive Account Is Breakback Eligibile</p> <code>level_dim_rollup</code> <code>str | None</code> <p>Adaptive Account Level Dim Rollup</p> <code>rollup_text</code> <code>str | None</code> <p>Adaptive Account Rollup Text</p> <code>enable_actuals</code> <code>bool | None</code> <p>Adaptive Account Enable Actuals</p> <code>is_group</code> <code>bool | None</code> <p>Adaptive Account Is Group</p> <code>is_intercompany</code> <code>bool | None</code> <p>Adaptive Account Is Intercompany</p> <code>formula</code> <code>str | None</code> <p>Adaptive Account Formula</p> <code>is_linked</code> <code>bool | None</code> <p>Adaptive Account Is Linked</p> <code>is_system</code> <code>bool | None</code> <p>Adaptive Account Is System</p> <code>owning_sheet_id</code> <code>str | None</code> <p>Adaptive Account Owning Sheet ID</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy Account XML tags</p> Source code in <code>src/wdadaptivepy/models/account.py</code> <pre><code>@dataclass(eq=False)\nclass Account(HierarchialAttributedMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Accounts.\n\n    Attributes:\n        id: Adaptive Account ID\n        code: Adaptive Account Code\n        name: Adaptive Account Name\n        account_type_code: Adaptive Account Type Code\n        description: Adaptive Account Description\n        short_name: Adaptive Account Short Name\n        time_stratum: Adaptive Account Time Stratum\n        display_as: Adaptive Account Dispay As\n        is_assumption: Adaptive Account Is Assumption\n        suppress_zeroes: Adaptive Account Suprress Zeroes\n        is_default_root: Adaptive Account Is Default Root\n        decimal_precision: Adaptive Account Decimal Precision\n        plan_by: Adaptive Account Plan By\n        exchange_rate_type: Adaptive Account Exchange Rate Type\n        is_importable: Adaptive Account Is Importable\n        balance_type: Adaptive Account Balance Type\n        data_entry_type: Adaptive Account Data Entry Type\n        time_roll_up: Adaptive Account Time Roll Up\n        time_weight_acct_id: Adaptive Account Time Weight Account ID\n        has_salary_detail: Adaptive Account Has Salary Detail\n        data_privacy: Adaptive Account Data Privacy\n        sub_type: Adaptive Account Sub Type\n        start_expanded: Adaptive Account Start Expanded\n        is_breakback_eligible: Aadaptive Account Is Breakback Eligibile\n        level_dim_rollup: Adaptive Account Level Dim Rollup\n        rollup_text: Adaptive Account Rollup Text\n        enable_actuals: Adaptive Account Enable Actuals\n        is_group: Adaptive Account Is Group\n        is_intercompany: Adaptive Account Is Intercompany\n        formula: Adaptive Account Formula\n        is_linked: Adaptive Account Is Linked\n        is_system: Adaptive Account Is System\n        owning_sheet_id: Adaptive Account Owning Sheet ID\n        __xml_tags: wdadaptivepy Account XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    account_type_code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"accountTypeCode\",\n            \"xml_read\": \"accountTypeCode\",\n            \"xml_update\": \"accountTypeCode\",\n            \"xml_delete\": \"accountTypeCode\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    time_stratum: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"timeStratum\",\n            \"xml_read\": \"timeStratum\",\n            \"xml_update\": \"timeStratum\",\n            \"xml_delete\": \"timeStratum\",\n        },\n    )\n    display_as: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayAs\",\n            \"xml_read\": \"displayAs\",\n            \"xml_update\": \"displayAs\",\n            \"xml_delete\": \"displayAs\",\n        },\n    )\n    is_assumption: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isAssumption\",\n            \"xml_read\": \"isAssumption\",\n            \"xml_update\": \"isAssumption\",\n            \"xml_delete\": \"isAssumption\",\n        },\n    )\n    suppress_zeroes: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"suppressZeroes\",\n            \"xml_read\": \"suppressZeroes\",\n            \"xml_update\": \"suppressZeroes\",\n            \"xml_delete\": \"suppressZeroes\",\n        },\n    )\n    is_default_root: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isDefaultRoot\",\n            \"xml_read\": \"isDefaultRoot\",\n            \"xml_update\": \"isDefaultRoot\",\n            \"xml_delete\": \"isDefaultRoot\",\n        },\n    )\n    decimal_precision: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"decimalPrecision\",\n            \"xml_read\": \"decimalPrecision\",\n            \"xml_update\": \"decimalPrecision\",\n            \"xml_delete\": \"decimalPrecision\",\n        },\n    )\n    plan_by: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"planBy\",\n            \"xml_read\": \"planBy\",\n            \"xml_update\": \"planBy\",\n            \"xml_delete\": \"planBy\",\n        },\n    )\n    exchange_rate_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"exchangeRateType\",\n            \"xml_read\": \"exchangeRateType\",\n            \"xml_update\": \"exchangeRateType\",\n            \"xml_delete\": \"exchangeRateType\",\n        },\n    )\n    is_importable: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isImportable\",\n            \"xml_read\": \"isImportable\",\n            \"xml_update\": \"isImportable\",\n            \"xml_delete\": \"isImportable\",\n        },\n    )\n    balance_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"balanceType\",\n            \"xml_read\": \"balanceType\",\n            \"xml_update\": \"balanceType\",\n            \"xml_delete\": \"balanceType\",\n        },\n    )\n    data_entry_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"dataEntryType\",\n            \"xml_read\": \"dataEntryType\",\n            \"xml_update\": \"dataEntryType\",\n            \"xml_delete\": \"dataEntryType\",\n        },\n    )\n    time_roll_up: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"timeRollUp\",\n            \"xml_read\": \"timeRollUp\",\n            \"xml_update\": \"timeRollUp\",\n            \"xml_delete\": \"timeRollUp\",\n        },\n    )\n    time_weight_acct_id: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"timeWeightAcctId\",\n            \"xml_read\": \"timeWeightAcctId\",\n            \"xml_update\": \"timeWeightAcctId\",\n            \"xml_delete\": \"timeWeightAcctId\",\n        },\n    )\n    has_salary_detail: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"hasSalaryDetail\",\n            \"xml_read\": \"hasSalaryDetail\",\n            \"xml_update\": \"hasSalaryDetail\",\n            \"xml_delete\": \"hasSalaryDetail\",\n        },\n    )\n    data_privacy: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"dataPrivacy\",\n            \"xml_read\": \"dataPrivacy\",\n            \"xml_update\": \"dataPrivacy\",\n            \"xml_delete\": \"dataPrivacy\",\n        },\n    )\n    sub_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"subType\",\n            \"xml_read\": \"subType\",\n            \"xml_update\": \"subType\",\n            \"xml_delete\": \"subType\",\n        },\n    )\n    start_expanded: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"startExpanded\",\n            \"xml_read\": \"startExpanded\",\n            \"xml_update\": \"startExpanded\",\n            \"xml_delete\": \"startExpanded\",\n        },\n    )\n    is_breakback_eligible: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isBreakbackEligible\",\n            \"xml_read\": \"isBreakbackEligible\",\n            \"xml_update\": \"isBreakbackEligible\",\n            \"xml_delete\": \"isBreakbackEligible\",\n        },\n    )\n    level_dim_rollup: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"levelDimRollup\",\n            \"xml_read\": \"levelDimRollup\",\n            \"xml_update\": \"levelDimRollup\",\n            \"xml_delete\": \"levelDimRollup\",\n        },\n    )\n    rollup_text: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"rollupText\",\n            \"xml_read\": \"rollupText\",\n            \"xml_update\": \"rollupText\",\n            \"xml_delete\": \"rollupText\",\n        },\n    )\n    enable_actuals: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"enableActuals\",\n            \"xml_read\": \"enableActuals\",\n            \"xml_update\": \"enableActuals\",\n            \"xml_delete\": \"enableActuals\",\n        },\n    )\n    is_group: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isGroup\",\n            \"xml_read\": \"isGroup\",\n            \"xml_update\": \"isGroup\",\n            \"xml_delete\": \"isGroup\",\n        },\n    )\n    is_intercompany: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isIntercompany\",\n            \"xml_read\": \"isIntercompany\",\n            \"xml_update\": \"isIntercompany\",\n            \"xml_delete\": \"isIntercompany\",\n        },\n    )\n    formula: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"formula\",\n            \"xml_read\": \"formula\",\n            \"xml_update\": \"formula\",\n            \"xml_delete\": \"formula\",\n        },\n    )\n    is_linked: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isLinked\",\n            \"xml_read\": \"isLinked\",\n            \"xml_update\": \"isLinked\",\n            \"xml_delete\": \"isLinked\",\n        },\n    )\n    is_system: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isSystem\",\n            \"xml_read\": \"isSystem\",\n            \"xml_update\": \"isSystem\",\n            \"xml_delete\": \"isSystem\",\n        },\n    )\n    owning_sheet_id: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"owningSheetId\",\n            \"xml_read\": \"owningSheetId\",\n            \"xml_update\": \"owningSheetId\",\n            \"xml_delete\": \"owningSheetId\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"accounts\",\n        \"xml_create_tag\": \"account\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"accounts\",\n        \"xml_read_tag\": \"account\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"accounts\",\n        \"xml_update_tag\": \"account\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"accounts\",\n        \"xml_delete_tag\": \"account\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.Attribute","title":"<code>Attribute</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Attributes.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Attribute ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Attribute Name</p> <code>display_name_type</code> <code>str | None</code> <p>Adaptive Attribute Display Name Type</p> <code>attribute_type</code> <code>str | None</code> <p>Adaptive Attribute Type</p> <code>auto_create</code> <code>bool | None</code> <p>Adaptive Attribute Auto Create</p> <code>keep_sorted</code> <code>bool | None</code> <p>Adaptive Attribute Keep Sorted</p> <code>dimension_id</code> <code>int | None</code> <p>Adaptive Attribute Dimension ID</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy Attribute XML tags</p> Source code in <code>src/wdadaptivepy/models/attribute.py</code> <pre><code>@dataclass(eq=False)\nclass Attribute(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Attributes.\n\n    Attributes:\n        id: Adaptive Attribute ID\n        name: Adaptive Attribute Name\n        display_name_type: Adaptive Attribute Display Name Type\n        attribute_type: Adaptive Attribute Type\n        auto_create: Adaptive Attribute Auto Create\n        keep_sorted: Adaptive Attribute Keep Sorted\n        dimension_id: Adaptive Attribute Dimension ID\n        __xml_tags: wdadaptivepy Attribute XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    display_name_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayNameType\",\n            \"xml_read\": \"displayNameType\",\n            \"xml_update\": \"displayNameType\",\n            \"xml_delete\": \"displayNameType\",\n        },\n    )\n    attribute_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"type\",\n            \"xml_read\": \"type\",\n            \"xml_update\": \"type\",\n            \"xml_delete\": \"type\",\n        },\n    )\n    auto_create: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"autoCreate\",\n            \"xml_read\": \"autoCreate\",\n            \"xml_update\": \"autoCreate\",\n            \"xml_delete\": \"autoCreate\",\n        },\n    )\n    keep_sorted: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"keepSorted\",\n            \"xml_read\": \"keepSorted\",\n            \"xml_update\": \"keepSorted\",\n            \"xml_delete\": \"keepSorted\",\n        },\n    )\n    dimension_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"dimensionId\",\n            \"xml_read\": \"dimensionId\",\n            \"xml_update\": \"dimensionId\",\n            \"xml_delete\": \"dimensionId\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"attributes\",\n        \"xml_create_tag\": \"attribute\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"attributes\",\n        \"xml_read_tag\": \"attribute\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"attributes\",\n        \"xml_update_tag\": \"attribute\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"attributes\",\n        \"xml_delete_tag\": \"attribute\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.AttributeValue","title":"<code>AttributeValue</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierchialMetadata</code></p> <p>wdadaptivepy model for Adaptive's Attribute Values.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Attribute Value ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Attribute Value Code</p> <code>name</code> <code>str | None</code> <p>Adaptive Attribute Value Name</p> <code>display_name</code> <code>str | None</code> <p>Adaptive Attribute Value Display Name</p> <code>description</code> <code>str | None</code> <p>Adaptive Attribute Value Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy Attribute Value XML tags</p> Source code in <code>src/wdadaptivepy/models/attribute_value.py</code> <pre><code>@dataclass(eq=False)\nclass AttributeValue(HierchialMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Attribute Values.\n\n    Attributes:\n        id: Adaptive Attribute Value ID\n        code: Adaptive Attribute Value Code\n        name: Adaptive Attribute Value Name\n        display_name: Adaptive Attribute Value Display Name\n        description: Adaptive Attribute Value Description\n        __xml_tags: wdadaptivepy Attribute Value XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    display_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayName\",\n            \"xml_read\": \"displayName\",\n            \"xml_update\": \"displayName\",\n            \"xml_delete\": \"displayName\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"attribute\",\n        \"xml_create_tag\": \"attributeValue\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"attribute\",\n        \"xml_read_tag\": \"attributeValue\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"attribute\",\n        \"xml_update_tag\": \"attributeValue\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"attribute\",\n        \"xml_delete_tag\": \"attributeValue\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.Currency","title":"<code>Currency</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Currencies.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Currency ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Currency Code</p> <code>precision</code> <code>str | None</code> <p>Adaptive Currency Precision</p> <code>is_reporting_currency</code> <code>bool | None</code> <p>Adaptive Currency Is Reporting Currency</p> <code>user_defined</code> <code>bool | None</code> <p>Adaptive Currency User Defined</p> <code>description</code> <code>str | None</code> <p>Adaptive Currency Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/currency.py</code> <pre><code>@dataclass(eq=False)\nclass Currency(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Currencies.\n\n    Attributes:\n        id: Adaptive Currency ID\n        code: Adaptive Currency Code\n        precision: Adaptive Currency Precision\n        is_reporting_currency: Adaptive Currency Is Reporting Currency\n        user_defined: Adaptive Currency User Defined\n        description: Adaptive Currency Description\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    precision: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"precision\",\n            \"xml_read\": \"precision\",\n            \"xml_update\": \"precision\",\n            \"xml_delete\": \"precision\",\n        },\n    )\n    is_reporting_currency: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isReportingCurrency\",\n            \"xml_read\": \"isReportingCurrency\",\n            \"xml_update\": \"isReportingCurrency\",\n            \"xml_delete\": \"isReportingCurrency\",\n        },\n    )\n    user_defined: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"userDefined\",\n            \"xml_read\": \"userDefined\",\n            \"xml_update\": \"userDefined\",\n            \"xml_delete\": \"userDefined\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"currencies\",\n        \"xml_create_tag\": \"currency\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"currencies\",\n        \"xml_read_tag\": \"currency\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"currencies\",\n        \"xml_update_tag\": \"currency\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"currencies\",\n        \"xml_delete_tag\": \"currency\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.Dimension","title":"<code>Dimension</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Dimensions.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Dimension ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Dimension Name</p> <code>code</code> <code>str | None</code> <p>Adaptive Dimension Code</p> <code>display_name_type</code> <code>str | None</code> <p>ADaptive Dimension Display Name Type</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Dimension Short Name</p> <code>auto_create</code> <code>bool | None</code> <p>Adaptive Dimension Auto Create</p> <code>list_dimension</code> <code>bool | None</code> <p>Adaptive Dimension List Dimension</p> <code>keep_sorted</code> <code>bool | None</code> <p>Adaptive Dimension Keep Sorted</p> <code>use_on_levels</code> <code>bool | None</code> <p>Adaptive Dimension Use On Levels</p> <code>seq_no</code> <code>str | None</code> <p>Adaptive Dimension Sequence Number</p> <code>description</code> <code>str | None</code> <p>Adaptive Dimension Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/dimension.py</code> <pre><code>@dataclass(eq=False)\nclass Dimension(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Dimensions.\n\n    Attributes:\n        id: Adaptive Dimension ID\n        name: Adaptive Dimension Name\n        code: Adaptive Dimension Code\n        display_name_type: ADaptive Dimension Display Name Type\n        short_name: Adaptive Dimension Short Name\n        auto_create: Adaptive Dimension Auto Create\n        list_dimension: Adaptive Dimension List Dimension\n        keep_sorted: Adaptive Dimension Keep Sorted\n        use_on_levels: Adaptive Dimension Use On Levels\n        seq_no: Adaptive Dimension Sequence Number\n        description: Adaptive Dimension Description\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    display_name_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayNameType\",\n            \"xml_read\": \"displayNameType\",\n            \"xml_update\": \"displayNameType\",\n            \"xml_delete\": \"displayNameType\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    auto_create: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"autoCreate\",\n            \"xml_read\": \"autoCreate\",\n            \"xml_update\": \"autoCreate\",\n            \"xml_delete\": \"autoCreate\",\n        },\n    )\n    list_dimension: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"listDimension\",\n            \"xml_read\": \"listDimension\",\n            \"xml_update\": \"listDimension\",\n            \"xml_delete\": \"listDimension\",\n        },\n    )\n    keep_sorted: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"keepSorted\",\n            \"xml_read\": \"keepSorted\",\n            \"xml_update\": \"keepSorted\",\n            \"xml_delete\": \"keepSorted\",\n        },\n    )\n    use_on_levels: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"useOnLevels\",\n            \"xml_read\": \"useOnLevels\",\n            \"xml_update\": \"useOnLevels\",\n            \"xml_delete\": \"useOnLevels\",\n        },\n    )\n    seq_no: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"seqNo\",\n            \"xml_read\": \"seqNo\",\n            \"xml_update\": \"seqNo\",\n            \"xml_delete\": \"seqNo\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"dimensions\",\n        \"xml_create_tag\": \"dimension\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"dimensions\",\n        \"xml_read_tag\": \"dimension\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"dimensions\",\n        \"xml_update_tag\": \"dimension\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"dimensions\",\n        \"xml_delete_tag\": \"dimension\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.DimensionValue","title":"<code>DimensionValue</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierarchialAttributedMetadata</code></p> <p>wdadaptivepy model for Adaptive's Dimension Values.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Dimension Value ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Dimension Value Code</p> <code>name</code> <code>str | None</code> <p>Adaptive Dimension Value Name</p> <code>display_name</code> <code>str | None</code> <p>Adaptive Dimension Value Display Name</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Dimension Value Short Name</p> <code>description</code> <code>str | None</code> <p>Adaptive Dimension Value Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/dimension_value.py</code> <pre><code>@dataclass(eq=False)\nclass DimensionValue(HierarchialAttributedMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Dimension Values.\n\n    Attributes:\n        id: Adaptive Dimension Value ID\n        code: Adaptive Dimension Value Code\n        name: Adaptive Dimension Value Name\n        display_name: Adaptive Dimension Value Display Name\n        short_name: Adaptive Dimension Value Short Name\n        description: Adaptive Dimension Value Description\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    display_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayName\",\n            \"xml_read\": \"displayName\",\n            \"xml_update\": \"displayName\",\n            \"xml_delete\": \"displayName\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"dimension\",\n        \"xml_create_tag\": \"dimensionValue\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"dimension\",\n        \"xml_read_tag\": \"dimensionValue\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"dimension\",\n        \"xml_update_tag\": \"dimensionValue\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"dimension\",\n        \"xml_delete_tag\": \"dimensionValue\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.Group","title":"<code>Group</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Groups.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Group ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Group Name</p> <code>is_global</code> <code>bool | None</code> <p>Adaptive Group Is Global</p> <code>owner_id</code> <code>str | None</code> <p>Adaptive Group Owner ID</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/group.py</code> <pre><code>@dataclass(eq=False)\nclass Group(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Groups.\n\n    Attributes:\n        id: Adaptive Group ID\n        name: Adaptive Group Name\n        is_global: Adaptive Group Is Global\n        owner_id: Adaptive Group Owner ID\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    is_global: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isGlobal\",\n            \"xml_read\": \"isGlobal\",\n            \"xml_update\": \"isGlobal\",\n            \"xml_delete\": \"isGlobal\",\n        },\n    )\n    owner_id: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"ownerId\",\n            \"xml_read\": \"ownerId\",\n            \"xml_update\": \"ownerId\",\n            \"xml_delete\": \"ownerId\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"groups\",\n        \"xml_create_tag\": \"group\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"groups\",\n        \"xml_read_tag\": \"group\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"groups\",\n        \"xml_update_tag\": \"group\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"groups\",\n        \"xml_delete_tag\": \"group\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.Level","title":"<code>Level</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierarchialAttributedMetadata</code></p> <p>wdadaptivepy model for Adaptive's Levels.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Level ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Level Code</p> <code>name</code> <code>str | None</code> <p>Adaptive Level Name</p> <code>display_name</code> <code>str | None</code> <p>Adaptive Level Display Name</p> <code>currency</code> <code>str | None</code> <p>Adaptive Level Currency</p> <code>publish_currency</code> <code>str | None</code> <p>Adaptive Level Publish Currency</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Level Short Name</p> <code>available_start</code> <code>str | None</code> <p>Adaptive Level Available Start</p> <code>available_end</code> <code>str | None</code> <p>Adaptive Level Available End</p> <code>is_importable</code> <code>bool | None</code> <p>Adaptive Level Is Importable</p> <code>workflow_status</code> <code>str | None</code> <p>Adaptive Level Workfalow Status</p> <code>is_elimination</code> <code>bool | None</code> <p>Adaptive Level Is Elimination</p> <code>is_linked</code> <code>bool | None</code> <p>Adaptive Level Is Linked</p> <code>has_children</code> <code>bool | None</code> <p>Adaptive Level Has Children</p> <code>description</code> <code>str | None</code> <p>Adaptive Level Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/level.py</code> <pre><code>@dataclass(eq=False)\nclass Level(HierarchialAttributedMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Levels.\n\n    Attributes:\n        id: Adaptive Level ID\n        code: Adaptive Level Code\n        name: Adaptive Level Name\n        display_name: Adaptive Level Display Name\n        currency: Adaptive Level Currency\n        publish_currency: Adaptive Level Publish Currency\n        short_name: Adaptive Level Short Name\n        available_start: Adaptive Level Available Start\n        available_end: Adaptive Level Available End\n        is_importable: Adaptive Level Is Importable\n        workflow_status: Adaptive Level Workfalow Status\n        is_elimination: Adaptive Level Is Elimination\n        is_linked: Adaptive Level Is Linked\n        has_children: Adaptive Level Has Children\n        description: Adaptive Level Description\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    display_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayName\",\n            \"xml_read\": \"displayName\",\n            \"xml_update\": \"displayName\",\n            \"xml_delete\": \"displayName\",\n        },\n    )\n    currency: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"currency\",\n            \"xml_read\": \"currency\",\n            \"xml_update\": \"currency\",\n            \"xml_delete\": \"currency\",\n        },\n    )\n    publish_currency: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"publishCurrency\",\n            \"xml_read\": \"publishCurrency\",\n            \"xml_update\": \"publishCurrency\",\n            \"xml_delete\": \"publishCurrency\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    available_start: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"availableStart\",\n            \"xml_read\": \"availableStart\",\n            \"xml_update\": \"availableStart\",\n            \"xml_delete\": \"availableStart\",\n        },\n    )\n    available_end: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"availableEnd\",\n            \"xml_read\": \"availableEnd\",\n            \"xml_update\": \"availableEnd\",\n            \"xml_delete\": \"availableEnd\",\n        },\n    )\n    is_importable: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isImportable\",\n            \"xml_read\": \"isImportable\",\n            \"xml_update\": \"isImportable\",\n            \"xml_delete\": \"isImportable\",\n        },\n    )\n    workflow_status: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"workflowStatus\",\n            \"xml_read\": \"workflowStatus\",\n            \"xml_update\": \"workflowStatus\",\n            \"xml_delete\": \"workflowStatus\",\n        },\n    )\n    is_elimination: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isElimination\",\n            \"xml_read\": \"isElimination\",\n            \"xml_update\": \"isElimination\",\n            \"xml_delete\": \"isElimination\",\n        },\n    )\n    is_linked: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isLinked\",\n            \"xml_read\": \"isLinked\",\n            \"xml_update\": \"isLinked\",\n            \"xml_delete\": \"isLinked\",\n        },\n    )\n    has_children: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"hasChildren\",\n            \"xml_read\": \"hasChildren\",\n            \"xml_update\": \"hasChildren\",\n            \"xml_delete\": \"hasChildren\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"levels\",\n        \"xml_create_tag\": \"level\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"levels\",\n        \"xml_read_tag\": \"level\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"levels\",\n        \"xml_update_tag\": \"level\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"levels\",\n        \"xml_delete_tag\": \"level\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.MetadataAttribute","title":"<code>MetadataAttribute</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>Attributes of BaseMetadata members.</p> <p>Attributes:</p> Name Type Description <code>attribute_id</code> <code>int | None</code> <p>Adaptive Attribute ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Attribute Name</p> <code>value_id</code> <code>int | None</code> <p>Adaptive Attribute Value ID</p> <code>value</code> <code>str | None</code> <p>Adaptive Attribute Value Name</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@dataclass(eq=False)\nclass MetadataAttribute(BaseMetadata):\n    \"\"\"Attributes of BaseMetadata members.\n\n    Attributes:\n        attribute_id: Adaptive Attribute ID\n        name: Adaptive Attribute Name\n        value_id: Adaptive Attribute Value ID\n        value: Adaptive Attribute Value Name\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    attribute_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"attributeId\",\n            \"xml_read\": \"attributeId\",\n            \"xml_update\": \"\",\n            \"xml_delete\": \"attributeId\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    value_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"valueId\",\n            \"xml_update\": \"\",\n            \"xml_delete\": \"\",\n        },\n    )\n    value: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"value\",\n            \"xml_read\": \"value\",\n            \"xml_update\": \"value\",\n            \"xml_delete\": \"value\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"attributes\",\n        \"xml_create_tag\": \"attribute\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"attributes\",\n        \"xml_read_tag\": \"attribute\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"attributes\",\n        \"xml_update_tag\": \"attribute\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"attributes\",\n        \"xml_delete_tag\": \"attribute\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.MetadataList","title":"<code>MetadataList</code>","text":"<p>               Bases: <code>list[T]</code></p> <p>wdadaptivepy model for list of Adaptive metadata.</p> Source code in <code>src/wdadaptivepy/models/list.py</code> <pre><code>class MetadataList(list[T]):\n    \"\"\"wdadaptivepy model for list of Adaptive metadata.\"\"\"\n\n    def to_csv(self, file_path_and_name: str | PathLike) -&gt; None:\n        \"\"\"Convert MetadataList to CSV.\n\n        Args:\n            file_path_and_name: Full path of CSV\n\n        \"\"\"\n        if len(self) != 0:\n            headers = list(asdict(self[0]).keys())\n            if hasattr(self[0], \"adaptive_parent\"):\n                headers.extend([\"parent id\", \"parent code\", \"parent name\"])\n\n            attribute_titles: list[str] = []\n            all_data: list[dict[str, str | int | bool | None | datetime]] = []\n            for item in self:\n                data = asdict(item)\n                adaptive_parent = getattr(item, \"adaptive_parent\", None)\n                if adaptive_parent is not None:\n                    data = data | {\n                        \"parent id\": adaptive_parent.id,\n                        \"parent code\": adaptive_parent.code,\n                        \"parent name\": adaptive_parent.name,\n                    }\n\n                adaptive_attributes = getattr(item, \"adaptive_attributes\", None)\n                if adaptive_attributes is not None:\n                    for attribute in adaptive_attributes:\n                        if attribute.name + \" id (attribute)\" not in attribute_titles:\n                            attribute_titles.append(\n                                attribute.name + \" id (attribute)\",\n                            )\n                            attribute_titles.append(\n                                attribute.name + \" name (attribute)\",\n                            )\n                        data = data | {\n                            attribute.name + \" id (attribute)\": attribute.value_id,\n                            attribute.name + \" name (attribute)\": attribute.value,\n                        }\n                all_data.append(data)\n\n            headers += attribute_titles\n\n            with Path(file_path_and_name).open(\"w\") as csvfile:\n                csv_writer = csv.DictWriter(csvfile, fieldnames=headers)\n                csv_writer.writeheader()\n                csv_writer.writerows(all_data)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.MetadataList.to_csv","title":"<code>to_csv(file_path_and_name)</code>","text":"<p>Convert MetadataList to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>file_path_and_name</code> <code>str | PathLike</code> <p>Full path of CSV</p> required Source code in <code>src/wdadaptivepy/models/list.py</code> <pre><code>def to_csv(self, file_path_and_name: str | PathLike) -&gt; None:\n    \"\"\"Convert MetadataList to CSV.\n\n    Args:\n        file_path_and_name: Full path of CSV\n\n    \"\"\"\n    if len(self) != 0:\n        headers = list(asdict(self[0]).keys())\n        if hasattr(self[0], \"adaptive_parent\"):\n            headers.extend([\"parent id\", \"parent code\", \"parent name\"])\n\n        attribute_titles: list[str] = []\n        all_data: list[dict[str, str | int | bool | None | datetime]] = []\n        for item in self:\n            data = asdict(item)\n            adaptive_parent = getattr(item, \"adaptive_parent\", None)\n            if adaptive_parent is not None:\n                data = data | {\n                    \"parent id\": adaptive_parent.id,\n                    \"parent code\": adaptive_parent.code,\n                    \"parent name\": adaptive_parent.name,\n                }\n\n            adaptive_attributes = getattr(item, \"adaptive_attributes\", None)\n            if adaptive_attributes is not None:\n                for attribute in adaptive_attributes:\n                    if attribute.name + \" id (attribute)\" not in attribute_titles:\n                        attribute_titles.append(\n                            attribute.name + \" id (attribute)\",\n                        )\n                        attribute_titles.append(\n                            attribute.name + \" name (attribute)\",\n                        )\n                    data = data | {\n                        attribute.name + \" id (attribute)\": attribute.value_id,\n                        attribute.name + \" name (attribute)\": attribute.value,\n                    }\n            all_data.append(data)\n\n        headers += attribute_titles\n\n        with Path(file_path_and_name).open(\"w\") as csvfile:\n            csv_writer = csv.DictWriter(csvfile, fieldnames=headers)\n            csv_writer.writeheader()\n            csv_writer.writerows(all_data)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.Period","title":"<code>Period</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierchialMetadata</code></p> <p>wdadaptivepy model for Adaptive's Periods.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>Adaptive Period Code</p> <code>label</code> <code>str | None</code> <p>Adaptive Period Label</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Period Short Name</p> <code>stratum_id</code> <code>int | None</code> <p>Adaptive Period Stratum ID</p> <code>id</code> <code>int | None</code> <p>Adaptive Period ID</p> <code>start</code> <code>str | None</code> <p>Adaptive Period Start</p> <code>end</code> <code>str | None</code> <p>Adaptive Period End</p> <code>legacy_report_time_id</code> <code>int | None</code> <p>Adaptive Period Legacy Report Time ID</p> <code>legacy_sheet_time_id</code> <code>int | None</code> <p>Adaptive Period Legacy Sheet Time ID</p> <code>locales</code> <code>MetadataList[TimeLocale]</code> <p>Adaptive Period Locales</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/time.py</code> <pre><code>@dataclass(eq=False)\nclass Period(HierchialMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Periods.\n\n    Attributes:\n        code: Adaptive Period Code\n        label: Adaptive Period Label\n        short_name: Adaptive Period Short Name\n        stratum_id: Adaptive Period Stratum ID\n        id: Adaptive Period ID\n        start: Adaptive Period Start\n        end: Adaptive Period End\n        legacy_report_time_id: Adaptive Period Legacy Report Time ID\n        legacy_sheet_time_id: Adaptive Period Legacy Sheet Time ID\n        locales: Adaptive Period Locales\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    label: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"label\",\n            \"xml_read\": \"label\",\n            \"xml_update\": \"label\",\n            \"xml_delete\": \"label\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    stratum_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"stratumId\",\n            \"xml_read\": \"stratumId\",\n            \"xml_update\": \"stratumId\",\n            \"xml_delete\": \"stratumId\",\n        },\n    )\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    start: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"start\",\n            \"xml_read\": \"start\",\n            \"xml_update\": \"start\",\n            \"xml_delete\": \"start\",\n        },\n    )\n    end: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"end\",\n            \"xml_read\": \"end\",\n            \"xml_update\": \"end\",\n            \"xml_delete\": \"end\",\n        },\n    )\n    legacy_report_time_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"legacyReportTimeId\",\n            \"xml_read\": \"legacyReportTimeId\",\n            \"xml_update\": \"legacyReportTimeId\",\n            \"xml_delete\": \"legacyReportTimeId\",\n        },\n    )\n    legacy_sheet_time_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"legacySheetTimeId\",\n            \"xml_read\": \"legacySheetTimeId\",\n            \"xml_update\": \"legacySheetTimeId\",\n            \"xml_delete\": \"legacySheetTimeId\",\n        },\n    )\n    locales: MetadataList[TimeLocale] = field(\n        default_factory=MetadataList[TimeLocale],\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"locales\",\n            \"xml_read\": \"locales\",\n            \"xml_update\": \"locales\",\n            \"xml_delete\": \"locales\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"periods\",\n        \"xml_create_tag\": \"period\",\n        \"xml_create_children\": {\"locales\": TimeLocale},\n        \"xml_read_parent_tag\": \"time\",\n        \"xml_read_tag\": \"period\",\n        \"xml_read_children\": {\"locales\": TimeLocale},\n        \"xml_update_parent_tag\": \"periods\",\n        \"xml_update_tag\": \"period\",\n        \"xml_update_children\": {\"locales\": TimeLocale},\n        \"xml_delete_parent_tag\": \"periods\",\n        \"xml_delete_tag\": \"period\",\n        \"xml_delete_children\": {\"locales\": TimeLocale},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.PermissionSet","title":"<code>PermissionSet</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Permission Sets.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Permission Set ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Permission Set Name</p> <code>permissions</code> <code>str | None</code> <p>Adaptive Permission Set Permissions</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/permission_set.py</code> <pre><code>@dataclass(eq=False)\nclass PermissionSet(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Permission Sets.\n\n    Attributes:\n        id: Adaptive Permission Set ID\n        name: Adaptive Permission Set Name\n        permissions: Adaptive Permission Set Permissions\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    permissions: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"permissions\",\n            \"xml_read\": \"permissions\",\n            \"xml_update\": \"permissions\",\n            \"xml_delete\": \"permissions\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"permission_sets\",\n        \"xml_create_tag\": \"permission_set\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"permission_sets\",\n        \"xml_read_tag\": \"permission_set\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"permission_sets\",\n        \"xml_update_tag\": \"permission_set\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"permission_sets\",\n        \"xml_delete_tag\": \"permission_set\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.Stratum","title":"<code>Stratum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierchialMetadata</code></p> <p>wdadaptivepy model for Adaptive's Stratum.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>Adaptive Stratum Code</p> <code>label</code> <code>str | None</code> <p>Adaptive Stratum Label</p> <code>short_name</code> <code>str | None</code> <p>ADaptive Stratum Short Name</p> <code>id</code> <code>int | None</code> <p>Adaptive Stratum ID</p> <code>in_use</code> <code>bool | None</code> <p>Adaptive Stratum In Use</p> <code>is_default</code> <code>bool | None</code> <p>Adaptive Stratum Is Default</p> <code>locales</code> <code>MetadataList[TimeLocale]</code> <p>Adaptive Stratum Locales</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/time.py</code> <pre><code>@dataclass(eq=False)\nclass Stratum(HierchialMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Stratum.\n\n    Attributes:\n        code: Adaptive Stratum Code\n        label: Adaptive Stratum Label\n        short_name: ADaptive Stratum Short Name\n        id: Adaptive Stratum ID\n        in_use: Adaptive Stratum In Use\n        is_default: Adaptive Stratum Is Default\n        locales: Adaptive Stratum Locales\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    label: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"label\",\n            \"xml_read\": \"label\",\n            \"xml_update\": \"label\",\n            \"xml_delete\": \"label\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    in_use: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"inUse\",\n            \"xml_read\": \"inUse\",\n            \"xml_update\": \"inUse\",\n            \"xml_delete\": \"inUse\",\n        },\n    )\n    is_default: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isDefault\",\n            \"xml_read\": \"isDefault\",\n            \"xml_update\": \"isDefault\",\n            \"xml_delete\": \"isDefault\",\n        },\n    )\n    locales: MetadataList[TimeLocale] = field(\n        default_factory=MetadataList[TimeLocale],\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"locales\",\n            \"xml_read\": \"locales\",\n            \"xml_update\": \"locales\",\n            \"xml_delete\": \"locales\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"stratums\",\n        \"xml_create_tag\": \"stratum\",\n        \"xml_create_children\": {\"locales\": TimeLocale},\n        \"xml_read_parent_tag\": \"time\",\n        \"xml_read_tag\": \"stratum\",\n        \"xml_read_children\": {\"locales\": TimeLocale},\n        \"xml_update_parent_tag\": \"stratums\",\n        \"xml_update_tag\": \"stratum\",\n        \"xml_update_children\": {\"locales\": TimeLocale},\n        \"xml_delete_parent_tag\": \"stratums\",\n        \"xml_delete_tag\": \"stratum\",\n        \"xml_delete_children\": {\"locales\": TimeLocale},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.Subscription","title":"<code>Subscription</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Subscriptions.</p> <p>Attributes:</p> Name Type Description <code>no_subscriptions</code> <code>bool | None</code> <p>Adaptive Subscription No Subscriptions</p> <code>sysem_alerts_and_updates</code> <code>bool | None</code> <p>Adaptive Subscription System Alerts and Updates</p> <code>customer_news_letter</code> <code>bool | None</code> <p>Adaptive Subscription Custom News Letter</p> <code>local_event</code> <code>bool | None</code> <p>Adaptive Subscription Local Event</p> <code>education_training</code> <code>bool | None</code> <p>Adaptive Subscription Education Training</p> <code>customer_webinars</code> <code>bool | None</code> <p>Adaptive Subscription Customer Webinars</p> <code>new_products_and_enhancements</code> <code>bool | None</code> <p>Adaptive Subscription New Products / Enhancements</p> <code>partner_news_letter</code> <code>bool | None</code> <p>Adaptive Subscription Partner News Letter</p> <code>partner_webinars</code> <code>bool | None</code> <p>Adaptive Subscription Partner Webinars</p> <code>user_groups</code> <code>bool | None</code> <p>Adaptive Subscription User Groups</p> <code>surveys</code> <code>bool | None</code> <p>Adaptive Subscription Surveys</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/user.py</code> <pre><code>@dataclass(eq=False)\nclass Subscription(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Subscriptions.\n\n    Attributes:\n        no_subscriptions: Adaptive Subscription No Subscriptions\n        sysem_alerts_and_updates: Adaptive Subscription System Alerts and Updates\n        customer_news_letter: Adaptive Subscription Custom News Letter\n        local_event: Adaptive Subscription Local Event\n        education_training: Adaptive Subscription Education Training\n        customer_webinars: Adaptive Subscription Customer Webinars\n        new_products_and_enhancements: Adaptive Subscription New Products / Enhancements\n        partner_news_letter: Adaptive Subscription Partner News Letter\n        partner_webinars: Adaptive Subscription Partner Webinars\n        user_groups: Adaptive Subscription User Groups\n        surveys: Adaptive Subscription Surveys\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    no_subscriptions: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"noSubscriptions\",\n            \"xml_read\": \"noSubscriptions\",\n            \"xml_update\": \"noSubscriptions\",\n            \"xml_delete\": \"noSubscriptions\",\n        },\n    )\n    sysem_alerts_and_updates: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"systemAlertsAndUpdates\",\n            \"xml_read\": \"systemAlertsAndUpdates\",\n            \"xml_update\": \"systemAlertsAndUpdates\",\n            \"xml_delete\": \"systemAlertsAndUpdates\",\n        },\n    )\n    customer_news_letter: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"customerNewsLetter\",\n            \"xml_read\": \"customerNewsLetter\",\n            \"xml_update\": \"customerNewsLetter\",\n            \"xml_delete\": \"customerNewsLetter\",\n        },\n    )\n    local_event: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"localEvent\",\n            \"xml_read\": \"localEvent\",\n            \"xml_update\": \"localEvent\",\n            \"xml_delete\": \"localEvent\",\n        },\n    )\n    education_training: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"educationTraining\",\n            \"xml_read\": \"educationTraining\",\n            \"xml_update\": \"educationTraining\",\n            \"xml_delete\": \"educationTraining\",\n        },\n    )\n    customer_webinars: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"customerWebinars\",\n            \"xml_read\": \"customerWebinars\",\n            \"xml_update\": \"customerWebinars\",\n            \"xml_delete\": \"customerWebinars\",\n        },\n    )\n    new_products_and_enhancements: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"newProductsAndEnhancements\",\n            \"xml_read\": \"newProductsAndEnhancements\",\n            \"xml_update\": \"newProductsAndEnhancements\",\n            \"xml_delete\": \"newProductsAndEnhancements\",\n        },\n    )\n    partner_news_letter: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"partnerNewsLetter\",\n            \"xml_read\": \"partnerNewsLetter\",\n            \"xml_update\": \"partnerNewsLetter\",\n            \"xml_delete\": \"partnerNewsLetter\",\n        },\n    )\n    partner_webinars: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"partnerWebinars\",\n            \"xml_read\": \"partnerWebinars\",\n            \"xml_update\": \"partnerWebinars\",\n            \"xml_delete\": \"partnerWebinars\",\n        },\n    )\n    user_groups: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"userGroups\",\n            \"xml_read\": \"userGroups\",\n            \"xml_update\": \"userGroups\",\n            \"xml_delete\": \"userGroups\",\n        },\n    )\n    surveys: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"surveys\",\n            \"xml_read\": \"surveys\",\n            \"xml_update\": \"surveys\",\n            \"xml_delete\": \"surveys\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"subscriptions\",\n        \"xml_create_tag\": \"subscription\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"subscriptions\",\n        \"xml_read_tag\": \"subscription\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"subscriptions\",\n        \"xml_update_tag\": \"subscription\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"subscriptions\",\n        \"xml_delete_tag\": \"subscription\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.Time","title":"<code>Time</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Time.</p> <p>Attributes:</p> Name Type Description <code>is_custom</code> <code>bool | None</code> <p>Adaptive Time Is Custom</p> <code>q_first_month</code> <code>int | None</code> <p>Adaptive Time Quarter First Month</p> <code>last_month_is_fy</code> <code>bool | None</code> <p>Adaptive Time Last Month Is Fiscal Year</p> <code>seq_no</code> <code>str | None</code> <p>Adaptive Time Sequence Number</p> <code>stratum</code> <code>MetadataList[Stratum]</code> <p>Adaptive Time Stratum</p> <code>period</code> <code>MetadataList[Period]</code> <p>Adaptive Time Period</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/time.py</code> <pre><code>@dataclass(eq=False)\nclass Time(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Time.\n\n    Attributes:\n        is_custom: Adaptive Time Is Custom\n        q_first_month: Adaptive Time Quarter First Month\n        last_month_is_fy: Adaptive Time Last Month Is Fiscal Year\n        seq_no: Adaptive Time Sequence Number\n        stratum: Adaptive Time Stratum\n        period: Adaptive Time Period\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    is_custom: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isCustom\",\n            \"xml_read\": \"isCustom\",\n            \"xml_update\": \"isCustom\",\n            \"xml_delete\": \"isCustom\",\n        },\n    )\n    q_first_month: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"qFirstMonth\",\n            \"xml_read\": \"qFirstMonth\",\n            \"xml_update\": \"qFirstMonth\",\n            \"xml_delete\": \"qFirstMonth\",\n        },\n    )\n    last_month_is_fy: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"lastMonthIsFy\",\n            \"xml_read\": \"lastMonthIsFy\",\n            \"xml_update\": \"lastMonthIsFy\",\n            \"xml_delete\": \"lastMonthIsFy\",\n        },\n    )\n    seq_no: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"seqNo\",\n            \"xml_read\": \"seqNo\",\n            \"xml_update\": \"seqNo\",\n            \"xml_delete\": \"seqNo\",\n        },\n    )\n    stratum: MetadataList[Stratum] = field(\n        default_factory=MetadataList[Stratum],\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"stratum\",\n            \"xml_read\": \"stratum\",\n            \"xml_update\": \"stratum\",\n            \"xml_delete\": \"stratum\",\n        },\n    )\n    period: MetadataList[Period] = field(\n        default_factory=MetadataList[Period],\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"period\",\n            \"xml_read\": \"period\",\n            \"xml_update\": \"period\",\n            \"xml_delete\": \"period\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"times\",\n        \"xml_create_tag\": \"time\",\n        \"xml_create_children\": {\"stratum\": Stratum, \"period\": Period},\n        \"xml_read_parent_tag\": \"times\",\n        \"xml_read_tag\": \"time\",\n        \"xml_read_children\": {\"stratum\": Stratum, \"period\": Period},\n        \"xml_update_parent_tag\": \"times\",\n        \"xml_update_tag\": \"time\",\n        \"xml_update_children\": {\"stratum\": Stratum, \"period\": Period},\n        \"xml_delete_parent_tag\": \"times\",\n        \"xml_delete_tag\": \"time\",\n        \"xml_delete_children\": {\"stratum\": Stratum, \"period\": Period},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.User","title":"<code>User</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Users.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive User ID</p> <code>guid</code> <code>str | None</code> <p>Adaptive User GUID</p> <code>login</code> <code>str | None</code> <p>Adaptive User Login</p> <code>email</code> <code>str | None</code> <p>Adaptive User Email</p> <code>name</code> <code>str | None</code> <p>Adaptive User Name</p> <code>position</code> <code>str | None</code> <p>Adaptive User Position</p> <code>permission_set_ids</code> <code>list[int] | None</code> <p>Adaptive User Permission Set IDs</p> <code>alternate_email</code> <code>str | None</code> <p>Adaptive User Alternate Email</p> <code>saml_fed_id</code> <code>str | None</code> <p>Adaptive User SAML Federation ID</p> <code>time_zone</code> <code>str | None</code> <p>Adaptive User Time Zone</p> <code>homepage</code> <code>str | None</code> <p>Adaptive User Homepage</p> <code>country</code> <code>str | None</code> <p>Adaptive User Country</p> <code>us_state</code> <code>str | None</code> <p>Adaptive User US State</p> <code>perspective</code> <code>str | None</code> <p>Adaptive User Perspective</p> <code>perspective_name</code> <code>str | None</code> <p>Adaptive User Perspective Name</p> <code>dashboard</code> <code>str | None</code> <p>Adaptive User Dashboard</p> <code>dashboard_name</code> <code>str | None</code> <p>Adaptive User Dashboard Name</p> <code>netsuite_login</code> <code>str | None</code> <p>Adaptive User NetSuite Login</p> <code>salesforce_login</code> <code>str | None</code> <p>Adaptive User Salesforce Login</p> <code>created_date</code> <code>datetime | None</code> <p>Adaptive User Created Date</p> <code>last_login</code> <code>datetime | None</code> <p>Adaptive User Last Login</p> <code>failed_attempts</code> <code>int | None</code> <p>Adaptive User Failed Attempts</p> <code>locked</code> <code>bool | None</code> <p>Adaptive User Locked</p> <code>subscriptions</code> <code>Subscription | None</code> <p>Adaptive User Subscriptions</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/user.py</code> <pre><code>@dataclass(eq=False)\nclass User(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Users.\n\n    Attributes:\n        id: Adaptive User ID\n        guid: Adaptive User GUID\n        login: Adaptive User Login\n        email: Adaptive User Email\n        name: Adaptive User Name\n        position: Adaptive User Position\n        permission_set_ids: Adaptive User Permission Set IDs\n        alternate_email: Adaptive User Alternate Email\n        saml_fed_id: Adaptive User SAML Federation ID\n        time_zone: Adaptive User Time Zone\n        homepage: Adaptive User Homepage\n        country: Adaptive User Country\n        us_state: Adaptive User US State\n        perspective: Adaptive User Perspective\n        perspective_name: Adaptive User Perspective Name\n        dashboard: Adaptive User Dashboard\n        dashboard_name:Adaptive User Dashboard Name\n        netsuite_login: Adaptive User NetSuite Login\n        salesforce_login: Adaptive User Salesforce Login\n        created_date: Adaptive User Created Date\n        last_login: Adaptive User Last Login\n        failed_attempts: Adaptive User Failed Attempts\n        locked: Adaptive User Locked\n        subscriptions: Adaptive User Subscriptions\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    guid: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"guid\",\n            \"xml_read\": \"guid\",\n            \"xml_update\": \"guid\",\n            \"xml_delete\": \"guid\",\n        },\n    )\n    login: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"login\",\n            \"xml_read\": \"login\",\n            \"xml_update\": \"login\",\n            \"xml_delete\": \"login\",\n        },\n    )\n    email: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"email\",\n            \"xml_read\": \"email\",\n            \"xml_update\": \"email\",\n            \"xml_delete\": \"email\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    position: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"position\",\n            \"xml_read\": \"position\",\n            \"xml_update\": \"position\",\n            \"xml_delete\": \"position\",\n        },\n    )\n    permission_set_ids: list[int] | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_list_or_none,\n            \"xml_parser\": int_list_to_str,\n            \"xml_create\": \"permissionSetIds\",\n            \"xml_read\": \"permissionSetIds\",\n            \"xml_update\": \"permissionSetIds\",\n            \"xml_delete\": \"permissionSetIds\",\n        },\n    )\n    alternate_email: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"alternateEmail\",\n            \"xml_read\": \"alternateEmail\",\n            \"xml_update\": \"alternateEmail\",\n            \"xml_delete\": \"alternateEmail\",\n        },\n    )\n    saml_fed_id: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"samlFedId\",\n            \"xml_read\": \"samlFedId\",\n            \"xml_update\": \"samlFedId\",\n            \"xml_delete\": \"samlFedId\",\n        },\n    )\n    time_zone: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"timeZone\",\n            \"xml_read\": \"timeZone\",\n            \"xml_update\": \"timeZone\",\n            \"xml_delete\": \"timeZone\",\n        },\n    )\n    homepage: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"homepage\",\n            \"xml_read\": \"homepage\",\n            \"xml_update\": \"homepage\",\n            \"xml_delete\": \"homepage\",\n        },\n    )\n    country: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"country\",\n            \"xml_read\": \"country\",\n            \"xml_update\": \"country\",\n            \"xml_delete\": \"country\",\n        },\n    )\n    us_state: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"usState\",\n            \"xml_read\": \"usState\",\n            \"xml_update\": \"usState\",\n            \"xml_delete\": \"usState\",\n        },\n    )\n    perspective: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"perspective\",\n            \"xml_read\": \"perspective\",\n            \"xml_update\": \"perspective\",\n            \"xml_delete\": \"perspective\",\n        },\n    )\n    perspective_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"perspectiveName\",\n            \"xml_read\": \"perspectiveName\",\n            \"xml_update\": \"perspectiveName\",\n            \"xml_delete\": \"perspectiveName\",\n        },\n    )\n    dashboard: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"dashboard\",\n            \"xml_read\": \"dashboard\",\n            \"xml_update\": \"dashboard\",\n            \"xml_delete\": \"dashboard\",\n        },\n    )\n    dashboard_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"dashboardName\",\n            \"xml_read\": \"dashboardName\",\n            \"xml_update\": \"dashboardName\",\n            \"xml_delete\": \"dashboardName\",\n        },\n    )\n    netsuite_login: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"netsuiteLogin\",\n            \"xml_read\": \"netsuiteLogin\",\n            \"xml_update\": \"netsuiteLogin\",\n            \"xml_delete\": \"netsuiteLogin\",\n        },\n    )\n    salesforce_login: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"salesforceLogin\",\n            \"xml_read\": \"salesforceLogin\",\n            \"xml_update\": \"salesforceLogin\",\n            \"xml_delete\": \"salesforceLogin\",\n        },\n    )\n    created_date: datetime | None = field(\n        default=None,\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"createdDate\",\n            \"xml_read\": \"createdDate\",\n            \"xml_update\": \"createdDate\",\n            \"xml_delete\": \"createdDate\",\n        },\n    )\n    last_login: datetime | None = field(\n        default=None,\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"lastLogin\",\n            \"xml_read\": \"lastLogin\",\n            \"xml_update\": \"lastLogin\",\n            \"xml_delete\": \"lastLogin\",\n        },\n    )\n    failed_attempts: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"failedAttempts\",\n            \"xml_read\": \"failedAttempts\",\n            \"xml_update\": \"failedAttempts\",\n            \"xml_delete\": \"failedAttempts\",\n        },\n    )\n    locked: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"locked\",\n            \"xml_read\": \"locked\",\n            \"xml_update\": \"locked\",\n            \"xml_delete\": \"locked\",\n        },\n    )\n    subscriptions: Subscription | None = field(\n        default=None,\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"subscriptions\",\n            \"xml_read\": \"subscriptions\",\n            \"xml_update\": \"subscriptions\",\n            \"xml_delete\": \"subscriptions\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"users\",\n        \"xml_create_tag\": \"user\",\n        \"xml_create_children\": {\"subscriptions\": Subscription},\n        \"xml_read_parent_tag\": \"users\",\n        \"xml_read_tag\": \"user\",\n        \"xml_read_children\": {\"subscriptions\": Subscription},\n        \"xml_update_parent_tag\": \"users\",\n        \"xml_update_tag\": \"user\",\n        \"xml_update_children\": {\"subscriptions\": Subscription},\n        \"xml_delete_parent_tag\": \"users\",\n        \"xml_delete_tag\": \"user\",\n        \"xml_delete_children\": {\"subscriptions\": Subscription},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/__init__/#wdadaptivepy.models.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierchialMetadata</code></p> <p>wdadaptivepy model for Adaptive's Versions.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Version ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Version Name</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Version Short Name</p> <code>version_type</code> <code>str | None</code> <p>Adaptive Version Type</p> <code>is_virtual</code> <code>bool | None</code> <p>Adaptive Version Is Virtual</p> <code>description</code> <code>str | None</code> <p>Adaptive Version Description</p> <code>is_default_version</code> <code>bool | None</code> <p>Adaptive Version Is Default Version</p> <code>is_locked</code> <code>bool | None</code> <p>Adaptive Version Is Locked</p> <code>has_audit_trail</code> <code>bool | None</code> <p>Adaptive Version Has Audit Trail</p> <code>enabled_for_workflow</code> <code>bool | None</code> <p>Adaptive Version Enabled for Workflow</p> <code>is_importable</code> <code>bool | None</code> <p>Adaptive Version Is Importable</p> <code>start_ver</code> <code>str | None</code> <p>Adaptive Version Start of Version</p> <code>end_ver</code> <code>str | None</code> <p>Adaptive Version End of Version</p> <code>start_scroll</code> <code>str | None</code> <p>Adaptive Version Start Scroll</p> <code>completed_values_thru</code> <code>str | None</code> <p>Adaptive Version Complted Values Through</p> <code>left_scroll</code> <code>str | None</code> <p>Adaptive Version Left Scroll</p> <code>start_plan</code> <code>str | None</code> <p>Adaptive Version Start Plan</p> <code>end_plan</code> <code>str | None</code> <p>ADaptive Version End Plan</p> <code>lock_leading</code> <code>str | None</code> <p>Adaptive Version Lock Leading</p> <code>is_predictive</code> <code>bool | None</code> <p>Adaptive Version Is Predictive</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/version.py</code> <pre><code>@dataclass(eq=False)\nclass Version(HierchialMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Versions.\n\n    Attributes:\n        id: Adaptive Version ID\n        name: Adaptive Version Name\n        short_name: Adaptive Version Short Name\n        version_type: Adaptive Version Type\n        is_virtual: Adaptive Version Is Virtual\n        description: Adaptive Version Description\n        is_default_version: Adaptive Version Is Default Version\n        is_locked: Adaptive Version Is Locked\n        has_audit_trail: Adaptive Version Has Audit Trail\n        enabled_for_workflow: Adaptive Version Enabled for Workflow\n        is_importable: Adaptive Version Is Importable\n        start_ver: Adaptive Version Start of Version\n        end_ver: Adaptive Version End of Version\n        start_scroll: Adaptive Version Start Scroll\n        completed_values_thru: Adaptive Version Complted Values Through\n        left_scroll: Adaptive Version Left Scroll\n        start_plan: Adaptive Version Start Plan\n        end_plan: ADaptive Version End Plan\n        lock_leading: Adaptive Version Lock Leading\n        is_predictive: Adaptive Version Is Predictive\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    version_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"type\",\n            \"xml_read\": \"type\",\n            \"xml_update\": \"type\",\n            \"xml_delete\": \"type\",\n        },\n    )\n    is_virtual: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isVirtual\",\n            \"xml_read\": \"isVirtual\",\n            \"xml_update\": \"isVirtual\",\n            \"xml_delete\": \"isVirtual\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    is_default_version: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isDefaultVersion\",\n            \"xml_read\": \"isDefaultVersion\",\n            \"xml_update\": \"isDefaultVersion\",\n            \"xml_delete\": \"isDefaultVersion\",\n        },\n    )\n    is_locked: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isLocked\",\n            \"xml_read\": \"isLocked\",\n            \"xml_update\": \"isLocked\",\n            \"xml_delete\": \"isLocked\",\n        },\n    )\n    has_audit_trail: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"hasAuditTrail\",\n            \"xml_read\": \"hasAuditTrail\",\n            \"xml_update\": \"hasAuditTrail\",\n            \"xml_delete\": \"hasAuditTrail\",\n        },\n    )\n    enabled_for_workflow: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"enabledForWorkflow\",\n            \"xml_read\": \"enabledForWorkflow\",\n            \"xml_update\": \"enabledForWorkflow\",\n            \"xml_delete\": \"enabledForWorkflow\",\n        },\n    )\n    is_importable: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isImportable\",\n            \"xml_read\": \"isImportable\",\n            \"xml_update\": \"isImportable\",\n            \"xml_delete\": \"isImportable\",\n        },\n    )\n    start_ver: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"startVer\",\n            \"xml_read\": \"startVer\",\n            \"xml_update\": \"startVer\",\n            \"xml_delete\": \"startVer\",\n        },\n    )\n    end_ver: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"endVer\",\n            \"xml_read\": \"endVer\",\n            \"xml_update\": \"endVer\",\n            \"xml_delete\": \"endVer\",\n        },\n    )\n    start_scroll: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"startScroll\",\n            \"xml_read\": \"startScroll\",\n            \"xml_update\": \"startScroll\",\n            \"xml_delete\": \"startScroll\",\n        },\n    )\n    completed_values_thru: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"completedValuesThru\",\n            \"xml_read\": \"completedValuesThru\",\n            \"xml_update\": \"completedValuesThru\",\n            \"xml_delete\": \"completedValuesThru\",\n        },\n    )\n    left_scroll: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"leftScroll\",\n            \"xml_read\": \"leftScroll\",\n            \"xml_update\": \"leftScroll\",\n            \"xml_delete\": \"leftScroll\",\n        },\n    )\n    start_plan: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"startPlan\",\n            \"xml_read\": \"startPlan\",\n            \"xml_update\": \"startPlan\",\n            \"xml_delete\": \"startPlan\",\n        },\n    )\n    end_plan: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"endPlan\",\n            \"xml_read\": \"endPlan\",\n            \"xml_update\": \"endPlan\",\n            \"xml_delete\": \"endPlan\",\n        },\n    )\n    lock_leading: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"lockLeading\",\n            \"xml_read\": \"lockLeading\",\n            \"xml_update\": \"lockLeading\",\n            \"xml_delete\": \"lockLeading\",\n        },\n    )\n    is_predictive: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isPredictive\",\n            \"xml_read\": \"isPredictive\",\n            \"xml_update\": \"isPredictive\",\n            \"xml_delete\": \"isPredictive\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"versions\",\n        \"xml_create_tag\": \"version\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"versions\",\n        \"xml_read_tag\": \"version\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"versions\",\n        \"xml_update_tag\": \"version\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"versions\",\n        \"xml_delete_tag\": \"version\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/account/","title":"account","text":"<p>wdadaptivepy model for Adaptive's Accounts.</p>"},{"location":"reference/wdadaptivepy/models/account/#wdadaptivepy.models.account.Account","title":"<code>Account</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierarchialAttributedMetadata</code></p> <p>wdadaptivepy model for Adaptive's Accounts.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Account ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Account Code</p> <code>name</code> <code>str | None</code> <p>Adaptive Account Name</p> <code>account_type_code</code> <code>str | None</code> <p>Adaptive Account Type Code</p> <code>description</code> <code>str | None</code> <p>Adaptive Account Description</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Account Short Name</p> <code>time_stratum</code> <code>str | None</code> <p>Adaptive Account Time Stratum</p> <code>display_as</code> <code>str | None</code> <p>Adaptive Account Dispay As</p> <code>is_assumption</code> <code>bool | None</code> <p>Adaptive Account Is Assumption</p> <code>suppress_zeroes</code> <code>bool | None</code> <p>Adaptive Account Suprress Zeroes</p> <code>is_default_root</code> <code>bool | None</code> <p>Adaptive Account Is Default Root</p> <code>decimal_precision</code> <code>str | None</code> <p>Adaptive Account Decimal Precision</p> <code>plan_by</code> <code>str | None</code> <p>Adaptive Account Plan By</p> <code>exchange_rate_type</code> <code>str | None</code> <p>Adaptive Account Exchange Rate Type</p> <code>is_importable</code> <code>bool | None</code> <p>Adaptive Account Is Importable</p> <code>balance_type</code> <code>str | None</code> <p>Adaptive Account Balance Type</p> <code>data_entry_type</code> <code>str | None</code> <p>Adaptive Account Data Entry Type</p> <code>time_roll_up</code> <code>str | None</code> <p>Adaptive Account Time Roll Up</p> <code>time_weight_acct_id</code> <code>str | None</code> <p>Adaptive Account Time Weight Account ID</p> <code>has_salary_detail</code> <code>bool | None</code> <p>Adaptive Account Has Salary Detail</p> <code>data_privacy</code> <code>str | None</code> <p>Adaptive Account Data Privacy</p> <code>sub_type</code> <code>str | None</code> <p>Adaptive Account Sub Type</p> <code>start_expanded</code> <code>bool | None</code> <p>Adaptive Account Start Expanded</p> <code>is_breakback_eligible</code> <code>bool | None</code> <p>Aadaptive Account Is Breakback Eligibile</p> <code>level_dim_rollup</code> <code>str | None</code> <p>Adaptive Account Level Dim Rollup</p> <code>rollup_text</code> <code>str | None</code> <p>Adaptive Account Rollup Text</p> <code>enable_actuals</code> <code>bool | None</code> <p>Adaptive Account Enable Actuals</p> <code>is_group</code> <code>bool | None</code> <p>Adaptive Account Is Group</p> <code>is_intercompany</code> <code>bool | None</code> <p>Adaptive Account Is Intercompany</p> <code>formula</code> <code>str | None</code> <p>Adaptive Account Formula</p> <code>is_linked</code> <code>bool | None</code> <p>Adaptive Account Is Linked</p> <code>is_system</code> <code>bool | None</code> <p>Adaptive Account Is System</p> <code>owning_sheet_id</code> <code>str | None</code> <p>Adaptive Account Owning Sheet ID</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy Account XML tags</p> Source code in <code>src/wdadaptivepy/models/account.py</code> <pre><code>@dataclass(eq=False)\nclass Account(HierarchialAttributedMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Accounts.\n\n    Attributes:\n        id: Adaptive Account ID\n        code: Adaptive Account Code\n        name: Adaptive Account Name\n        account_type_code: Adaptive Account Type Code\n        description: Adaptive Account Description\n        short_name: Adaptive Account Short Name\n        time_stratum: Adaptive Account Time Stratum\n        display_as: Adaptive Account Dispay As\n        is_assumption: Adaptive Account Is Assumption\n        suppress_zeroes: Adaptive Account Suprress Zeroes\n        is_default_root: Adaptive Account Is Default Root\n        decimal_precision: Adaptive Account Decimal Precision\n        plan_by: Adaptive Account Plan By\n        exchange_rate_type: Adaptive Account Exchange Rate Type\n        is_importable: Adaptive Account Is Importable\n        balance_type: Adaptive Account Balance Type\n        data_entry_type: Adaptive Account Data Entry Type\n        time_roll_up: Adaptive Account Time Roll Up\n        time_weight_acct_id: Adaptive Account Time Weight Account ID\n        has_salary_detail: Adaptive Account Has Salary Detail\n        data_privacy: Adaptive Account Data Privacy\n        sub_type: Adaptive Account Sub Type\n        start_expanded: Adaptive Account Start Expanded\n        is_breakback_eligible: Aadaptive Account Is Breakback Eligibile\n        level_dim_rollup: Adaptive Account Level Dim Rollup\n        rollup_text: Adaptive Account Rollup Text\n        enable_actuals: Adaptive Account Enable Actuals\n        is_group: Adaptive Account Is Group\n        is_intercompany: Adaptive Account Is Intercompany\n        formula: Adaptive Account Formula\n        is_linked: Adaptive Account Is Linked\n        is_system: Adaptive Account Is System\n        owning_sheet_id: Adaptive Account Owning Sheet ID\n        __xml_tags: wdadaptivepy Account XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    account_type_code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"accountTypeCode\",\n            \"xml_read\": \"accountTypeCode\",\n            \"xml_update\": \"accountTypeCode\",\n            \"xml_delete\": \"accountTypeCode\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    time_stratum: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"timeStratum\",\n            \"xml_read\": \"timeStratum\",\n            \"xml_update\": \"timeStratum\",\n            \"xml_delete\": \"timeStratum\",\n        },\n    )\n    display_as: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayAs\",\n            \"xml_read\": \"displayAs\",\n            \"xml_update\": \"displayAs\",\n            \"xml_delete\": \"displayAs\",\n        },\n    )\n    is_assumption: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isAssumption\",\n            \"xml_read\": \"isAssumption\",\n            \"xml_update\": \"isAssumption\",\n            \"xml_delete\": \"isAssumption\",\n        },\n    )\n    suppress_zeroes: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"suppressZeroes\",\n            \"xml_read\": \"suppressZeroes\",\n            \"xml_update\": \"suppressZeroes\",\n            \"xml_delete\": \"suppressZeroes\",\n        },\n    )\n    is_default_root: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isDefaultRoot\",\n            \"xml_read\": \"isDefaultRoot\",\n            \"xml_update\": \"isDefaultRoot\",\n            \"xml_delete\": \"isDefaultRoot\",\n        },\n    )\n    decimal_precision: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"decimalPrecision\",\n            \"xml_read\": \"decimalPrecision\",\n            \"xml_update\": \"decimalPrecision\",\n            \"xml_delete\": \"decimalPrecision\",\n        },\n    )\n    plan_by: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"planBy\",\n            \"xml_read\": \"planBy\",\n            \"xml_update\": \"planBy\",\n            \"xml_delete\": \"planBy\",\n        },\n    )\n    exchange_rate_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"exchangeRateType\",\n            \"xml_read\": \"exchangeRateType\",\n            \"xml_update\": \"exchangeRateType\",\n            \"xml_delete\": \"exchangeRateType\",\n        },\n    )\n    is_importable: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isImportable\",\n            \"xml_read\": \"isImportable\",\n            \"xml_update\": \"isImportable\",\n            \"xml_delete\": \"isImportable\",\n        },\n    )\n    balance_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"balanceType\",\n            \"xml_read\": \"balanceType\",\n            \"xml_update\": \"balanceType\",\n            \"xml_delete\": \"balanceType\",\n        },\n    )\n    data_entry_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"dataEntryType\",\n            \"xml_read\": \"dataEntryType\",\n            \"xml_update\": \"dataEntryType\",\n            \"xml_delete\": \"dataEntryType\",\n        },\n    )\n    time_roll_up: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"timeRollUp\",\n            \"xml_read\": \"timeRollUp\",\n            \"xml_update\": \"timeRollUp\",\n            \"xml_delete\": \"timeRollUp\",\n        },\n    )\n    time_weight_acct_id: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"timeWeightAcctId\",\n            \"xml_read\": \"timeWeightAcctId\",\n            \"xml_update\": \"timeWeightAcctId\",\n            \"xml_delete\": \"timeWeightAcctId\",\n        },\n    )\n    has_salary_detail: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"hasSalaryDetail\",\n            \"xml_read\": \"hasSalaryDetail\",\n            \"xml_update\": \"hasSalaryDetail\",\n            \"xml_delete\": \"hasSalaryDetail\",\n        },\n    )\n    data_privacy: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"dataPrivacy\",\n            \"xml_read\": \"dataPrivacy\",\n            \"xml_update\": \"dataPrivacy\",\n            \"xml_delete\": \"dataPrivacy\",\n        },\n    )\n    sub_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"subType\",\n            \"xml_read\": \"subType\",\n            \"xml_update\": \"subType\",\n            \"xml_delete\": \"subType\",\n        },\n    )\n    start_expanded: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"startExpanded\",\n            \"xml_read\": \"startExpanded\",\n            \"xml_update\": \"startExpanded\",\n            \"xml_delete\": \"startExpanded\",\n        },\n    )\n    is_breakback_eligible: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isBreakbackEligible\",\n            \"xml_read\": \"isBreakbackEligible\",\n            \"xml_update\": \"isBreakbackEligible\",\n            \"xml_delete\": \"isBreakbackEligible\",\n        },\n    )\n    level_dim_rollup: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"levelDimRollup\",\n            \"xml_read\": \"levelDimRollup\",\n            \"xml_update\": \"levelDimRollup\",\n            \"xml_delete\": \"levelDimRollup\",\n        },\n    )\n    rollup_text: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"rollupText\",\n            \"xml_read\": \"rollupText\",\n            \"xml_update\": \"rollupText\",\n            \"xml_delete\": \"rollupText\",\n        },\n    )\n    enable_actuals: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"enableActuals\",\n            \"xml_read\": \"enableActuals\",\n            \"xml_update\": \"enableActuals\",\n            \"xml_delete\": \"enableActuals\",\n        },\n    )\n    is_group: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isGroup\",\n            \"xml_read\": \"isGroup\",\n            \"xml_update\": \"isGroup\",\n            \"xml_delete\": \"isGroup\",\n        },\n    )\n    is_intercompany: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isIntercompany\",\n            \"xml_read\": \"isIntercompany\",\n            \"xml_update\": \"isIntercompany\",\n            \"xml_delete\": \"isIntercompany\",\n        },\n    )\n    formula: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"formula\",\n            \"xml_read\": \"formula\",\n            \"xml_update\": \"formula\",\n            \"xml_delete\": \"formula\",\n        },\n    )\n    is_linked: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isLinked\",\n            \"xml_read\": \"isLinked\",\n            \"xml_update\": \"isLinked\",\n            \"xml_delete\": \"isLinked\",\n        },\n    )\n    is_system: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isSystem\",\n            \"xml_read\": \"isSystem\",\n            \"xml_update\": \"isSystem\",\n            \"xml_delete\": \"isSystem\",\n        },\n    )\n    owning_sheet_id: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"owningSheetId\",\n            \"xml_read\": \"owningSheetId\",\n            \"xml_update\": \"owningSheetId\",\n            \"xml_delete\": \"owningSheetId\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"accounts\",\n        \"xml_create_tag\": \"account\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"accounts\",\n        \"xml_read_tag\": \"account\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"accounts\",\n        \"xml_update_tag\": \"account\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"accounts\",\n        \"xml_delete_tag\": \"account\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/attribute/","title":"attribute","text":"<p>wdadaptivepy model for Adaptive's Attributes.</p>"},{"location":"reference/wdadaptivepy/models/attribute/#wdadaptivepy.models.attribute.Attribute","title":"<code>Attribute</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Attributes.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Attribute ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Attribute Name</p> <code>display_name_type</code> <code>str | None</code> <p>Adaptive Attribute Display Name Type</p> <code>attribute_type</code> <code>str | None</code> <p>Adaptive Attribute Type</p> <code>auto_create</code> <code>bool | None</code> <p>Adaptive Attribute Auto Create</p> <code>keep_sorted</code> <code>bool | None</code> <p>Adaptive Attribute Keep Sorted</p> <code>dimension_id</code> <code>int | None</code> <p>Adaptive Attribute Dimension ID</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy Attribute XML tags</p> Source code in <code>src/wdadaptivepy/models/attribute.py</code> <pre><code>@dataclass(eq=False)\nclass Attribute(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Attributes.\n\n    Attributes:\n        id: Adaptive Attribute ID\n        name: Adaptive Attribute Name\n        display_name_type: Adaptive Attribute Display Name Type\n        attribute_type: Adaptive Attribute Type\n        auto_create: Adaptive Attribute Auto Create\n        keep_sorted: Adaptive Attribute Keep Sorted\n        dimension_id: Adaptive Attribute Dimension ID\n        __xml_tags: wdadaptivepy Attribute XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    display_name_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayNameType\",\n            \"xml_read\": \"displayNameType\",\n            \"xml_update\": \"displayNameType\",\n            \"xml_delete\": \"displayNameType\",\n        },\n    )\n    attribute_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"type\",\n            \"xml_read\": \"type\",\n            \"xml_update\": \"type\",\n            \"xml_delete\": \"type\",\n        },\n    )\n    auto_create: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"autoCreate\",\n            \"xml_read\": \"autoCreate\",\n            \"xml_update\": \"autoCreate\",\n            \"xml_delete\": \"autoCreate\",\n        },\n    )\n    keep_sorted: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"keepSorted\",\n            \"xml_read\": \"keepSorted\",\n            \"xml_update\": \"keepSorted\",\n            \"xml_delete\": \"keepSorted\",\n        },\n    )\n    dimension_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"dimensionId\",\n            \"xml_read\": \"dimensionId\",\n            \"xml_update\": \"dimensionId\",\n            \"xml_delete\": \"dimensionId\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"attributes\",\n        \"xml_create_tag\": \"attribute\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"attributes\",\n        \"xml_read_tag\": \"attribute\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"attributes\",\n        \"xml_update_tag\": \"attribute\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"attributes\",\n        \"xml_delete_tag\": \"attribute\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/attribute_value/","title":"attribute_value","text":"<p>wdadaptivepy model for Adaptive's Attribute Values.</p>"},{"location":"reference/wdadaptivepy/models/attribute_value/#wdadaptivepy.models.attribute_value.AttributeValue","title":"<code>AttributeValue</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierchialMetadata</code></p> <p>wdadaptivepy model for Adaptive's Attribute Values.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Attribute Value ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Attribute Value Code</p> <code>name</code> <code>str | None</code> <p>Adaptive Attribute Value Name</p> <code>display_name</code> <code>str | None</code> <p>Adaptive Attribute Value Display Name</p> <code>description</code> <code>str | None</code> <p>Adaptive Attribute Value Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy Attribute Value XML tags</p> Source code in <code>src/wdadaptivepy/models/attribute_value.py</code> <pre><code>@dataclass(eq=False)\nclass AttributeValue(HierchialMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Attribute Values.\n\n    Attributes:\n        id: Adaptive Attribute Value ID\n        code: Adaptive Attribute Value Code\n        name: Adaptive Attribute Value Name\n        display_name: Adaptive Attribute Value Display Name\n        description: Adaptive Attribute Value Description\n        __xml_tags: wdadaptivepy Attribute Value XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    display_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayName\",\n            \"xml_read\": \"displayName\",\n            \"xml_update\": \"displayName\",\n            \"xml_delete\": \"displayName\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"attribute\",\n        \"xml_create_tag\": \"attributeValue\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"attribute\",\n        \"xml_read_tag\": \"attributeValue\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"attribute\",\n        \"xml_update_tag\": \"attributeValue\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"attribute\",\n        \"xml_delete_tag\": \"attributeValue\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/","title":"base","text":"<p>wdadaptivepy base model for Adaptive's metadata.</p>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.AttributedMetadata","title":"<code>AttributedMetadata</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseAttributtedMetadata</code>, <code>BaseMetadata</code></p> <p>Class for Attributed Adaptive Metadata.</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@dataclass(eq=False)\nclass AttributedMetadata(BaseAttributtedMetadata, BaseMetadata):\n    \"\"\"Class for Attributed Adaptive Metadata.\"\"\"\n\n    def __post_init__(\n        self,\n        attributes: Sequence[MetadataAttribute] | None = None,  # NOQA: RUF033\n    ) -&gt; None:\n        \"\"\"Clean up AttributedMetadata instance.\n\n        Args:\n            attributes: Adaptive Attributes\n\n        \"\"\"\n        BaseAttributtedMetadata.__post_init__(self, attributes=attributes)\n        BaseMetadata.__post_init__(self)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.AttributedMetadata.__post_init__","title":"<code>__post_init__(attributes=None)</code>","text":"<p>Clean up AttributedMetadata instance.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Sequence[MetadataAttribute] | None</code> <p>Adaptive Attributes</p> <code>None</code> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def __post_init__(\n    self,\n    attributes: Sequence[MetadataAttribute] | None = None,  # NOQA: RUF033\n) -&gt; None:\n    \"\"\"Clean up AttributedMetadata instance.\n\n    Args:\n        attributes: Adaptive Attributes\n\n    \"\"\"\n    BaseAttributtedMetadata.__post_init__(self, attributes=attributes)\n    BaseMetadata.__post_init__(self)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseAttributtedMetadata","title":"<code>BaseAttributtedMetadata</code>  <code>dataclass</code>","text":"<p>Base class for all Adaptive metadata with attributes.</p> <p>Attributes:</p> Name Type Description <code>attributes</code> <p>Adaptive Attributes</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@dataclass(eq=False)\nclass BaseAttributtedMetadata:\n    \"\"\"Base class for all Adaptive metadata with attributes.\n\n    Attributes:\n        attributes: Adaptive Attributes\n\n    \"\"\"\n\n    attributes: InitVar[Sequence[MetadataAttribute] | None] = None\n\n    def __post_init__(\n        self,\n        attributes: Sequence[MetadataAttribute] | None = None,  # NOQA: RUF033\n    ) -&gt; None:\n        \"\"\"Cleanup BaseAttributtedMetadata instance.\n\n        Args:\n            attributes: Adaptive Attributes\n\n        \"\"\"\n        self.__adaptive_attributes = MetadataList[MetadataAttribute]()\n        if attributes:\n            for attribute in attributes:\n                self.set_adaptive_attribute(attribute)\n\n    @property\n    def adaptive_attributes(self) -&gt; MetadataList[MetadataAttribute]:\n        \"\"\"Adaptive Attributes of member.\n\n        Returns:\n            MetadataList of Attributes\n\n        \"\"\"\n        return self.__adaptive_attributes\n\n    def set_adaptive_attribute(self, adaptive_attribute: MetadataAttribute) -&gt; None:\n        \"\"\"Set Adaptive Attribute for member.\n\n        Args:\n            adaptive_attribute: Adaptive Attribute\n\n        \"\"\"\n        if adaptive_attribute not in self.__adaptive_attributes:\n            for index, attribute in enumerate(iterable=self.__adaptive_attributes):\n                if attribute.attribute_id == adaptive_attribute.attribute_id:\n                    self.__adaptive_attributes[index] = adaptive_attribute\n                    return\n            self.__adaptive_attributes.append(adaptive_attribute)\n\n    def remove_adaptive_attribute(\n        self,\n        adaptive_attribute: MetadataAttribute | None = None,\n        adaptive_attribute_id: int | None = None,\n        adaptive_attribute_name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Remove Adaptive Attribute from member.\n\n        Args:\n            adaptive_attribute: Adaptive Attribute\n            adaptive_attribute_id: Adaptive Attribute ID\n            adaptive_attribute_name: Adaptive Attribute Name\n\n        \"\"\"\n        attribute_id = 0\n        if adaptive_attribute is not None:\n            attribute_id = adaptive_attribute.attribute_id\n        elif adaptive_attribute_id is not None:\n            attribute_id = adaptive_attribute_id\n        for index, attribute in enumerate(iterable=self.__adaptive_attributes):\n            if (attribute.attribute_id == attribute_id) or (\n                attribute_id == 0 and attribute.name == adaptive_attribute_name\n            ):\n                self.__adaptive_attributes[index] = MetadataAttribute(\n                    attribute_id=self.__adaptive_attributes[index].attribute_id,\n                    name=self.__adaptive_attributes[index].name,\n                    value_id=0,\n                    value=\"\",\n                )\n                return\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseAttributtedMetadata.adaptive_attributes","title":"<code>adaptive_attributes</code>  <code>property</code>","text":"<p>Adaptive Attributes of member.</p> <p>Returns:</p> Type Description <code>MetadataList[MetadataAttribute]</code> <p>MetadataList of Attributes</p>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseAttributtedMetadata.__post_init__","title":"<code>__post_init__(attributes=None)</code>","text":"<p>Cleanup BaseAttributtedMetadata instance.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Sequence[MetadataAttribute] | None</code> <p>Adaptive Attributes</p> <code>None</code> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def __post_init__(\n    self,\n    attributes: Sequence[MetadataAttribute] | None = None,  # NOQA: RUF033\n) -&gt; None:\n    \"\"\"Cleanup BaseAttributtedMetadata instance.\n\n    Args:\n        attributes: Adaptive Attributes\n\n    \"\"\"\n    self.__adaptive_attributes = MetadataList[MetadataAttribute]()\n    if attributes:\n        for attribute in attributes:\n            self.set_adaptive_attribute(attribute)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseAttributtedMetadata.remove_adaptive_attribute","title":"<code>remove_adaptive_attribute(adaptive_attribute=None, adaptive_attribute_id=None, adaptive_attribute_name=None)</code>","text":"<p>Remove Adaptive Attribute from member.</p> <p>Parameters:</p> Name Type Description Default <code>adaptive_attribute</code> <code>MetadataAttribute | None</code> <p>Adaptive Attribute</p> <code>None</code> <code>adaptive_attribute_id</code> <code>int | None</code> <p>Adaptive Attribute ID</p> <code>None</code> <code>adaptive_attribute_name</code> <code>str | None</code> <p>Adaptive Attribute Name</p> <code>None</code> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def remove_adaptive_attribute(\n    self,\n    adaptive_attribute: MetadataAttribute | None = None,\n    adaptive_attribute_id: int | None = None,\n    adaptive_attribute_name: str | None = None,\n) -&gt; None:\n    \"\"\"Remove Adaptive Attribute from member.\n\n    Args:\n        adaptive_attribute: Adaptive Attribute\n        adaptive_attribute_id: Adaptive Attribute ID\n        adaptive_attribute_name: Adaptive Attribute Name\n\n    \"\"\"\n    attribute_id = 0\n    if adaptive_attribute is not None:\n        attribute_id = adaptive_attribute.attribute_id\n    elif adaptive_attribute_id is not None:\n        attribute_id = adaptive_attribute_id\n    for index, attribute in enumerate(iterable=self.__adaptive_attributes):\n        if (attribute.attribute_id == attribute_id) or (\n            attribute_id == 0 and attribute.name == adaptive_attribute_name\n        ):\n            self.__adaptive_attributes[index] = MetadataAttribute(\n                attribute_id=self.__adaptive_attributes[index].attribute_id,\n                name=self.__adaptive_attributes[index].name,\n                value_id=0,\n                value=\"\",\n            )\n            return\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseAttributtedMetadata.set_adaptive_attribute","title":"<code>set_adaptive_attribute(adaptive_attribute)</code>","text":"<p>Set Adaptive Attribute for member.</p> <p>Parameters:</p> Name Type Description Default <code>adaptive_attribute</code> <code>MetadataAttribute</code> <p>Adaptive Attribute</p> required Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def set_adaptive_attribute(self, adaptive_attribute: MetadataAttribute) -&gt; None:\n    \"\"\"Set Adaptive Attribute for member.\n\n    Args:\n        adaptive_attribute: Adaptive Attribute\n\n    \"\"\"\n    if adaptive_attribute not in self.__adaptive_attributes:\n        for index, attribute in enumerate(iterable=self.__adaptive_attributes):\n            if attribute.attribute_id == adaptive_attribute.attribute_id:\n                self.__adaptive_attributes[index] = adaptive_attribute\n                return\n        self.__adaptive_attributes.append(adaptive_attribute)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseHierarchialMetadata","title":"<code>BaseHierarchialMetadata</code>  <code>dataclass</code>","text":"<p>Base class for hierarchial Adaptive metadata.</p> <p>Attributes:</p> Name Type Description <code>parent</code> <p>wdadaptivepy BaseHierarchialMetadata parent</p> <code>children</code> <p>wdadaptivepy BaseHierarchialMetadata children</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@dataclass(eq=False)\nclass BaseHierarchialMetadata:\n    \"\"\"Base class for hierarchial Adaptive metadata.\n\n    Attributes:\n        parent: wdadaptivepy BaseHierarchialMetadata parent\n        children: wdadaptivepy BaseHierarchialMetadata children\n\n    \"\"\"\n\n    parent: InitVar[Self | None] = None\n    children: InitVar[Sequence[Self] | None] = None\n\n    def __post_init__(\n        self,\n        parent: Self | None = None,  # NOQA: RUF033\n        children: Sequence[Self] | None = None,  # NOQA: RUF033\n    ) -&gt; None:\n        \"\"\"Cleanup BaseHierarchialMetadata instance.\n\n        Args:\n            parent: Parent of BaseHierarchialMetadata member\n            children: Children of BaseHierarchialMetadata member\n\n        \"\"\"\n        self.__adaptive_parent = None\n        self.__adaptive_children = MetadataList[Self]()\n        self.set_adaptive_parent(parent)\n        if children:\n            for child in children:\n                self.__add_adaptive_child(child)\n\n    @property\n    def adaptive_parent(self) -&gt; Self | None:\n        \"\"\"Adaptive parent from hierarchy.\n\n        Returns:\n            wdadaptivepy parent\n\n        \"\"\"\n        return self.__adaptive_parent\n\n    @property\n    def adaptive_children(self) -&gt; MetadataList[Self]:\n        \"\"\"Adaptive children from hierarchy.\n\n        Returns:\n            wdadaptivepy MetadataList of children\n\n        \"\"\"\n        return self.__adaptive_children\n\n    def set_adaptive_parent(self, adaptive_parent: Self | None) -&gt; None:\n        \"\"\"Assign parent of wdadaptivepy member.\n\n        Args:\n            adaptive_parent: wdadaptivepy parent member\n\n        \"\"\"\n        if self == adaptive_parent:\n            raise ValueError\n        if self.__adaptive_parent != adaptive_parent:\n            if adaptive_parent is not None:\n                adaptive_parent.__add_adaptive_child(adaptive_child=self)  # noqa: SLF001\n                if (\n                    adaptive_parent.adaptive_parent is not None\n                    and self == adaptive_parent.__adaptive_parent  # noqa: SLF001\n                ):\n                    adaptive_parent.set_adaptive_parent(\n                        adaptive_parent=self.adaptive_parent,\n                    )\n            if self.__adaptive_parent is not None:\n                self.__adaptive_parent.__remove_adaptive_child(adaptive_child=self)  # noqa: SLF001\n            self.__adaptive_parent = adaptive_parent\n\n    def __add_adaptive_child(self, adaptive_child: Self) -&gt; None:\n        if adaptive_child not in self.__adaptive_children:\n            self.__adaptive_children.append(adaptive_child)\n\n    def __remove_adaptive_child(self, adaptive_child: Self) -&gt; None:\n        self.__adaptive_children.remove(adaptive_child)\n\n    def get_ancestors(self, nodes: int = -1) -&gt; MetadataList[Self]:\n        \"\"\"Retrieve MetadataList of all ancestors of wdadaptivepy member.\n\n        Args:\n            nodes: Number of nodes in the hierarchy to traverse\n\n        Returns:\n            MetadataList of all ancestors\n\n        \"\"\"\n        ancestors = MetadataList[Self]()\n        if self.adaptive_parent:\n            ancestors.append(self.adaptive_parent)\n            if nodes != 0:\n                ancestors.extend(self.adaptive_parent.get_ancestors(nodes=nodes - 1))\n        return ancestors\n\n    def get_descendents(self, nodes: int = -1) -&gt; MetadataList[Self]:\n        \"\"\"Retrieve MetadataList of all descendents of wdadaptivepy member.\n\n        Args:\n            nodes: Number of nodes in the hierarchy to traverse\n\n        Returns:\n            MetadataList of all descendents\n\n        \"\"\"\n        descendents = MetadataList[Self]()\n        if self.adaptive_children:\n            descendents.extend(self.adaptive_children)\n            if nodes != 0:\n                for child in self.adaptive_children:\n                    descendents.extend(child.get_descendents(nodes=nodes - 1))\n        return descendents\n\n    @classmethod\n    def get_common_ancestors(cls, members: Sequence[Self]) -&gt; MetadataList[Self]:  # NOQA: PLR0912\n        \"\"\"Retrieve MetadataList of shared ancestors of all given members.\n\n        Args:\n            members: wdadaptivepy members to check for common ancestors\n\n        Returns:\n            MetadataList of common ancestors\n\n        \"\"\"\n        common_ancestor = None\n        common_ancestors = MetadataList[Self]()\n        for member in members:\n            if common_ancestor:\n                member_ancestors = member.get_ancestors()\n                found = False\n                for index, ancestor in enumerate(member_ancestors):\n                    if ancestor in common_ancestors:\n                        found = True\n                        if index &gt; 0:\n                            common_ancestors.extend(member_ancestors[:index])\n                        break\n                if not found:\n                    if member.adaptive_parent is None:\n                        common_ancestors.insert(0, member)\n                    new_ancestors = common_ancestors[0].get_ancestors()\n                    for index, new_ancestor in enumerate(new_ancestors):\n                        if new_ancestor in member_ancestors:\n                            common_ancestor = new_ancestor\n                            common_ancestors = (\n                                common_ancestors + new_ancestors[: index + 1]\n                            )\n                            common_ancestors = (\n                                common_ancestors\n                                + member_ancestors[\n                                    : member_ancestors.index(new_ancestor) + 1\n                                ]\n                            )\n                            break\n            else:\n                if member.adaptive_parent is None:\n                    common_ancestor = member\n                else:\n                    common_ancestor = member.adaptive_parent\n                common_ancestors.append(common_ancestor)\n        if common_ancestor is None or common_ancestors == []:\n            raise ValueError\n\n        ordered_ancestors = MetadataList[Self]([common_ancestor])\n        common_ancestors.remove(common_ancestor)\n        while common_ancestors:\n            for ancestor in reversed(common_ancestors):\n                if ancestor in ordered_ancestors:\n                    common_ancestors.remove(ancestor)\n                elif ancestor.adaptive_parent is None:\n                    common_ancestors.remove(ancestor)\n                    ordered_ancestors.append(ancestor)\n                elif ancestor.adaptive_parent in ordered_ancestors:\n                    common_ancestors.remove(ancestor)\n                    index = ordered_ancestors.index(ancestor.adaptive_parent) + 1\n                    ordered_ancestors.insert(index, ancestor)\n        return ordered_ancestors\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseHierarchialMetadata.adaptive_children","title":"<code>adaptive_children</code>  <code>property</code>","text":"<p>Adaptive children from hierarchy.</p> <p>Returns:</p> Type Description <code>MetadataList[Self]</code> <p>wdadaptivepy MetadataList of children</p>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseHierarchialMetadata.adaptive_parent","title":"<code>adaptive_parent</code>  <code>property</code>","text":"<p>Adaptive parent from hierarchy.</p> <p>Returns:</p> Type Description <code>Self | None</code> <p>wdadaptivepy parent</p>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseHierarchialMetadata.__post_init__","title":"<code>__post_init__(parent=None, children=None)</code>","text":"<p>Cleanup BaseHierarchialMetadata instance.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Self | None</code> <p>Parent of BaseHierarchialMetadata member</p> <code>None</code> <code>children</code> <code>Sequence[Self] | None</code> <p>Children of BaseHierarchialMetadata member</p> <code>None</code> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def __post_init__(\n    self,\n    parent: Self | None = None,  # NOQA: RUF033\n    children: Sequence[Self] | None = None,  # NOQA: RUF033\n) -&gt; None:\n    \"\"\"Cleanup BaseHierarchialMetadata instance.\n\n    Args:\n        parent: Parent of BaseHierarchialMetadata member\n        children: Children of BaseHierarchialMetadata member\n\n    \"\"\"\n    self.__adaptive_parent = None\n    self.__adaptive_children = MetadataList[Self]()\n    self.set_adaptive_parent(parent)\n    if children:\n        for child in children:\n            self.__add_adaptive_child(child)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseHierarchialMetadata.get_ancestors","title":"<code>get_ancestors(nodes=-1)</code>","text":"<p>Retrieve MetadataList of all ancestors of wdadaptivepy member.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>int</code> <p>Number of nodes in the hierarchy to traverse</p> <code>-1</code> <p>Returns:</p> Type Description <code>MetadataList[Self]</code> <p>MetadataList of all ancestors</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def get_ancestors(self, nodes: int = -1) -&gt; MetadataList[Self]:\n    \"\"\"Retrieve MetadataList of all ancestors of wdadaptivepy member.\n\n    Args:\n        nodes: Number of nodes in the hierarchy to traverse\n\n    Returns:\n        MetadataList of all ancestors\n\n    \"\"\"\n    ancestors = MetadataList[Self]()\n    if self.adaptive_parent:\n        ancestors.append(self.adaptive_parent)\n        if nodes != 0:\n            ancestors.extend(self.adaptive_parent.get_ancestors(nodes=nodes - 1))\n    return ancestors\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseHierarchialMetadata.get_common_ancestors","title":"<code>get_common_ancestors(members)</code>  <code>classmethod</code>","text":"<p>Retrieve MetadataList of shared ancestors of all given members.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Sequence[Self]</code> <p>wdadaptivepy members to check for common ancestors</p> required <p>Returns:</p> Type Description <code>MetadataList[Self]</code> <p>MetadataList of common ancestors</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@classmethod\ndef get_common_ancestors(cls, members: Sequence[Self]) -&gt; MetadataList[Self]:  # NOQA: PLR0912\n    \"\"\"Retrieve MetadataList of shared ancestors of all given members.\n\n    Args:\n        members: wdadaptivepy members to check for common ancestors\n\n    Returns:\n        MetadataList of common ancestors\n\n    \"\"\"\n    common_ancestor = None\n    common_ancestors = MetadataList[Self]()\n    for member in members:\n        if common_ancestor:\n            member_ancestors = member.get_ancestors()\n            found = False\n            for index, ancestor in enumerate(member_ancestors):\n                if ancestor in common_ancestors:\n                    found = True\n                    if index &gt; 0:\n                        common_ancestors.extend(member_ancestors[:index])\n                    break\n            if not found:\n                if member.adaptive_parent is None:\n                    common_ancestors.insert(0, member)\n                new_ancestors = common_ancestors[0].get_ancestors()\n                for index, new_ancestor in enumerate(new_ancestors):\n                    if new_ancestor in member_ancestors:\n                        common_ancestor = new_ancestor\n                        common_ancestors = (\n                            common_ancestors + new_ancestors[: index + 1]\n                        )\n                        common_ancestors = (\n                            common_ancestors\n                            + member_ancestors[\n                                : member_ancestors.index(new_ancestor) + 1\n                            ]\n                        )\n                        break\n        else:\n            if member.adaptive_parent is None:\n                common_ancestor = member\n            else:\n                common_ancestor = member.adaptive_parent\n            common_ancestors.append(common_ancestor)\n    if common_ancestor is None or common_ancestors == []:\n        raise ValueError\n\n    ordered_ancestors = MetadataList[Self]([common_ancestor])\n    common_ancestors.remove(common_ancestor)\n    while common_ancestors:\n        for ancestor in reversed(common_ancestors):\n            if ancestor in ordered_ancestors:\n                common_ancestors.remove(ancestor)\n            elif ancestor.adaptive_parent is None:\n                common_ancestors.remove(ancestor)\n                ordered_ancestors.append(ancestor)\n            elif ancestor.adaptive_parent in ordered_ancestors:\n                common_ancestors.remove(ancestor)\n                index = ordered_ancestors.index(ancestor.adaptive_parent) + 1\n                ordered_ancestors.insert(index, ancestor)\n    return ordered_ancestors\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseHierarchialMetadata.get_descendents","title":"<code>get_descendents(nodes=-1)</code>","text":"<p>Retrieve MetadataList of all descendents of wdadaptivepy member.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>int</code> <p>Number of nodes in the hierarchy to traverse</p> <code>-1</code> <p>Returns:</p> Type Description <code>MetadataList[Self]</code> <p>MetadataList of all descendents</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def get_descendents(self, nodes: int = -1) -&gt; MetadataList[Self]:\n    \"\"\"Retrieve MetadataList of all descendents of wdadaptivepy member.\n\n    Args:\n        nodes: Number of nodes in the hierarchy to traverse\n\n    Returns:\n        MetadataList of all descendents\n\n    \"\"\"\n    descendents = MetadataList[Self]()\n    if self.adaptive_children:\n        descendents.extend(self.adaptive_children)\n        if nodes != 0:\n            for child in self.adaptive_children:\n                descendents.extend(child.get_descendents(nodes=nodes - 1))\n    return descendents\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseHierarchialMetadata.set_adaptive_parent","title":"<code>set_adaptive_parent(adaptive_parent)</code>","text":"<p>Assign parent of wdadaptivepy member.</p> <p>Parameters:</p> Name Type Description Default <code>adaptive_parent</code> <code>Self | None</code> <p>wdadaptivepy parent member</p> required Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def set_adaptive_parent(self, adaptive_parent: Self | None) -&gt; None:\n    \"\"\"Assign parent of wdadaptivepy member.\n\n    Args:\n        adaptive_parent: wdadaptivepy parent member\n\n    \"\"\"\n    if self == adaptive_parent:\n        raise ValueError\n    if self.__adaptive_parent != adaptive_parent:\n        if adaptive_parent is not None:\n            adaptive_parent.__add_adaptive_child(adaptive_child=self)  # noqa: SLF001\n            if (\n                adaptive_parent.adaptive_parent is not None\n                and self == adaptive_parent.__adaptive_parent  # noqa: SLF001\n            ):\n                adaptive_parent.set_adaptive_parent(\n                    adaptive_parent=self.adaptive_parent,\n                )\n        if self.__adaptive_parent is not None:\n            self.__adaptive_parent.__remove_adaptive_child(adaptive_child=self)  # noqa: SLF001\n        self.__adaptive_parent = adaptive_parent\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseMetadata","title":"<code>BaseMetadata</code>  <code>dataclass</code>","text":"<p>Base class for all Adaptive Metadata.</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@dataclass(eq=False)\nclass BaseMetadata:\n    \"\"\"Base class for all Adaptive Metadata.\"\"\"\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Create a hash for a BaseMetadata instance.\n\n        Returns:\n            int hash value\n\n        \"\"\"\n        return hash(getattr(self, f.name, None) for f in fields(self))\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check if two BaseMetadata objects are equal.\n\n        Args:\n            other: Object to compare with\n\n        Returns:\n            True if equal, False otherwise\n\n        \"\"\"\n        if other is None:\n            return self is None\n\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        for self_field in fields(self):\n            self_value = getattr(self, self_field.name, None)\n            other_value = getattr(other, self_field.name, None)\n            if self_value != other_value:\n                return False\n\n        self_parent = getattr(self, \"adaptive_parent\", None)\n        other_parent = getattr(other, \"adaptive_parent\", None)\n        if self_parent != other_parent:\n            return False\n\n        self_attributes = getattr(self, \"adaptive_attributes\", None)\n        other_attributes = getattr(other, \"adaptive_attributes\", None)\n        return self_attributes == other_attributes\n\n        # return True\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Cleanup BaseMetadata instance.\"\"\"\n\n    def __setattr__(self, name: str, value: Any, /) -&gt; None:  # noqa: ANN401\n        \"\"\"Force data to appropriate data type.\n\n        Args:\n            name: Name of field to modify\n            value: Value to modify\n\n        Raises:\n            RuntimeError: Unexpected value\n\n        \"\"\"\n        if name not in self.__dataclass_fields__:\n            super().__setattr__(name, value)\n            return\n        field_def = self.__dataclass_fields__[name]\n        validator: Callable[[Any], Any] = field_def.metadata.get(\n            \"validator\",\n            lambda x: x,\n        )\n        new_value = validator(value)\n        if (\n            name == \"id\"\n            and getattr(self, \"id\", None) is not None\n            and getattr(self, \"id\", None) != new_value\n        ):\n            error_message = \"Cannot change value of id\"\n            raise RuntimeError(error_message)\n        super().__setattr__(name, validator(value))\n\n    @classmethod\n    def from_xml(  # NOQA: PLR0912\n        cls: type[Self],\n        xml: ET.Element,\n    ) -&gt; MetadataList[Self]:\n        \"\"\"Create wdadaptivepy object from XML.\n\n        Args:\n            cls: Metadata Base Class\n            xml: XML to convert to MetadataList of wdadaptivepy metadata objects\n\n        Returns:\n            wdadaptivepy MetadataList\n\n        Raises:\n            RuntimeError: Unexpected value\n            ValueError: Unexpected value\n\n        \"\"\"\n        metadata_members = MetadataList[Self]()\n\n        cls_name = cls.__name__\n        # xml_parent_tag = cls.__dataclass_fields__[f\"_{cls_name}__xml_tags\"].default[\n        #     \"xml_read_parent_tag\"\n        # ]\n        xml_tag = cls.__dataclass_fields__[f\"_{cls_name}__xml_tags\"].default[\n            \"xml_read_tag\"\n        ]\n        xml_children = cls.__dataclass_fields__[f\"_{cls_name}__xml_tags\"].default[\n            \"xml_read_children\"\n        ]\n        if xml_tag is not None:\n            for xml_element in xml.iter(tag=xml_tag):\n                metadata_data = {\n                    field_name: xml_element.get(field_def.metadata.get(\"xml_read\"))\n                    for field_name, field_def in cls.__dataclass_fields__.items()\n                    if field_def.metadata.get(\"xml_read\") in xml_element.attrib\n                }\n                metadata_member = cls(**metadata_data)\n                if xml_children:\n                    for field_name, data_type in xml_children.items():\n                        child_xml_parent_tag = data_type.__dataclass_fields__[\n                            f\"_{data_type.__name__}__xml_tags\"\n                        ].default[\"xml_read_parent_tag\"]\n                        child_xml_tag = data_type.__dataclass_fields__[\n                            f\"_{data_type.__name__}__xml_tags\"\n                        ].default[\"xml_read_tag\"]\n                        if child_xml_tag is None or child_xml_parent_tag is None:\n                            continue\n                        search_xml_tag = (\n                            child_xml_tag\n                            if child_xml_parent_tag == xml_element.tag\n                            else child_xml_parent_tag\n                        )\n                        children_members = MetadataList()\n                        for child_element in xml_element.findall(f\"./{search_xml_tag}\"):\n                            children_members.extend(data_type.from_xml(child_element))\n                        if children_members:\n                            setattr(metadata_member, field_name, children_members)\n                if hasattr(metadata_member, \"adaptive_parent\"):\n                    parent_xml_element = xml.find(\n                        path=f'.//{xml_element.tag}[@id=\"{xml_element.get(\"id\")}\"]..',\n                    )\n                    if (\n                        parent_xml_element is not None\n                        and parent_xml_element.tag == xml_element.tag\n                    ):\n                        for parent in metadata_members:\n                            if int(getattr(parent, \"id\", 0)) == int(\n                                parent_xml_element.attrib[\"id\"],\n                            ):\n                                set_adaptive_parent = getattr(\n                                    metadata_member,\n                                    \"set_adaptive_parent\",\n                                    None,\n                                )\n                                if set_adaptive_parent is None:\n                                    error_message = \"Cannot access set_adaptive_parent\"\n                                    raise RuntimeError(error_message)\n                                set_adaptive_parent(parent)\n                                break\n                        adaptive_parent = getattr(\n                            metadata_member,\n                            \"adaptive_parent\",\n                            None,\n                        )\n                        if adaptive_parent is None:\n                            error_message = \"Parent not found\"\n                            raise ValueError(error_message)\n                if hasattr(metadata_member, \"adaptive_attributes\"):\n                    adaptive_metadata_instance = MetadataAttribute()\n                    for metadata_element in xml_element.findall(\n                        f\"./{adaptive_metadata_instance.__dataclass_fields__['_MetadataAttribute__xml_tags'].default['xml_read_parent_tag']}\",\n                    ):\n                        adaptive_metadata_members = MetadataAttribute.from_xml(\n                            metadata_element,\n                        )\n                        for adaptive_metadata_member in adaptive_metadata_members:\n                            set_adaptive_attribute = getattr(\n                                metadata_member,\n                                \"set_adaptive_attribute\",\n                                None,\n                            )\n                            if set_adaptive_attribute is None:\n                                error_message = \"Cannot access set_adaptive_attribute\"\n                                raise RuntimeError(error_message)\n                            set_adaptive_attribute(adaptive_metadata_member)\n                metadata_members.append(metadata_member)\n\n        return metadata_members\n\n    @classmethod\n    def to_xml(cls: type[Self], xml_type: str, members: Sequence[Self]) -&gt; ET.Element:  # NOQA: PLR0912, PLR0915\n        \"\"\"Convert BaseMetadata to XML.\n\n        Args:\n            cls: BaseMetadata\n            xml_type: Adaptive XML API call type\n            members: BaseMetadata members\n\n        Returns:\n            XML Element\n\n        Raises:\n            RuntimeError: Unexpected value\n\n        \"\"\"\n        cls_name = cls.__name__\n        xml_parent_tag = cls.__dataclass_fields__[f\"_{cls_name}__xml_tags\"].default[\n            f\"xml_{xml_type}_parent_tag\"\n        ]\n        xml_tag = cls.__dataclass_fields__[f\"_{cls_name}__xml_tags\"].default[\n            f\"xml_{xml_type}_tag\"\n        ]\n        xml_children = cls.__dataclass_fields__[f\"_{cls_name}__xml_tags\"].default[\n            f\"xml_{xml_type}_children\"\n        ]\n        root_element = ET.Element(xml_parent_tag)\n        parent_elements: list[ET.Element] = []\n        parent_members = MetadataList()\n        if hasattr(cls, \"adaptive_parent\"):\n            get_common_ancestors = getattr(cls, \"get_common_ancestors\", None)\n            if get_common_ancestors is None:\n                error_message = \"Missing get_common_ancestors\"\n                raise RuntimeError(error_message)\n            parent_members = get_common_ancestors(members=members)\n            for index, parent in enumerate(parent_members):\n                parent_element = ET.Element(\n                    xml_tag,\n                    {\"id\": str(parent.id)},\n                )\n                parent_elements.append(parent_element)\n                if index == 0 or parent.adaptive_parent is None:\n                    root_element.append(parent_element)\n                else:\n                    parent_index = parent_members.index(parent.adaptive_parent)\n                    parent_elements[parent_index].append(parent_element)\n        for member in members:\n            member_element = ET.Element(xml_tag)\n            for field_name, field_def in cls.__dataclass_fields__.items():\n                xml_name = field_def.metadata.get(f\"xml_{xml_type}\")\n                xml_parser = field_def.metadata.get(\"xml_parser\")\n                if xml_name is None or xml_name == \"\" or xml_parser is None:\n                    continue\n                xml_value = xml_parser(getattr(member, field_name))\n                if xml_value is not None:\n                    member_element.attrib[xml_name] = xml_value\n            for field_name, data_type in xml_children.items():\n                if getattr(member, field_name) not in [None, [], {}]:\n                    children = data_type.to_xml(xml_type, getattr(member, field_name))\n                    if children.tag == xml_tag:\n                        member_element.extend(children)\n                    else:\n                        member_element.append(children)\n            for field_name in xml_children:\n                field_def = [\n                    y for x, y in cls.__dataclass_fields__.items() if x == field_name\n                ]\n                if field_def is None:\n                    continue\n                field_def = field_def[0]\n            if adaptive_attributes := getattr(member, \"adaptive_attributes\", None):\n                attributes = MetadataAttribute.to_xml(xml_type, adaptive_attributes)\n                member_element.extend(attributes)\n            if hasattr(member, \"adaptive_parent\"):\n                if member in parent_members:\n                    index = parent_members.index(member)\n                    parent_elements[index].attrib = member_element.attrib\n                    parent_elements[index].extend(member_element)\n                else:\n                    adaptive_parent = getattr(member, \"adaptive_parent\", None)\n                    if adaptive_parent is None:\n                        index = 0\n                    else:\n                        index = parent_members.index(adaptive_parent)\n                    parent_elements[index].append(member_element)\n            else:\n                root_element.append(member_element)\n\n        return root_element\n\n    @classmethod\n    def from_json(cls: type[Self], data: str) -&gt; MetadataList[Self]:\n        \"\"\"Convert JSON to MetadataList.\n\n        Args:\n            cls: BaseMetadata\n            data: JSON string\n\n        Returns:\n            MetadataList\n\n        \"\"\"\n        vals = loads(s=data)\n        return cls.from_dict(data=vals)\n\n    @classmethod\n    def from_dict(\n        cls: type[Self],\n        data: dict | Sequence[dict],\n    ) -&gt; MetadataList[Self]:\n        \"\"\"Convert Python Dictionary to MetadataList.\n\n        Args:\n            cls: BaseMetadata\n            data: Python Dictionary\n\n        Returns:\n            MetadataList\n\n        \"\"\"\n        members = MetadataList[Self]()\n        if isinstance(data, Sequence):\n            for record in data:\n                member = cls(**record)\n                members.append(member)\n        elif isinstance(data, dict):\n            member = cls(**data)\n            members.append(member)\n\n        return members\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseMetadata.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if two BaseMetadata objects are equal.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Object to compare with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if equal, False otherwise</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check if two BaseMetadata objects are equal.\n\n    Args:\n        other: Object to compare with\n\n    Returns:\n        True if equal, False otherwise\n\n    \"\"\"\n    if other is None:\n        return self is None\n\n    if not isinstance(other, type(self)):\n        return NotImplemented\n    for self_field in fields(self):\n        self_value = getattr(self, self_field.name, None)\n        other_value = getattr(other, self_field.name, None)\n        if self_value != other_value:\n            return False\n\n    self_parent = getattr(self, \"adaptive_parent\", None)\n    other_parent = getattr(other, \"adaptive_parent\", None)\n    if self_parent != other_parent:\n        return False\n\n    self_attributes = getattr(self, \"adaptive_attributes\", None)\n    other_attributes = getattr(other, \"adaptive_attributes\", None)\n    return self_attributes == other_attributes\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseMetadata.__hash__","title":"<code>__hash__()</code>","text":"<p>Create a hash for a BaseMetadata instance.</p> <p>Returns:</p> Type Description <code>int</code> <p>int hash value</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Create a hash for a BaseMetadata instance.\n\n    Returns:\n        int hash value\n\n    \"\"\"\n    return hash(getattr(self, f.name, None) for f in fields(self))\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseMetadata.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Cleanup BaseMetadata instance.</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Cleanup BaseMetadata instance.\"\"\"\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseMetadata.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>Force data to appropriate data type.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of field to modify</p> required <code>value</code> <code>Any</code> <p>Value to modify</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Unexpected value</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def __setattr__(self, name: str, value: Any, /) -&gt; None:  # noqa: ANN401\n    \"\"\"Force data to appropriate data type.\n\n    Args:\n        name: Name of field to modify\n        value: Value to modify\n\n    Raises:\n        RuntimeError: Unexpected value\n\n    \"\"\"\n    if name not in self.__dataclass_fields__:\n        super().__setattr__(name, value)\n        return\n    field_def = self.__dataclass_fields__[name]\n    validator: Callable[[Any], Any] = field_def.metadata.get(\n        \"validator\",\n        lambda x: x,\n    )\n    new_value = validator(value)\n    if (\n        name == \"id\"\n        and getattr(self, \"id\", None) is not None\n        and getattr(self, \"id\", None) != new_value\n    ):\n        error_message = \"Cannot change value of id\"\n        raise RuntimeError(error_message)\n    super().__setattr__(name, validator(value))\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseMetadata.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Convert Python Dictionary to MetadataList.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Self]</code> <p>BaseMetadata</p> required <code>data</code> <code>dict | Sequence[dict]</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Self]</code> <p>MetadataList</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls: type[Self],\n    data: dict | Sequence[dict],\n) -&gt; MetadataList[Self]:\n    \"\"\"Convert Python Dictionary to MetadataList.\n\n    Args:\n        cls: BaseMetadata\n        data: Python Dictionary\n\n    Returns:\n        MetadataList\n\n    \"\"\"\n    members = MetadataList[Self]()\n    if isinstance(data, Sequence):\n        for record in data:\n            member = cls(**record)\n            members.append(member)\n    elif isinstance(data, dict):\n        member = cls(**data)\n        members.append(member)\n\n    return members\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseMetadata.from_json","title":"<code>from_json(data)</code>  <code>classmethod</code>","text":"<p>Convert JSON to MetadataList.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Self]</code> <p>BaseMetadata</p> required <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[Self]</code> <p>MetadataList</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@classmethod\ndef from_json(cls: type[Self], data: str) -&gt; MetadataList[Self]:\n    \"\"\"Convert JSON to MetadataList.\n\n    Args:\n        cls: BaseMetadata\n        data: JSON string\n\n    Returns:\n        MetadataList\n\n    \"\"\"\n    vals = loads(s=data)\n    return cls.from_dict(data=vals)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseMetadata.from_xml","title":"<code>from_xml(xml)</code>  <code>classmethod</code>","text":"<p>Create wdadaptivepy object from XML.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Self]</code> <p>Metadata Base Class</p> required <code>xml</code> <code>Element</code> <p>XML to convert to MetadataList of wdadaptivepy metadata objects</p> required <p>Returns:</p> Type Description <code>MetadataList[Self]</code> <p>wdadaptivepy MetadataList</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Unexpected value</p> <code>ValueError</code> <p>Unexpected value</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@classmethod\ndef from_xml(  # NOQA: PLR0912\n    cls: type[Self],\n    xml: ET.Element,\n) -&gt; MetadataList[Self]:\n    \"\"\"Create wdadaptivepy object from XML.\n\n    Args:\n        cls: Metadata Base Class\n        xml: XML to convert to MetadataList of wdadaptivepy metadata objects\n\n    Returns:\n        wdadaptivepy MetadataList\n\n    Raises:\n        RuntimeError: Unexpected value\n        ValueError: Unexpected value\n\n    \"\"\"\n    metadata_members = MetadataList[Self]()\n\n    cls_name = cls.__name__\n    # xml_parent_tag = cls.__dataclass_fields__[f\"_{cls_name}__xml_tags\"].default[\n    #     \"xml_read_parent_tag\"\n    # ]\n    xml_tag = cls.__dataclass_fields__[f\"_{cls_name}__xml_tags\"].default[\n        \"xml_read_tag\"\n    ]\n    xml_children = cls.__dataclass_fields__[f\"_{cls_name}__xml_tags\"].default[\n        \"xml_read_children\"\n    ]\n    if xml_tag is not None:\n        for xml_element in xml.iter(tag=xml_tag):\n            metadata_data = {\n                field_name: xml_element.get(field_def.metadata.get(\"xml_read\"))\n                for field_name, field_def in cls.__dataclass_fields__.items()\n                if field_def.metadata.get(\"xml_read\") in xml_element.attrib\n            }\n            metadata_member = cls(**metadata_data)\n            if xml_children:\n                for field_name, data_type in xml_children.items():\n                    child_xml_parent_tag = data_type.__dataclass_fields__[\n                        f\"_{data_type.__name__}__xml_tags\"\n                    ].default[\"xml_read_parent_tag\"]\n                    child_xml_tag = data_type.__dataclass_fields__[\n                        f\"_{data_type.__name__}__xml_tags\"\n                    ].default[\"xml_read_tag\"]\n                    if child_xml_tag is None or child_xml_parent_tag is None:\n                        continue\n                    search_xml_tag = (\n                        child_xml_tag\n                        if child_xml_parent_tag == xml_element.tag\n                        else child_xml_parent_tag\n                    )\n                    children_members = MetadataList()\n                    for child_element in xml_element.findall(f\"./{search_xml_tag}\"):\n                        children_members.extend(data_type.from_xml(child_element))\n                    if children_members:\n                        setattr(metadata_member, field_name, children_members)\n            if hasattr(metadata_member, \"adaptive_parent\"):\n                parent_xml_element = xml.find(\n                    path=f'.//{xml_element.tag}[@id=\"{xml_element.get(\"id\")}\"]..',\n                )\n                if (\n                    parent_xml_element is not None\n                    and parent_xml_element.tag == xml_element.tag\n                ):\n                    for parent in metadata_members:\n                        if int(getattr(parent, \"id\", 0)) == int(\n                            parent_xml_element.attrib[\"id\"],\n                        ):\n                            set_adaptive_parent = getattr(\n                                metadata_member,\n                                \"set_adaptive_parent\",\n                                None,\n                            )\n                            if set_adaptive_parent is None:\n                                error_message = \"Cannot access set_adaptive_parent\"\n                                raise RuntimeError(error_message)\n                            set_adaptive_parent(parent)\n                            break\n                    adaptive_parent = getattr(\n                        metadata_member,\n                        \"adaptive_parent\",\n                        None,\n                    )\n                    if adaptive_parent is None:\n                        error_message = \"Parent not found\"\n                        raise ValueError(error_message)\n            if hasattr(metadata_member, \"adaptive_attributes\"):\n                adaptive_metadata_instance = MetadataAttribute()\n                for metadata_element in xml_element.findall(\n                    f\"./{adaptive_metadata_instance.__dataclass_fields__['_MetadataAttribute__xml_tags'].default['xml_read_parent_tag']}\",\n                ):\n                    adaptive_metadata_members = MetadataAttribute.from_xml(\n                        metadata_element,\n                    )\n                    for adaptive_metadata_member in adaptive_metadata_members:\n                        set_adaptive_attribute = getattr(\n                            metadata_member,\n                            \"set_adaptive_attribute\",\n                            None,\n                        )\n                        if set_adaptive_attribute is None:\n                            error_message = \"Cannot access set_adaptive_attribute\"\n                            raise RuntimeError(error_message)\n                        set_adaptive_attribute(adaptive_metadata_member)\n            metadata_members.append(metadata_member)\n\n    return metadata_members\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.BaseMetadata.to_xml","title":"<code>to_xml(xml_type, members)</code>  <code>classmethod</code>","text":"<p>Convert BaseMetadata to XML.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Self]</code> <p>BaseMetadata</p> required <code>xml_type</code> <code>str</code> <p>Adaptive XML API call type</p> required <code>members</code> <code>Sequence[Self]</code> <p>BaseMetadata members</p> required <p>Returns:</p> Type Description <code>Element</code> <p>XML Element</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Unexpected value</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@classmethod\ndef to_xml(cls: type[Self], xml_type: str, members: Sequence[Self]) -&gt; ET.Element:  # NOQA: PLR0912, PLR0915\n    \"\"\"Convert BaseMetadata to XML.\n\n    Args:\n        cls: BaseMetadata\n        xml_type: Adaptive XML API call type\n        members: BaseMetadata members\n\n    Returns:\n        XML Element\n\n    Raises:\n        RuntimeError: Unexpected value\n\n    \"\"\"\n    cls_name = cls.__name__\n    xml_parent_tag = cls.__dataclass_fields__[f\"_{cls_name}__xml_tags\"].default[\n        f\"xml_{xml_type}_parent_tag\"\n    ]\n    xml_tag = cls.__dataclass_fields__[f\"_{cls_name}__xml_tags\"].default[\n        f\"xml_{xml_type}_tag\"\n    ]\n    xml_children = cls.__dataclass_fields__[f\"_{cls_name}__xml_tags\"].default[\n        f\"xml_{xml_type}_children\"\n    ]\n    root_element = ET.Element(xml_parent_tag)\n    parent_elements: list[ET.Element] = []\n    parent_members = MetadataList()\n    if hasattr(cls, \"adaptive_parent\"):\n        get_common_ancestors = getattr(cls, \"get_common_ancestors\", None)\n        if get_common_ancestors is None:\n            error_message = \"Missing get_common_ancestors\"\n            raise RuntimeError(error_message)\n        parent_members = get_common_ancestors(members=members)\n        for index, parent in enumerate(parent_members):\n            parent_element = ET.Element(\n                xml_tag,\n                {\"id\": str(parent.id)},\n            )\n            parent_elements.append(parent_element)\n            if index == 0 or parent.adaptive_parent is None:\n                root_element.append(parent_element)\n            else:\n                parent_index = parent_members.index(parent.adaptive_parent)\n                parent_elements[parent_index].append(parent_element)\n    for member in members:\n        member_element = ET.Element(xml_tag)\n        for field_name, field_def in cls.__dataclass_fields__.items():\n            xml_name = field_def.metadata.get(f\"xml_{xml_type}\")\n            xml_parser = field_def.metadata.get(\"xml_parser\")\n            if xml_name is None or xml_name == \"\" or xml_parser is None:\n                continue\n            xml_value = xml_parser(getattr(member, field_name))\n            if xml_value is not None:\n                member_element.attrib[xml_name] = xml_value\n        for field_name, data_type in xml_children.items():\n            if getattr(member, field_name) not in [None, [], {}]:\n                children = data_type.to_xml(xml_type, getattr(member, field_name))\n                if children.tag == xml_tag:\n                    member_element.extend(children)\n                else:\n                    member_element.append(children)\n        for field_name in xml_children:\n            field_def = [\n                y for x, y in cls.__dataclass_fields__.items() if x == field_name\n            ]\n            if field_def is None:\n                continue\n            field_def = field_def[0]\n        if adaptive_attributes := getattr(member, \"adaptive_attributes\", None):\n            attributes = MetadataAttribute.to_xml(xml_type, adaptive_attributes)\n            member_element.extend(attributes)\n        if hasattr(member, \"adaptive_parent\"):\n            if member in parent_members:\n                index = parent_members.index(member)\n                parent_elements[index].attrib = member_element.attrib\n                parent_elements[index].extend(member_element)\n            else:\n                adaptive_parent = getattr(member, \"adaptive_parent\", None)\n                if adaptive_parent is None:\n                    index = 0\n                else:\n                    index = parent_members.index(adaptive_parent)\n                parent_elements[index].append(member_element)\n        else:\n            root_element.append(member_element)\n\n    return root_element\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.HierarchialAttributedMetadata","title":"<code>HierarchialAttributedMetadata</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseHierarchialMetadata</code>, <code>BaseAttributtedMetadata</code>, <code>BaseMetadata</code></p> <p>Class for Hierarchial, Attributed Adaptive Metadata.</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@dataclass(eq=False)\nclass HierarchialAttributedMetadata(\n    BaseHierarchialMetadata,\n    BaseAttributtedMetadata,\n    BaseMetadata,\n):\n    \"\"\"Class for Hierarchial, Attributed Adaptive Metadata.\"\"\"\n\n    def __post_init__(\n        self,\n        attributes: Sequence[MetadataAttribute] | None = None,  # NOQA: RUF033\n        parent: Self | None = None,  # NOQA: RUF033\n        children: Sequence[Self] | None = None,  # NOQA: RUF033\n    ) -&gt; None:\n        \"\"\"Clean up HierarchialAttributedMetadata instance.\n\n        Args:\n            attributes: Adaptive Attributes\n            parent: Adaptive parent\n            children: Adaptive children\n\n        \"\"\"\n        BaseHierarchialMetadata.__post_init__(self, parent=parent, children=children)\n        BaseAttributtedMetadata.__post_init__(self, attributes=attributes)\n        BaseMetadata.__post_init__(self)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.HierarchialAttributedMetadata.__post_init__","title":"<code>__post_init__(attributes=None, parent=None, children=None)</code>","text":"<p>Clean up HierarchialAttributedMetadata instance.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Sequence[MetadataAttribute] | None</code> <p>Adaptive Attributes</p> <code>None</code> <code>parent</code> <code>Self | None</code> <p>Adaptive parent</p> <code>None</code> <code>children</code> <code>Sequence[Self] | None</code> <p>Adaptive children</p> <code>None</code> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def __post_init__(\n    self,\n    attributes: Sequence[MetadataAttribute] | None = None,  # NOQA: RUF033\n    parent: Self | None = None,  # NOQA: RUF033\n    children: Sequence[Self] | None = None,  # NOQA: RUF033\n) -&gt; None:\n    \"\"\"Clean up HierarchialAttributedMetadata instance.\n\n    Args:\n        attributes: Adaptive Attributes\n        parent: Adaptive parent\n        children: Adaptive children\n\n    \"\"\"\n    BaseHierarchialMetadata.__post_init__(self, parent=parent, children=children)\n    BaseAttributtedMetadata.__post_init__(self, attributes=attributes)\n    BaseMetadata.__post_init__(self)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.HierchialMetadata","title":"<code>HierchialMetadata</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseHierarchialMetadata</code>, <code>BaseMetadata</code></p> <p>Calss for Hierarchial Adaptive Metadata.</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@dataclass(eq=False)\nclass HierchialMetadata(BaseHierarchialMetadata, BaseMetadata):\n    \"\"\"Calss for Hierarchial Adaptive Metadata.\"\"\"\n\n    def __post_init__(\n        self,\n        parent: Self | None = None,  # NOQA: RUF033\n        children: Sequence[Self] | None = None,  # NOQA: RUF033\n    ) -&gt; None:\n        \"\"\"Clean up HierchialMetadata instance.\n\n        Args:\n            parent: Adaptive parent\n            children: Adaptive children\n\n        \"\"\"\n        BaseHierarchialMetadata.__post_init__(self, parent=parent, children=children)\n        BaseMetadata.__post_init__(self)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.HierchialMetadata.__post_init__","title":"<code>__post_init__(parent=None, children=None)</code>","text":"<p>Clean up HierchialMetadata instance.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Self | None</code> <p>Adaptive parent</p> <code>None</code> <code>children</code> <code>Sequence[Self] | None</code> <p>Adaptive children</p> <code>None</code> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def __post_init__(\n    self,\n    parent: Self | None = None,  # NOQA: RUF033\n    children: Sequence[Self] | None = None,  # NOQA: RUF033\n) -&gt; None:\n    \"\"\"Clean up HierchialMetadata instance.\n\n    Args:\n        parent: Adaptive parent\n        children: Adaptive children\n\n    \"\"\"\n    BaseHierarchialMetadata.__post_init__(self, parent=parent, children=children)\n    BaseMetadata.__post_init__(self)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.Metadata","title":"<code>Metadata</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>Class for Adaptive Metadata.</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@dataclass(eq=False)\nclass Metadata(BaseMetadata):\n    \"\"\"Class for Adaptive Metadata.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Clean up Metadata instance.\"\"\"\n        BaseMetadata.__post_init__(self)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.Metadata.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Clean up Metadata instance.</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Clean up Metadata instance.\"\"\"\n    BaseMetadata.__post_init__(self)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.MetadataAttribute","title":"<code>MetadataAttribute</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>Attributes of BaseMetadata members.</p> <p>Attributes:</p> Name Type Description <code>attribute_id</code> <code>int | None</code> <p>Adaptive Attribute ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Attribute Name</p> <code>value_id</code> <code>int | None</code> <p>Adaptive Attribute Value ID</p> <code>value</code> <code>str | None</code> <p>Adaptive Attribute Value Name</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>@dataclass(eq=False)\nclass MetadataAttribute(BaseMetadata):\n    \"\"\"Attributes of BaseMetadata members.\n\n    Attributes:\n        attribute_id: Adaptive Attribute ID\n        name: Adaptive Attribute Name\n        value_id: Adaptive Attribute Value ID\n        value: Adaptive Attribute Value Name\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    attribute_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"attributeId\",\n            \"xml_read\": \"attributeId\",\n            \"xml_update\": \"\",\n            \"xml_delete\": \"attributeId\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    value_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"valueId\",\n            \"xml_update\": \"\",\n            \"xml_delete\": \"\",\n        },\n    )\n    value: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"value\",\n            \"xml_read\": \"value\",\n            \"xml_update\": \"value\",\n            \"xml_delete\": \"value\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"attributes\",\n        \"xml_create_tag\": \"attribute\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"attributes\",\n        \"xml_read_tag\": \"attribute\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"attributes\",\n        \"xml_update_tag\": \"attribute\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"attributes\",\n        \"xml_delete_tag\": \"attribute\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.bool_or_none","title":"<code>bool_or_none(value)</code>","text":"<p>Convert a value to either boolean or None.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | int | bool | None</code> <p>Value to convert to boolean or None</p> required <p>Returns:</p> Type Description <code>bool | None</code> <p>Boolean value or None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Unexpected value</p> <code>TypeError</code> <p>Unexpected type</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def bool_or_none(value: str | int | bool | None) -&gt; bool | None:  # NOQA: FBT001\n    \"\"\"Convert a value to either boolean or None.\n\n    Args:\n        value: Value to convert to boolean or None\n\n    Returns:\n        Boolean value or None\n\n    Raises:\n        ValueError: Unexpected value\n        TypeError: Unexpected type\n\n    \"\"\"\n    if value is None or isinstance(value, bool):\n        return value\n    if isinstance(value, int):\n        if value == 1:\n            return True\n        if value == 0:\n            return False\n        error_message = \"Invalid boolean value\"\n        raise ValueError(error_message)\n    if isinstance(value, str):\n        if value.lower() in [\"true\", \"t\", \"y\", \"yes\", \"1\"]:\n            return True\n        if value.lower() in [\"false\", \"f\", \"n\", \"no\", \"0\"]:\n            return False\n        if value == \"\":\n            return None\n        error_message = \"Invalid boolean value\"\n        raise ValueError(error_message)\n    error_message = \"Unexpected type for boolean\"\n    raise TypeError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.bool_to_str_one_zero","title":"<code>bool_to_str_one_zero(value)</code>","text":"<p>Convert boolean to string value of 1 or 0.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool | None</code> <p>Value to convert to 1 or 0</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>1 or 0 or None</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Unexpected type</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def bool_to_str_one_zero(value: bool | None) -&gt; str | None:  # NOQA: FBT001\n    \"\"\"Convert boolean to string value of 1 or 0.\n\n    Args:\n        value: Value to convert to 1 or 0\n\n    Returns:\n        1 or 0 or None\n\n    Raises:\n        TypeError: Unexpected type\n\n    \"\"\"\n    if value is None:\n        return None\n    if value is True:\n        return \"1\"\n    if value is False:\n        return \"0\"\n    error_message = \"Unexpected type for boolean\"\n    raise TypeError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.bool_to_str_true_false","title":"<code>bool_to_str_true_false(value)</code>","text":"<p>Convert boolean to string of true or false.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool | None</code> <p>Value to convert to true or fale</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>true or false or None</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Unexpected type</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def bool_to_str_true_false(value: bool | None) -&gt; str | None:  # NOQA: FBT001\n    \"\"\"Convert boolean to string of true or false.\n\n    Args:\n        value: Value to convert to true or fale\n\n    Returns:\n        true or false or None\n\n    Raises:\n        TypeError: Unexpected type\n\n    \"\"\"\n    if value is None:\n        return None\n    if value is True:\n        return \"true\"\n    if value is False:\n        return \"false\"\n    error_message = \"Unexpected type for boolean\"\n    raise TypeError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.bool_to_str_y_n","title":"<code>bool_to_str_y_n(value)</code>","text":"<p>Convert boolean to y or n.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool | None</code> <p>Value to convert to y or n</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>y or n or None</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Unexpected type</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def bool_to_str_y_n(value: bool | None) -&gt; str | None:  # NOQA: FBT001\n    \"\"\"Convert boolean to y or n.\n\n    Args:\n        value: Value to convert to y or n\n\n    Returns:\n        y or n or None\n\n    Raises:\n        TypeError: Unexpected type\n\n    \"\"\"\n    if value is None:\n        return None\n    if value is True:\n        return \"y\"\n    if value is False:\n        return \"n\"\n    error_message = \"Unexpected type for boolean\"\n    raise TypeError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.int_list_or_none","title":"<code>int_list_or_none(value)</code>","text":"<p>Convert to list of integers.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | int | Sequence[int] | Sequence[str] | None</code> <p>Value to convert to list of integers</p> required <p>Returns:</p> Type Description <code>list[int] | None</code> <p>List of integers</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Unexpected type</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def int_list_or_none(\n    value: str | int | Sequence[int] | Sequence[str] | None,\n) -&gt; list[int] | None:\n    \"\"\"Convert to list of integers.\n\n    Args:\n        value: Value to convert to list of integers\n\n    Returns:\n       List of integers\n\n    Raises:\n        TypeError: Unexpected type\n\n    \"\"\"\n    if value is None:\n        return None\n    if isinstance(value, str):\n        return [int(value)]\n    if isinstance(value, int):\n        return [value]\n    if isinstance(value, Sequence):\n        return [int(x) for x in value]\n    error_message = \"unexpected type for integer list\"\n    raise TypeError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.int_list_to_str","title":"<code>int_list_to_str(value)</code>","text":"<p>Convert list of integers to string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Sequence[int] | None</code> <p>Value to convert to string</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Joined string from list of integers or None</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def int_list_to_str(value: Sequence[int] | None) -&gt; str | None:\n    \"\"\"Convert list of integers to string.\n\n    Args:\n        value: Value to convert to string\n\n    Returns:\n        Joined string from list of integers or None\n\n    \"\"\"\n    if value is None:\n        return value\n    return \",\".join([str(x) for x in value])\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.int_or_none","title":"<code>int_or_none(value)</code>","text":"<p>Convert value to an integer or None.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | int | None</code> <p>Value to convert to integer or None</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>integer or None</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Unexpected type</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def int_or_none(value: str | int | None) -&gt; int | None:\n    \"\"\"Convert value to an integer or None.\n\n    Args:\n        value: Value to convert to integer or None\n\n    Returns:\n        integer or None\n\n    Raises:\n        TypeError: Unexpected type\n\n    \"\"\"\n    if value is None:\n        return None\n    if isinstance(value, int):\n        return value\n    if isinstance(value, str):\n        return int(value)\n    error_message = \"Unexpected type for integer\"\n    raise TypeError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.int_to_str","title":"<code>int_to_str(value)</code>","text":"<p>Convert integer to string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int | str | None</code> <p>Value to convert to a string</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>String</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Unexpected type</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def int_to_str(value: int | str | None) -&gt; str | None:\n    \"\"\"Convert integer to string.\n\n    Args:\n        value: Value to convert to a string\n\n    Returns:\n        String\n\n    Raises:\n        TypeError: Unexpected type\n\n    \"\"\"\n    if value is None:\n        return None\n    if isinstance(value, int):\n        return str(value)\n    if isinstance(value, str):\n        try:\n            int_value = int(value)\n            return str(int_value)\n        except TypeError as e:\n            error_message = \"Unable to convert to integer\"\n            raise TypeError(error_message) from e\n    error_message = \"Unexpected type for integer\"\n    raise TypeError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.nullable_int_or_none","title":"<code>nullable_int_or_none(value)</code>","text":"<p>Convert integer to string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | int | None</code> <p>Value to convert to string</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>String or None</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Unexpected type</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def nullable_int_or_none(value: str | int | None) -&gt; str | None:\n    \"\"\"Convert integer to string.\n\n    Args:\n        value: Value to convert to string\n\n    Returns:\n        String or None\n\n    Raises:\n        TypeError: Unexpected type\n\n    \"\"\"\n    if value is None:\n        return None\n    if isinstance(value, int):\n        return str(value)\n    if isinstance(value, str):\n        if value == \"\":\n            return value\n        return str(int(value))\n    error_message = \"Unexpected type for integer\"\n    raise TypeError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.str_or_none","title":"<code>str_or_none(value)</code>","text":"<p>Convert value to string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | None</code> <p>Value to convert to string</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>String</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Unexpected type</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def str_or_none(value: str | None) -&gt; str | None:\n    \"\"\"Convert value to string.\n\n    Args:\n        value: Value to convert to string\n\n    Returns:\n        String\n\n    Raises:\n        TypeError: Unexpected type\n\n    \"\"\"\n    if value is None:\n        return None\n    if isinstance(value, str):\n        return value\n    error_message = \"Unexpected type for string\"\n    raise TypeError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/base/#wdadaptivepy.models.base.str_to_str","title":"<code>str_to_str(value)</code>","text":"<p>Convert string to string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | None</code> <p>Value to convert to string</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>String</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Unexpected type</p> Source code in <code>src/wdadaptivepy/models/base.py</code> <pre><code>def str_to_str(value: str | None) -&gt; str | None:\n    \"\"\"Convert string to string.\n\n    Args:\n        value: Value to convert to string\n\n    Returns:\n        String\n\n    Raises:\n        TypeError: Unexpected type\n\n    \"\"\"\n    if value is None:\n        return None\n    if isinstance(value, str):\n        return value\n    error_message = \"Unexpected type for string\"\n    raise TypeError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/currency/","title":"currency","text":"<p>wdadaptivepy model for Adaptive's Currencies.</p>"},{"location":"reference/wdadaptivepy/models/currency/#wdadaptivepy.models.currency.Currency","title":"<code>Currency</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Currencies.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Currency ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Currency Code</p> <code>precision</code> <code>str | None</code> <p>Adaptive Currency Precision</p> <code>is_reporting_currency</code> <code>bool | None</code> <p>Adaptive Currency Is Reporting Currency</p> <code>user_defined</code> <code>bool | None</code> <p>Adaptive Currency User Defined</p> <code>description</code> <code>str | None</code> <p>Adaptive Currency Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/currency.py</code> <pre><code>@dataclass(eq=False)\nclass Currency(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Currencies.\n\n    Attributes:\n        id: Adaptive Currency ID\n        code: Adaptive Currency Code\n        precision: Adaptive Currency Precision\n        is_reporting_currency: Adaptive Currency Is Reporting Currency\n        user_defined: Adaptive Currency User Defined\n        description: Adaptive Currency Description\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    precision: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"precision\",\n            \"xml_read\": \"precision\",\n            \"xml_update\": \"precision\",\n            \"xml_delete\": \"precision\",\n        },\n    )\n    is_reporting_currency: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isReportingCurrency\",\n            \"xml_read\": \"isReportingCurrency\",\n            \"xml_update\": \"isReportingCurrency\",\n            \"xml_delete\": \"isReportingCurrency\",\n        },\n    )\n    user_defined: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"userDefined\",\n            \"xml_read\": \"userDefined\",\n            \"xml_update\": \"userDefined\",\n            \"xml_delete\": \"userDefined\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"currencies\",\n        \"xml_create_tag\": \"currency\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"currencies\",\n        \"xml_read_tag\": \"currency\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"currencies\",\n        \"xml_update_tag\": \"currency\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"currencies\",\n        \"xml_delete_tag\": \"currency\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/","title":"data","text":"<p>wdadaptivepy model for Adaptive data.</p>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.AccountFilter","title":"<code>AccountFilter</code>  <code>dataclass</code>","text":"<p>Adaptive Account Filter.</p> <p>Attributes:</p> Name Type Description <code>account</code> <code>Account | Sequence[Account]</code> <p>Adaptive Account</p> <code>include_descendants</code> <code>bool</code> <p>Adaptive Include Desccendants</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>@dataclass\nclass AccountFilter:\n    \"\"\"Adaptive Account Filter.\n\n    Attributes:\n        account: Adaptive Account\n        include_descendants: Adaptive Include Desccendants\n\n    \"\"\"\n\n    account: Account | Sequence[Account] = field(metadata={\"validator\": has_code})\n    include_descendants: bool = field(default=False, metadata={\"validator\": is_bool})\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.CurrencyFilter","title":"<code>CurrencyFilter</code>  <code>dataclass</code>","text":"<p>Adaptive Currency Filter.</p> <p>Attributes:</p> Name Type Description <code>use_corporate</code> <code>bool | None</code> <p>Adaptive Use Corporate</p> <code>use_local</code> <code>bool | None</code> <p>Adaptive Use Local</p> <code>override</code> <code>str | None</code> <p>Adaptive Override</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>@dataclass\nclass CurrencyFilter:\n    \"\"\"Adaptive Currency Filter.\n\n    Attributes:\n        use_corporate: Adaptive Use Corporate\n        use_local: Adaptive Use Local\n        override: Adaptive Override\n\n    \"\"\"\n\n    use_corporate: bool | None = field(\n        default=None,\n        metadata={\"validator\": is_none_or_is_bool},\n    )\n    use_local: bool | None = field(\n        default=None,\n        metadata={\"validator\": is_none_or_is_bool},\n    )\n    override: str | None = field(\n        default=None,\n        metadata={\"validator\": is_none_or_is_string},\n    )\n\n    def to_xml_element(self) -&gt; ET.Element:\n        \"\"\"Convert Currency Filter to XML Element.\n\n        Returns:\n            XML Element\n\n        Raises:\n            ValueError: Unexpected value\n\n        \"\"\"\n        currency_element = ET.Element(\"currency\")\n\n        use_corporate = bool_to_str_true_false(self.use_corporate)\n        use_local = bool_to_str_true_false(self.use_local)\n        override = str_to_str(self.override)\n        property_count = sum(\n            1 for attr in (use_corporate, use_local, override) if attr is not None\n        )\n        if property_count != 1:\n            error_message = \"Expected exactly least one currency property\"\n            raise ValueError(error_message)\n\n        if use_corporate is not None:\n            currency_element.attrib[\"useCorporate\"] = use_corporate\n\n        if use_local is not None:\n            currency_element.attrib[\"useLocal\"] = use_local\n\n        if override is not None:\n            currency_element.attrib[\"override\"] = override\n\n        return currency_element\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.CurrencyFilter.to_xml_element","title":"<code>to_xml_element()</code>","text":"<p>Convert Currency Filter to XML Element.</p> <p>Returns:</p> Type Description <code>Element</code> <p>XML Element</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Unexpected value</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def to_xml_element(self) -&gt; ET.Element:\n    \"\"\"Convert Currency Filter to XML Element.\n\n    Returns:\n        XML Element\n\n    Raises:\n        ValueError: Unexpected value\n\n    \"\"\"\n    currency_element = ET.Element(\"currency\")\n\n    use_corporate = bool_to_str_true_false(self.use_corporate)\n    use_local = bool_to_str_true_false(self.use_local)\n    override = str_to_str(self.override)\n    property_count = sum(\n        1 for attr in (use_corporate, use_local, override) if attr is not None\n    )\n    if property_count != 1:\n        error_message = \"Expected exactly least one currency property\"\n        raise ValueError(error_message)\n\n    if use_corporate is not None:\n        currency_element.attrib[\"useCorporate\"] = use_corporate\n\n    if use_local is not None:\n        currency_element.attrib[\"useLocal\"] = use_local\n\n    if override is not None:\n        currency_element.attrib[\"override\"] = override\n\n    return currency_element\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.DimensionValueFilter","title":"<code>DimensionValueFilter</code>  <code>dataclass</code>","text":"<p>Adaptive Dimension Value Filter.</p> <p>Attributes:</p> Name Type Description <code>dimension_value</code> <code>DimensionValue | Sequence[DimensionValue] | None</code> <p>Adaptive Dimension Value</p> <code>direct_children</code> <code>bool | None</code> <p>Adaptive Direct Children</p> <code>uncategorized</code> <code>bool | None</code> <p>Adaptive Uncategorized</p> <code>uncategorized_of_dimension</code> <code>Dimension | Sequence[Dimension] | None</code> <p>Adaptive Uncategorized of Dimension</p> <code>direct_children_of_dimension</code> <code>bool | None</code> <p>Adaptive Directchildren of Dimension</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>@dataclass\nclass DimensionValueFilter:\n    \"\"\"Adaptive Dimension Value Filter.\n\n    Attributes:\n        dimension_value: Adaptive Dimension Value\n        direct_children: Adaptive Direct Children\n        uncategorized: Adaptive Uncategorized\n        uncategorized_of_dimension: Adaptive Uncategorized of Dimension\n        direct_children_of_dimension: Adaptive Directchildren of Dimension\n\n    \"\"\"\n\n    #\n    # dimension: Optional[Dimension | Sequence[Dimension]] = field(\n    #     metadata={\"validator\": is_none_or_has_name}\n    # )\n    dimension_value: DimensionValue | Sequence[DimensionValue] | None = field(\n        metadata={\"validator\": is_none_or_has_code},\n    )\n    direct_children: bool | None = field(metadata={\"validator\": is_none_or_is_bool})\n    uncategorized: bool | None = field(metadata={\"validator\": is_none_or_is_bool})\n    # uncategorized_of_dimension: Optional[bool] = field(\n    #     metadata={\"validator\": is_none_or_is_bool}\n    # )\n    uncategorized_of_dimension: Dimension | Sequence[Dimension] | None\n    direct_children_of_dimension: bool | None = field(\n        metadata={\"validator\": is_none_or_is_bool},\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.ExportDataFilter","title":"<code>ExportDataFilter</code>  <code>dataclass</code>","text":"<p>Adaptive Export Data Filter.</p> <p>Attributes:</p> Name Type Description <code>accounts</code> <code>AccountFilter | Sequence[AccountFilter]</code> <p>Adaptive Accounts</p> <code>time</code> <code>TimeFilter</code> <p>Adaptive Time</p> <code>levels</code> <code>LevelFilter | Sequence[LevelFilter] | None</code> <p>Adaptive Levels</p> <code>dimension_values</code> <code>DimensionValueFilter | Sequence[DimensionValueFilter] | None</code> <p>Adaptive Dimension Values</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>@dataclass\nclass ExportDataFilter:\n    \"\"\"Adaptive Export Data Filter.\n\n    Attributes:\n        accounts: Adaptive Accounts\n        time: Adaptive Time\n        levels: Adaptive Levels\n        dimension_values: Adaptive Dimension Values\n\n    \"\"\"\n\n    accounts: AccountFilter | Sequence[AccountFilter]\n    time: TimeFilter\n    levels: LevelFilter | Sequence[LevelFilter] | None = field(\n        default=None,\n    )\n    dimension_values: DimensionValueFilter | Sequence[DimensionValueFilter] | None = (\n        field(default=None)\n    )\n\n    def to_xml_element(self) -&gt; ET.Element:  # NOQA: PLR0912, PLR0915\n        \"\"\"Convert ExportDataFilter to XML Element.\n\n        Returns:\n            XML Element\n\n        Raises:\n            ValueError: Unexpected value\n\n        \"\"\"\n        filters_element = ET.Element(\"filters\")\n\n        accounts_element = ET.Element(\"accounts\")\n        if isinstance(self.accounts, Sequence):\n            for account_filter in self.accounts:\n                include_descendants = bool_to_str_true_false(\n                    account_filter.include_descendants,\n                )\n                if include_descendants is None:\n                    error_message = \"Expected include_descendants value\"\n                    raise ValueError(error_message)\n                if isinstance(account_filter.account, Sequence):\n                    for account in account_filter.account:\n                        code = str_to_str(account.code)\n                        if code is None:\n                            error_message = \"Expected code value\"\n                            raise ValueError(error_message)\n                        is_assumption = bool_to_str_true_false(account.is_assumption)\n                        if is_assumption is None:\n                            error_message = \"Expected is_assumption value\"\n                            raise ValueError(error_message)\n                        account_element = ET.Element(\n                            \"account\",\n                            attrib={\n                                \"code\": code,\n                                \"isAssumption\": is_assumption,\n                                \"includeDescendants\": include_descendants,\n                            },\n                        )\n                        accounts_element.append(account_element)\n                else:\n                    account = account_filter.account\n                    code = str_to_str(account.code)\n                    if code is None:\n                        error_message = \"Expected code value\"\n                        raise ValueError(error_message)\n                    is_assumption = bool_to_str_true_false(account.is_assumption)\n                    if is_assumption is None:\n                        error_message = \"Expected is_assumption value\"\n                        raise ValueError(error_message)\n                    account_element = ET.Element(\n                        \"account\",\n                        attrib={\n                            \"code\": code,\n                            \"isAssumption\": is_assumption,\n                            \"includeDescendants\": include_descendants,\n                        },\n                    )\n                    accounts_element.append(account_element)\n        else:\n            account_filter = self.accounts\n            include_descendants = bool_to_str_true_false(\n                account_filter.include_descendants,\n            )\n            if include_descendants is None:\n                error_message = \"Expected include_descendants value\"\n                raise ValueError(error_message)\n            if isinstance(account_filter.account, Sequence):\n                for account in account_filter.account:\n                    code = str_to_str(account.code)\n                    if code is None:\n                        error_message = \"Expected code value\"\n                        raise ValueError(error_message)\n                    is_assumption = bool_to_str_true_false(account.is_assumption)\n                    if is_assumption is None:\n                        error_message = \"Expected is_assumption value\"\n                        raise ValueError(error_message)\n                    account_element = ET.Element(\n                        \"account\",\n                        attrib={\n                            \"code\": code,\n                            \"isAssumption\": is_assumption,\n                            \"includeDescendants\": include_descendants,\n                        },\n                    )\n                    accounts_element.append(account_element)\n            else:\n                account = account_filter.account\n                code = str_to_str(account.code)\n                if code is None:\n                    error_message = \"Expected code value\"\n                    raise ValueError(error_message)\n                is_assumption = bool_to_str_true_false(account.is_assumption)\n                if is_assumption is None:\n                    error_message = \"Expected is_assumption value\"\n                    raise ValueError(error_message)\n                account_element = ET.Element(\n                    \"account\",\n                    attrib={\n                        \"code\": code,\n                        \"isAssumption\": is_assumption,\n                        \"includeDescendants\": include_descendants,\n                    },\n                )\n                accounts_element.append(account_element)\n        filters_element.append(accounts_element)\n\n        if self.levels is not None:\n            levels_element = ET.Element(\"levels\")\n            if isinstance(self.levels, Sequence):\n                for level_filter in self.levels:\n                    is_rollup = bool_to_str_true_false(level_filter.is_rollup)\n                    if is_rollup is None:\n                        error_message = \"Expected is_rollup value\"\n                        raise ValueError(error_message)\n                    include_descendants = bool_to_str_true_false(\n                        level_filter.include_descendants,\n                    )\n                    if include_descendants is None:\n                        error_message = \"Expected include_descendants value\"\n                        raise ValueError(error_message)\n                    if isinstance(level_filter.level, Sequence):\n                        for level in level_filter.level:\n                            code = str_to_str(level.code)\n                            if code is None:\n                                error_message = \"Expected code value\"\n                                raise ValueError(error_message)\n                            name = str_to_str(level.name)\n                            if name is None:\n                                error_message = \"Expected name value\"\n                                raise ValueError(error_message)\n                            level_element = ET.Element(\n                                \"level\",\n                                attrib={\n                                    \"code\": code,\n                                    \"name\": name,\n                                    \"isRollup\": is_rollup,\n                                    \"includeDescendants\": include_descendants,\n                                },\n                            )\n                            levels_element.append(level_element)\n                    else:\n                        level = level_filter.level\n                        code = str_to_str(level.code)\n                        if code is None:\n                            error_message = \"Expected code value\"\n                            raise ValueError(error_message)\n                        name = str_to_str(level.name)\n                        if name is None:\n                            error_message = \"Expected name value\"\n                            raise ValueError(error_message)\n                        level_element = ET.Element(\n                            \"level\",\n                            attrib={\n                                \"code\": code,\n                                \"name\": name,\n                                \"isRollup\": is_rollup,\n                                \"includeDescendants\": include_descendants,\n                            },\n                        )\n                        levels_element.append(level_element)\n            else:\n                level_filter = self.levels\n                is_rollup = bool_to_str_true_false(level_filter.is_rollup)\n                if is_rollup is None:\n                    error_message = \"Expected is_rollup value\"\n                    raise ValueError(error_message)\n                include_descendants = bool_to_str_true_false(\n                    level_filter.include_descendants,\n                )\n                if include_descendants is None:\n                    error_message = \"Expected include_descendants value\"\n                    raise ValueError(error_message)\n                if isinstance(level_filter.level, Sequence):\n                    for level in level_filter.level:\n                        code = str_to_str(level.code)\n                        if code is None:\n                            error_message = \"Expected code value\"\n                            raise ValueError(error_message)\n                        name = str_to_str(level.name)\n                        if name is None:\n                            error_message = \"Expected name value\"\n                            raise ValueError(error_message)\n                        level_element = ET.Element(\n                            \"level\",\n                            attrib={\n                                \"code\": code,\n                                \"name\": name,\n                                \"isRollup\": is_rollup,\n                                \"includeDescendants\": include_descendants,\n                            },\n                        )\n                        levels_element.append(level_element)\n                else:\n                    level = level_filter.level\n                    code = str_to_str(level.code)\n                    if code is None:\n                        error_message = \"Expected code value\"\n                        raise ValueError(error_message)\n                    name = str_to_str(level.name)\n                    if name is None:\n                        error_message = \"Expected name value\"\n                        raise ValueError(error_message)\n                    level_element = ET.Element(\n                        \"level\",\n                        attrib={\n                            \"code\": code,\n                            \"name\": name,\n                            \"isRollup\": is_rollup,\n                            \"includeDescendants\": include_descendants,\n                        },\n                    )\n                    levels_element.append(level_element)\n\n        start = str_to_str(self.time.start.code)\n        if start is None:\n            error_message = \"Expected start value\"\n            raise ValueError(error_message)\n        end = str_to_str(self.time.end.code)\n        if end is None:\n            error_message = \"Expected end value\"\n            raise ValueError(error_message)\n        time_span_element = ET.Element(\"timeSpan\", attrib={\"start\": start, \"end\": end})\n        if self.time.stratum is not None:\n            stratum = str_to_str(self.time.stratum.code)\n            if stratum is not None:\n                time_span_element.attrib[\"stratum\"] = stratum\n        filters_element.append(time_span_element)\n\n        if self.dimension_values is not None:\n            dimension_values_element = ET.Element(\"dimensionValues\")\n            if isinstance(self.dimension_values, Sequence):\n                for dimension_value_filter in self.dimension_values:\n                    if isinstance(\n                        dimension_value_filter.uncategorized_of_dimension,\n                        Sequence,\n                    ):\n                        for (\n                            dimension\n                        ) in dimension_value_filter.uncategorized_of_dimension:\n                            dimension_value_element = ET.Element(\"dimensionValue\")\n                            dimension_name = str_to_str(dimension.name)\n                            dimension_id = int_to_str(dimension.id)\n                            if dimension_name is None and dimension_id is None:\n                                error_message = (\n                                    \"One or more of dimension name or \"\n                                    \"dimension id value expected\"\n                                )\n                                raise ValueError(error_message)\n                            if dimension_id is not None:\n                                dimension_value_element.attrib[\n                                    \"uncategorizedOfDimension\"\n                                ] = dimension_id\n                            elif dimension_name is not None:\n                                dimension_value_element.attrib[\"uncategorized\"] = (\n                                    dimension_name\n                                )\n                            dimension_values_element.append(dimension_value_element)\n                    elif dimension_value_filter.uncategorized_of_dimension is not None:\n                        dimension = dimension_value_filter.uncategorized_of_dimension\n                        dimension_value_element = ET.Element(\"dimensionValue\")\n                        dimension_name = str_to_str(dimension.name)\n                        dimension_id = int_to_str(dimension.id)\n                        if dimension_name is None and dimension_id is None:\n                            error_message = (\n                                \"One or more of dimension name \"\n                                \"or dimension id value expected\"\n                            )\n                            raise ValueError(error_message)\n                        if dimension_id is not None:\n                            dimension_value_element.attrib[\n                                \"uncategorizedOfDimension\"\n                            ] = dimension_id\n                        elif dimension_name is not None:\n                            dimension_value_element.attrib[\"uncategorized\"] = (\n                                dimension_name\n                            )\n                        dimension_values_element.append(dimension_value_element)\n\n        return filters_element\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.ExportDataFilter.to_xml_element","title":"<code>to_xml_element()</code>","text":"<p>Convert ExportDataFilter to XML Element.</p> <p>Returns:</p> Type Description <code>Element</code> <p>XML Element</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Unexpected value</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def to_xml_element(self) -&gt; ET.Element:  # NOQA: PLR0912, PLR0915\n    \"\"\"Convert ExportDataFilter to XML Element.\n\n    Returns:\n        XML Element\n\n    Raises:\n        ValueError: Unexpected value\n\n    \"\"\"\n    filters_element = ET.Element(\"filters\")\n\n    accounts_element = ET.Element(\"accounts\")\n    if isinstance(self.accounts, Sequence):\n        for account_filter in self.accounts:\n            include_descendants = bool_to_str_true_false(\n                account_filter.include_descendants,\n            )\n            if include_descendants is None:\n                error_message = \"Expected include_descendants value\"\n                raise ValueError(error_message)\n            if isinstance(account_filter.account, Sequence):\n                for account in account_filter.account:\n                    code = str_to_str(account.code)\n                    if code is None:\n                        error_message = \"Expected code value\"\n                        raise ValueError(error_message)\n                    is_assumption = bool_to_str_true_false(account.is_assumption)\n                    if is_assumption is None:\n                        error_message = \"Expected is_assumption value\"\n                        raise ValueError(error_message)\n                    account_element = ET.Element(\n                        \"account\",\n                        attrib={\n                            \"code\": code,\n                            \"isAssumption\": is_assumption,\n                            \"includeDescendants\": include_descendants,\n                        },\n                    )\n                    accounts_element.append(account_element)\n            else:\n                account = account_filter.account\n                code = str_to_str(account.code)\n                if code is None:\n                    error_message = \"Expected code value\"\n                    raise ValueError(error_message)\n                is_assumption = bool_to_str_true_false(account.is_assumption)\n                if is_assumption is None:\n                    error_message = \"Expected is_assumption value\"\n                    raise ValueError(error_message)\n                account_element = ET.Element(\n                    \"account\",\n                    attrib={\n                        \"code\": code,\n                        \"isAssumption\": is_assumption,\n                        \"includeDescendants\": include_descendants,\n                    },\n                )\n                accounts_element.append(account_element)\n    else:\n        account_filter = self.accounts\n        include_descendants = bool_to_str_true_false(\n            account_filter.include_descendants,\n        )\n        if include_descendants is None:\n            error_message = \"Expected include_descendants value\"\n            raise ValueError(error_message)\n        if isinstance(account_filter.account, Sequence):\n            for account in account_filter.account:\n                code = str_to_str(account.code)\n                if code is None:\n                    error_message = \"Expected code value\"\n                    raise ValueError(error_message)\n                is_assumption = bool_to_str_true_false(account.is_assumption)\n                if is_assumption is None:\n                    error_message = \"Expected is_assumption value\"\n                    raise ValueError(error_message)\n                account_element = ET.Element(\n                    \"account\",\n                    attrib={\n                        \"code\": code,\n                        \"isAssumption\": is_assumption,\n                        \"includeDescendants\": include_descendants,\n                    },\n                )\n                accounts_element.append(account_element)\n        else:\n            account = account_filter.account\n            code = str_to_str(account.code)\n            if code is None:\n                error_message = \"Expected code value\"\n                raise ValueError(error_message)\n            is_assumption = bool_to_str_true_false(account.is_assumption)\n            if is_assumption is None:\n                error_message = \"Expected is_assumption value\"\n                raise ValueError(error_message)\n            account_element = ET.Element(\n                \"account\",\n                attrib={\n                    \"code\": code,\n                    \"isAssumption\": is_assumption,\n                    \"includeDescendants\": include_descendants,\n                },\n            )\n            accounts_element.append(account_element)\n    filters_element.append(accounts_element)\n\n    if self.levels is not None:\n        levels_element = ET.Element(\"levels\")\n        if isinstance(self.levels, Sequence):\n            for level_filter in self.levels:\n                is_rollup = bool_to_str_true_false(level_filter.is_rollup)\n                if is_rollup is None:\n                    error_message = \"Expected is_rollup value\"\n                    raise ValueError(error_message)\n                include_descendants = bool_to_str_true_false(\n                    level_filter.include_descendants,\n                )\n                if include_descendants is None:\n                    error_message = \"Expected include_descendants value\"\n                    raise ValueError(error_message)\n                if isinstance(level_filter.level, Sequence):\n                    for level in level_filter.level:\n                        code = str_to_str(level.code)\n                        if code is None:\n                            error_message = \"Expected code value\"\n                            raise ValueError(error_message)\n                        name = str_to_str(level.name)\n                        if name is None:\n                            error_message = \"Expected name value\"\n                            raise ValueError(error_message)\n                        level_element = ET.Element(\n                            \"level\",\n                            attrib={\n                                \"code\": code,\n                                \"name\": name,\n                                \"isRollup\": is_rollup,\n                                \"includeDescendants\": include_descendants,\n                            },\n                        )\n                        levels_element.append(level_element)\n                else:\n                    level = level_filter.level\n                    code = str_to_str(level.code)\n                    if code is None:\n                        error_message = \"Expected code value\"\n                        raise ValueError(error_message)\n                    name = str_to_str(level.name)\n                    if name is None:\n                        error_message = \"Expected name value\"\n                        raise ValueError(error_message)\n                    level_element = ET.Element(\n                        \"level\",\n                        attrib={\n                            \"code\": code,\n                            \"name\": name,\n                            \"isRollup\": is_rollup,\n                            \"includeDescendants\": include_descendants,\n                        },\n                    )\n                    levels_element.append(level_element)\n        else:\n            level_filter = self.levels\n            is_rollup = bool_to_str_true_false(level_filter.is_rollup)\n            if is_rollup is None:\n                error_message = \"Expected is_rollup value\"\n                raise ValueError(error_message)\n            include_descendants = bool_to_str_true_false(\n                level_filter.include_descendants,\n            )\n            if include_descendants is None:\n                error_message = \"Expected include_descendants value\"\n                raise ValueError(error_message)\n            if isinstance(level_filter.level, Sequence):\n                for level in level_filter.level:\n                    code = str_to_str(level.code)\n                    if code is None:\n                        error_message = \"Expected code value\"\n                        raise ValueError(error_message)\n                    name = str_to_str(level.name)\n                    if name is None:\n                        error_message = \"Expected name value\"\n                        raise ValueError(error_message)\n                    level_element = ET.Element(\n                        \"level\",\n                        attrib={\n                            \"code\": code,\n                            \"name\": name,\n                            \"isRollup\": is_rollup,\n                            \"includeDescendants\": include_descendants,\n                        },\n                    )\n                    levels_element.append(level_element)\n            else:\n                level = level_filter.level\n                code = str_to_str(level.code)\n                if code is None:\n                    error_message = \"Expected code value\"\n                    raise ValueError(error_message)\n                name = str_to_str(level.name)\n                if name is None:\n                    error_message = \"Expected name value\"\n                    raise ValueError(error_message)\n                level_element = ET.Element(\n                    \"level\",\n                    attrib={\n                        \"code\": code,\n                        \"name\": name,\n                        \"isRollup\": is_rollup,\n                        \"includeDescendants\": include_descendants,\n                    },\n                )\n                levels_element.append(level_element)\n\n    start = str_to_str(self.time.start.code)\n    if start is None:\n        error_message = \"Expected start value\"\n        raise ValueError(error_message)\n    end = str_to_str(self.time.end.code)\n    if end is None:\n        error_message = \"Expected end value\"\n        raise ValueError(error_message)\n    time_span_element = ET.Element(\"timeSpan\", attrib={\"start\": start, \"end\": end})\n    if self.time.stratum is not None:\n        stratum = str_to_str(self.time.stratum.code)\n        if stratum is not None:\n            time_span_element.attrib[\"stratum\"] = stratum\n    filters_element.append(time_span_element)\n\n    if self.dimension_values is not None:\n        dimension_values_element = ET.Element(\"dimensionValues\")\n        if isinstance(self.dimension_values, Sequence):\n            for dimension_value_filter in self.dimension_values:\n                if isinstance(\n                    dimension_value_filter.uncategorized_of_dimension,\n                    Sequence,\n                ):\n                    for (\n                        dimension\n                    ) in dimension_value_filter.uncategorized_of_dimension:\n                        dimension_value_element = ET.Element(\"dimensionValue\")\n                        dimension_name = str_to_str(dimension.name)\n                        dimension_id = int_to_str(dimension.id)\n                        if dimension_name is None and dimension_id is None:\n                            error_message = (\n                                \"One or more of dimension name or \"\n                                \"dimension id value expected\"\n                            )\n                            raise ValueError(error_message)\n                        if dimension_id is not None:\n                            dimension_value_element.attrib[\n                                \"uncategorizedOfDimension\"\n                            ] = dimension_id\n                        elif dimension_name is not None:\n                            dimension_value_element.attrib[\"uncategorized\"] = (\n                                dimension_name\n                            )\n                        dimension_values_element.append(dimension_value_element)\n                elif dimension_value_filter.uncategorized_of_dimension is not None:\n                    dimension = dimension_value_filter.uncategorized_of_dimension\n                    dimension_value_element = ET.Element(\"dimensionValue\")\n                    dimension_name = str_to_str(dimension.name)\n                    dimension_id = int_to_str(dimension.id)\n                    if dimension_name is None and dimension_id is None:\n                        error_message = (\n                            \"One or more of dimension name \"\n                            \"or dimension id value expected\"\n                        )\n                        raise ValueError(error_message)\n                    if dimension_id is not None:\n                        dimension_value_element.attrib[\n                            \"uncategorizedOfDimension\"\n                        ] = dimension_id\n                    elif dimension_name is not None:\n                        dimension_value_element.attrib[\"uncategorized\"] = (\n                            dimension_name\n                        )\n                    dimension_values_element.append(dimension_value_element)\n\n    return filters_element\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.ExportDataFormat","title":"<code>ExportDataFormat</code>  <code>dataclass</code>","text":"<p>Adaptive Export Data Format.</p> <p>Attributes:</p> Name Type Description <code>use_internal_codes</code> <code>bool</code> <p>Adaptive Use Internal Codes</p> <code>use_ids</code> <code>bool | None</code> <p>Adaptive Use IDs</p> <code>include_unmapped_items</code> <code>bool | None</code> <p>Adaptive Include Unmapped Items</p> <code>include_codes</code> <code>bool | None</code> <p>Adaptive Include Codes</p> <code>include_names</code> <code>bool | None</code> <p>Adaptive Include Names</p> <code>include_display_names</code> <code>bool | None</code> <p>Adaptive Include Display Names</p> <code>display_name_enabled</code> <code>bool | None</code> <p>Adaptive Display Name Enabled</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>@dataclass\nclass ExportDataFormat:\n    \"\"\"Adaptive Export Data Format.\n\n    Attributes:\n        use_internal_codes: Adaptive Use Internal Codes\n        use_ids: Adaptive Use IDs\n        include_unmapped_items: Adaptive Include Unmapped Items\n        include_codes: Adaptive Include Codes\n        include_names: Adaptive Include Names\n        include_display_names: Adaptive Include Display Names\n        display_name_enabled: Adaptive Display Name Enabled\n\n    \"\"\"\n\n    use_internal_codes: bool = field(default=True, metadata={\"validator\": is_bool})\n    use_ids: bool | None = field(\n        default=False,\n        metadata={\"validator\": is_none_or_is_bool},\n    )\n    include_unmapped_items: bool | None = field(\n        default=True,\n        metadata={\"validator\": is_none_or_is_bool},\n    )\n    include_codes: bool | None = field(\n        default=True,\n        metadata={\"validator\": is_none_or_is_bool},\n    )\n    include_names: bool | None = field(\n        default=True,\n        metadata={\"validator\": is_none_or_is_bool},\n    )\n    include_display_names: bool | None = field(\n        default=False,\n        metadata={\"validator\": is_none_or_is_bool},\n    )\n    display_name_enabled: bool | None = field(\n        default=True,\n        metadata={\"validator\": is_none_or_is_bool},\n    )\n\n    def to_xml_element(self) -&gt; ET.Element:\n        \"\"\"Convert Export Data Format to XML Element.\n\n        Returns:\n            XML Element\n\n        Raises:\n            ValueError: Unexpected value\n\n        \"\"\"\n        format_element = ET.Element(\"format\")\n\n        use_internal_codes = bool_to_str_true_false(self.use_internal_codes)\n        if use_internal_codes is None:\n            error_message = \"Expected value for use_internal_codes\"\n            raise ValueError(error_message)\n        format_element.attrib[\"useInternalCodes\"] = use_internal_codes\n\n        use_ids = bool_to_str_true_false(self.use_ids)\n        if use_ids is not None:\n            format_element.attrib[\"useIds\"] = use_ids\n\n        incudle_unmapped_items = bool_to_str_true_false(self.include_unmapped_items)\n        if incudle_unmapped_items is not None:\n            format_element.attrib[\"includeUnmappedItems\"] = incudle_unmapped_items\n\n        include_codes = bool_to_str_true_false(self.include_codes)\n        if include_codes is not None:\n            format_element.attrib[\"includeCodes\"] = include_codes\n\n        include_names = bool_to_str_true_false(self.include_names)\n        if include_names is not None:\n            format_element.attrib[\"includeNames\"] = include_names\n\n        include_display_names = bool_to_str_true_false(self.include_display_names)\n        if include_display_names is not None:\n            format_element.attrib[\"includeDisplayNames\"] = include_display_names\n\n        display_name_enabled = bool_to_str_true_false(self.display_name_enabled)\n        if display_name_enabled is not None:\n            format_element.attrib[\"displayNameEnabled\"] = display_name_enabled\n\n        return format_element\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.ExportDataFormat.to_xml_element","title":"<code>to_xml_element()</code>","text":"<p>Convert Export Data Format to XML Element.</p> <p>Returns:</p> Type Description <code>Element</code> <p>XML Element</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Unexpected value</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def to_xml_element(self) -&gt; ET.Element:\n    \"\"\"Convert Export Data Format to XML Element.\n\n    Returns:\n        XML Element\n\n    Raises:\n        ValueError: Unexpected value\n\n    \"\"\"\n    format_element = ET.Element(\"format\")\n\n    use_internal_codes = bool_to_str_true_false(self.use_internal_codes)\n    if use_internal_codes is None:\n        error_message = \"Expected value for use_internal_codes\"\n        raise ValueError(error_message)\n    format_element.attrib[\"useInternalCodes\"] = use_internal_codes\n\n    use_ids = bool_to_str_true_false(self.use_ids)\n    if use_ids is not None:\n        format_element.attrib[\"useIds\"] = use_ids\n\n    incudle_unmapped_items = bool_to_str_true_false(self.include_unmapped_items)\n    if incudle_unmapped_items is not None:\n        format_element.attrib[\"includeUnmappedItems\"] = incudle_unmapped_items\n\n    include_codes = bool_to_str_true_false(self.include_codes)\n    if include_codes is not None:\n        format_element.attrib[\"includeCodes\"] = include_codes\n\n    include_names = bool_to_str_true_false(self.include_names)\n    if include_names is not None:\n        format_element.attrib[\"includeNames\"] = include_names\n\n    include_display_names = bool_to_str_true_false(self.include_display_names)\n    if include_display_names is not None:\n        format_element.attrib[\"includeDisplayNames\"] = include_display_names\n\n    display_name_enabled = bool_to_str_true_false(self.display_name_enabled)\n    if display_name_enabled is not None:\n        format_element.attrib[\"displayNameEnabled\"] = display_name_enabled\n\n    return format_element\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.ExportDataRules","title":"<code>ExportDataRules</code>  <code>dataclass</code>","text":"<p>Adaptive Export Data Rules.</p> <p>Attributes:</p> Name Type Description <code>include_zero_rows</code> <code>bool | None</code> <p>Adaptive Include Zero Rows</p> <code>include_rollup_accounts</code> <code>bool | None</code> <p>Adaptive Include Rollup Accounts</p> <code>include_rollup_levels</code> <code>bool | None</code> <p>ADaptive Include Rollup Levels</p> <code>mark_invalid_values</code> <code>bool | None</code> <p>Adaptive Mark Invalid Values</p> <code>mark_blanks</code> <code>bool | None</code> <p>Adaptive Mark Blanks</p> <code>time_rollups</code> <code>bool | None</code> <p>Adaptive Time Rollups</p> <code>currency</code> <code>CurrencyFilter | None</code> <p>Adaptive Currency</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>@dataclass\nclass ExportDataRules:\n    \"\"\"Adaptive Export Data Rules.\n\n    Attributes:\n        include_zero_rows: Adaptive Include Zero Rows\n        include_rollup_accounts: Adaptive Include Rollup Accounts\n        include_rollup_levels: ADaptive Include Rollup Levels\n        mark_invalid_values: Adaptive Mark Invalid Values\n        mark_blanks: Adaptive Mark Blanks\n        time_rollups: Adaptive Time Rollups\n        currency: Adaptive Currency\n\n    \"\"\"\n\n    include_zero_rows: bool | None = field(\n        metadata={\"validator\": is_none_or_is_bool},\n    )\n    # include_rollups: Optional[bool] = field(metadata={\"validator\":is_none_or_is_bool})\n    include_rollup_accounts: bool | None = field(\n        metadata={\"validator\": is_none_or_is_bool},\n    )\n    include_rollup_levels: bool | None = field(\n        metadata={\"validator\": is_none_or_is_bool},\n    )\n    mark_invalid_values: bool | None = field(\n        metadata={\"validator\": is_none_or_is_bool},\n    )\n    mark_blanks: bool | None = field(metadata={\"validator\": is_none_or_is_bool})\n    time_rollups: bool | None = field(metadata={\"validator\": is_none_or_is_bool})\n    currency: CurrencyFilter | None = field(default=None)\n\n    def to_xml_element(self) -&gt; ET.Element:\n        \"\"\"Convert ExportDataRules to XML Element.\n\n        Returns:\n            XML Element\n\n        \"\"\"\n        rules_element = ET.Element(\"rules\")\n\n        include_zero_rows = bool_to_str_true_false(self.include_zero_rows)\n        if include_zero_rows is not None:\n            rules_element.attrib[\"includeZeroRows\"] = include_zero_rows\n\n        include_rollup_accounts = bool_to_str_true_false(self.include_rollup_accounts)\n        if include_rollup_accounts is not None:\n            rules_element.attrib[\"includeRollupAccounts\"] = include_rollup_accounts\n\n        include_rollup_levels = bool_to_str_true_false(self.include_rollup_levels)\n        if include_rollup_levels is not None:\n            rules_element.attrib[\"includeRollupLevels\"] = include_rollup_levels\n\n        mark_invalid_values = bool_to_str_true_false(self.mark_invalid_values)\n        if mark_invalid_values is not None:\n            rules_element.attrib[\"markInvalidValues\"] = mark_invalid_values\n\n        mark_blanks = bool_to_str_true_false(self.mark_blanks)\n        if mark_blanks is not None:\n            rules_element.attrib[\"markBlanks\"] = mark_blanks\n\n        time_rollups = bool_to_str_true_false(self.time_rollups)\n        if time_rollups is not None:\n            rules_element.attrib[\"timeRollups\"] = time_rollups\n\n        if self.currency is not None:\n            rules_element.append(self.currency.to_xml_element())\n\n        return rules_element\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.ExportDataRules.to_xml_element","title":"<code>to_xml_element()</code>","text":"<p>Convert ExportDataRules to XML Element.</p> <p>Returns:</p> Type Description <code>Element</code> <p>XML Element</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def to_xml_element(self) -&gt; ET.Element:\n    \"\"\"Convert ExportDataRules to XML Element.\n\n    Returns:\n        XML Element\n\n    \"\"\"\n    rules_element = ET.Element(\"rules\")\n\n    include_zero_rows = bool_to_str_true_false(self.include_zero_rows)\n    if include_zero_rows is not None:\n        rules_element.attrib[\"includeZeroRows\"] = include_zero_rows\n\n    include_rollup_accounts = bool_to_str_true_false(self.include_rollup_accounts)\n    if include_rollup_accounts is not None:\n        rules_element.attrib[\"includeRollupAccounts\"] = include_rollup_accounts\n\n    include_rollup_levels = bool_to_str_true_false(self.include_rollup_levels)\n    if include_rollup_levels is not None:\n        rules_element.attrib[\"includeRollupLevels\"] = include_rollup_levels\n\n    mark_invalid_values = bool_to_str_true_false(self.mark_invalid_values)\n    if mark_invalid_values is not None:\n        rules_element.attrib[\"markInvalidValues\"] = mark_invalid_values\n\n    mark_blanks = bool_to_str_true_false(self.mark_blanks)\n    if mark_blanks is not None:\n        rules_element.attrib[\"markBlanks\"] = mark_blanks\n\n    time_rollups = bool_to_str_true_false(self.time_rollups)\n    if time_rollups is not None:\n        rules_element.attrib[\"timeRollups\"] = time_rollups\n\n    if self.currency is not None:\n        rules_element.append(self.currency.to_xml_element())\n\n    return rules_element\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.LevelFilter","title":"<code>LevelFilter</code>  <code>dataclass</code>","text":"<p>Adaptive Level Filter.</p> <p>Attributes:</p> Name Type Description <code>level</code> <code>Level | Sequence[Level]</code> <p>Adaptive Level</p> <code>is_rollup</code> <code>bool</code> <p>Adaptive Is Rollup</p> <code>include_descendants</code> <code>bool</code> <p>Adaptive Include Descendants</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>@dataclass\nclass LevelFilter:\n    \"\"\"Adaptive Level Filter.\n\n    Attributes:\n        level: Adaptive Level\n        is_rollup: Adaptive Is Rollup\n        include_descendants: Adaptive Include Descendants\n\n    \"\"\"\n\n    level: Level | Sequence[Level] = field(metadata={\"validator\": has_code_and_name})\n    is_rollup: bool = field(default=False, metadata={\"validator\": is_bool})\n    include_descendants: bool = field(default=False, metadata={\"validator\": is_bool})\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.TimeFilter","title":"<code>TimeFilter</code>  <code>dataclass</code>","text":"<p>Adaptive Time Filter.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>Period</code> <p>Adaptive Start</p> <code>end</code> <code>Period</code> <p>Adaptive End</p> <code>stratum</code> <code>Stratum | None</code> <p>Adaptive Stratum</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>@dataclass\nclass TimeFilter:\n    \"\"\"Adaptive Time Filter.\n\n    Attributes:\n        start: Adaptive Start\n        end: Adaptive End\n        stratum: Adaptive Stratum\n\n    \"\"\"\n\n    start: Period = field(metadata={\"validator\": has_code})\n    end: Period = field(metadata={\"validator\": has_code})\n    stratum: Stratum | None = field(\n        default=None,\n        metadata={\"validator\": is_none_or_has_code},\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.has_code","title":"<code>has_code(value)</code>","text":"<p>Validate that a value has a code.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T | Sequence[T]</code> <p>Value to validate has a code</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>Missing key</p> <code>ValueError</code> <p>Unexpected value</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def has_code(value: T | Sequence[T]) -&gt; None:\n    \"\"\"Validate that a value has a code.\n\n    Args:\n        value: Value to validate has a code\n\n    Raises:\n        KeyError: Missing key\n        ValueError: Unexpected value\n\n    \"\"\"\n    if isinstance(value, Sequence):\n        for item in value:\n            has_code(item)\n    if not hasattr(value, \"code\"):\n        error_message = \"Filter value missing code\"\n        raise KeyError(error_message)\n    code = getattr(value, \"code\", None)\n    if code in [None, \"\"]:\n        error_message = \"Filter value must have a code\"\n        raise ValueError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.has_code_and_name","title":"<code>has_code_and_name(value)</code>","text":"<p>Validate that a value has a code and a name.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T | Sequence[T]</code> <p>Value to validate has a code and a name</p> required Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def has_code_and_name(value: T | Sequence[T]) -&gt; None:\n    \"\"\"Validate that a value has a code and a name.\n\n    Args:\n        value: Value to validate has a code and a name\n\n    \"\"\"\n    has_code(value)\n    has_name(value)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.has_name","title":"<code>has_name(value)</code>","text":"<p>Validate that a value has a name.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T | Sequence[T]</code> <p>Value to validate has a name</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>Missing key</p> <code>ValueError</code> <p>Unexpected value</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def has_name(value: T | Sequence[T]) -&gt; None:\n    \"\"\"Validate that a value has a name.\n\n    Args:\n        value: Value to validate has a name\n\n    Raises:\n        KeyError: Missing key\n        ValueError: Unexpected value\n\n    \"\"\"\n    if isinstance(value, Sequence):\n        for item in value:\n            has_code(item)\n    if not hasattr(value, \"name\"):\n        error_message = \"Filter value missing code\"\n        raise KeyError(error_message)\n    code = getattr(value, \"code\", None)\n    if code in [None, \"\"]:\n        error_message = \"Filter value must have a code\"\n        raise ValueError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.is_bool","title":"<code>is_bool(value)</code>","text":"<p>Validate that a value is boolean.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T | Sequence[T]</code> <p>Value to validate is boolean</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>Unexpected type</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def is_bool(value: T | Sequence[T]) -&gt; None:\n    \"\"\"Validate that a value is boolean.\n\n    Args:\n        value: Value to validate is boolean\n\n    Raises:\n        TypeError: Unexpected type\n\n    \"\"\"\n    if isinstance(value, Sequence):\n        for item in value:\n            is_bool(item)\n    if not isinstance(value, bool):\n        error_message = \"Filter value must be a bool\"\n        raise TypeError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.is_none_or_has_code","title":"<code>is_none_or_has_code(value)</code>","text":"<p>Validate that a value is None or has a code.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T | Sequence[T]</code> <p>Value to check if None or has a code</p> required Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def is_none_or_has_code(value: T | Sequence[T]) -&gt; None:\n    \"\"\"Validate that a value is None or has a code.\n\n    Args:\n        value: Value to check if None or has a code\n\n    \"\"\"\n    if value is None:\n        return\n    has_code(value)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.is_none_or_has_code_and_name","title":"<code>is_none_or_has_code_and_name(value)</code>","text":"<p>Validate that a value is None or has a name and a code.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T | Sequence[T]</code> <p>Value to validate isnone or has a name or a code</p> required Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def is_none_or_has_code_and_name(value: T | Sequence[T]) -&gt; None:\n    \"\"\"Validate that a value is None or has a name and a code.\n\n    Args:\n        value: Value to validate isnone or has a name or a code\n\n    \"\"\"\n    if value is None:\n        return\n    has_code_and_name(value)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.is_none_or_has_name","title":"<code>is_none_or_has_name(value)</code>","text":"<p>Validate that a value is None or has a name.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T | Sequence[T]</code> <p>Value to check if None or has a name</p> required Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def is_none_or_has_name(value: T | Sequence[T]) -&gt; None:\n    \"\"\"Validate that a value is None or has a name.\n\n    Args:\n        value: Value to check if None or has a name\n\n    \"\"\"\n    if value is None:\n        return\n    has_name(value)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.is_none_or_is_bool","title":"<code>is_none_or_is_bool(value)</code>","text":"<p>Validate that a value is None or a boolean.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T | Sequence[T]</code> <p>Value to validate is None or a boolean</p> required Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def is_none_or_is_bool(value: T | Sequence[T]) -&gt; None:\n    \"\"\"Validate that a value is None or a boolean.\n\n    Args:\n        value: Value to validate is None or a boolean\n\n    \"\"\"\n    if value is None:\n        return\n    is_bool(value)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.is_none_or_is_string","title":"<code>is_none_or_is_string(value)</code>","text":"<p>Validate that a value is None or a string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T | Sequence[T]</code> <p>Value to validate is None or a string</p> required Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def is_none_or_is_string(value: T | Sequence[T]) -&gt; None:\n    \"\"\"Validate that a value is None or a string.\n\n    Args:\n        value: Value to validate is None or a string\n\n    \"\"\"\n    if value is None:\n        return\n    is_string(value)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/data/#wdadaptivepy.models.data.is_string","title":"<code>is_string(value)</code>","text":"<p>Validate that a value is a string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T | Sequence[T]</code> <p>Value to validate is a string</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>Unexpected type</p> Source code in <code>src/wdadaptivepy/models/data.py</code> <pre><code>def is_string(value: T | Sequence[T]) -&gt; None:\n    \"\"\"Validate that a value is a string.\n\n    Args:\n        value: Value to validate is a string\n\n    Raises:\n        TypeError: Unexpected type\n\n    \"\"\"\n    if isinstance(value, Sequence):\n        for item in value:\n            is_string(item)\n    if not isinstance(value, str):\n        error_message = \"Filter value must be a string\"\n        raise TypeError(error_message)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/dimension/","title":"dimension","text":"<p>wdadaptivepy model for Adaptive's Dimensions.</p>"},{"location":"reference/wdadaptivepy/models/dimension/#wdadaptivepy.models.dimension.Dimension","title":"<code>Dimension</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Dimensions.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Dimension ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Dimension Name</p> <code>code</code> <code>str | None</code> <p>Adaptive Dimension Code</p> <code>display_name_type</code> <code>str | None</code> <p>ADaptive Dimension Display Name Type</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Dimension Short Name</p> <code>auto_create</code> <code>bool | None</code> <p>Adaptive Dimension Auto Create</p> <code>list_dimension</code> <code>bool | None</code> <p>Adaptive Dimension List Dimension</p> <code>keep_sorted</code> <code>bool | None</code> <p>Adaptive Dimension Keep Sorted</p> <code>use_on_levels</code> <code>bool | None</code> <p>Adaptive Dimension Use On Levels</p> <code>seq_no</code> <code>str | None</code> <p>Adaptive Dimension Sequence Number</p> <code>description</code> <code>str | None</code> <p>Adaptive Dimension Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/dimension.py</code> <pre><code>@dataclass(eq=False)\nclass Dimension(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Dimensions.\n\n    Attributes:\n        id: Adaptive Dimension ID\n        name: Adaptive Dimension Name\n        code: Adaptive Dimension Code\n        display_name_type: ADaptive Dimension Display Name Type\n        short_name: Adaptive Dimension Short Name\n        auto_create: Adaptive Dimension Auto Create\n        list_dimension: Adaptive Dimension List Dimension\n        keep_sorted: Adaptive Dimension Keep Sorted\n        use_on_levels: Adaptive Dimension Use On Levels\n        seq_no: Adaptive Dimension Sequence Number\n        description: Adaptive Dimension Description\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    display_name_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayNameType\",\n            \"xml_read\": \"displayNameType\",\n            \"xml_update\": \"displayNameType\",\n            \"xml_delete\": \"displayNameType\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    auto_create: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"autoCreate\",\n            \"xml_read\": \"autoCreate\",\n            \"xml_update\": \"autoCreate\",\n            \"xml_delete\": \"autoCreate\",\n        },\n    )\n    list_dimension: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"listDimension\",\n            \"xml_read\": \"listDimension\",\n            \"xml_update\": \"listDimension\",\n            \"xml_delete\": \"listDimension\",\n        },\n    )\n    keep_sorted: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"keepSorted\",\n            \"xml_read\": \"keepSorted\",\n            \"xml_update\": \"keepSorted\",\n            \"xml_delete\": \"keepSorted\",\n        },\n    )\n    use_on_levels: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"useOnLevels\",\n            \"xml_read\": \"useOnLevels\",\n            \"xml_update\": \"useOnLevels\",\n            \"xml_delete\": \"useOnLevels\",\n        },\n    )\n    seq_no: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"seqNo\",\n            \"xml_read\": \"seqNo\",\n            \"xml_update\": \"seqNo\",\n            \"xml_delete\": \"seqNo\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"dimensions\",\n        \"xml_create_tag\": \"dimension\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"dimensions\",\n        \"xml_read_tag\": \"dimension\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"dimensions\",\n        \"xml_update_tag\": \"dimension\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"dimensions\",\n        \"xml_delete_tag\": \"dimension\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/dimension_value/","title":"dimension_value","text":"<p>wdadaptivepy model for Adaptive's Dimension Values.</p>"},{"location":"reference/wdadaptivepy/models/dimension_value/#wdadaptivepy.models.dimension_value.DimensionValue","title":"<code>DimensionValue</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierarchialAttributedMetadata</code></p> <p>wdadaptivepy model for Adaptive's Dimension Values.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Dimension Value ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Dimension Value Code</p> <code>name</code> <code>str | None</code> <p>Adaptive Dimension Value Name</p> <code>display_name</code> <code>str | None</code> <p>Adaptive Dimension Value Display Name</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Dimension Value Short Name</p> <code>description</code> <code>str | None</code> <p>Adaptive Dimension Value Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/dimension_value.py</code> <pre><code>@dataclass(eq=False)\nclass DimensionValue(HierarchialAttributedMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Dimension Values.\n\n    Attributes:\n        id: Adaptive Dimension Value ID\n        code: Adaptive Dimension Value Code\n        name: Adaptive Dimension Value Name\n        display_name: Adaptive Dimension Value Display Name\n        short_name: Adaptive Dimension Value Short Name\n        description: Adaptive Dimension Value Description\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    display_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayName\",\n            \"xml_read\": \"displayName\",\n            \"xml_update\": \"displayName\",\n            \"xml_delete\": \"displayName\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"dimension\",\n        \"xml_create_tag\": \"dimensionValue\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"dimension\",\n        \"xml_read_tag\": \"dimensionValue\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"dimension\",\n        \"xml_update_tag\": \"dimensionValue\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"dimension\",\n        \"xml_delete_tag\": \"dimensionValue\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/exceptions/","title":"exceptions","text":"<p>wdadaptivepy model exceptions.</p>"},{"location":"reference/wdadaptivepy/models/exceptions/#wdadaptivepy.models.exceptions.InvalidBooleanValueError","title":"<code>InvalidBooleanValueError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for Invalid Boolean Values.</p> Source code in <code>src/wdadaptivepy/models/exceptions.py</code> <pre><code>class InvalidBooleanValueError(Exception):\n    \"\"\"Exception for Invalid Boolean Values.\"\"\"\n</code></pre>"},{"location":"reference/wdadaptivepy/models/group/","title":"group","text":"<p>wdadaptivepy model for Adaptive's Groups.</p>"},{"location":"reference/wdadaptivepy/models/group/#wdadaptivepy.models.group.Group","title":"<code>Group</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Groups.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Group ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Group Name</p> <code>is_global</code> <code>bool | None</code> <p>Adaptive Group Is Global</p> <code>owner_id</code> <code>str | None</code> <p>Adaptive Group Owner ID</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/group.py</code> <pre><code>@dataclass(eq=False)\nclass Group(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Groups.\n\n    Attributes:\n        id: Adaptive Group ID\n        name: Adaptive Group Name\n        is_global: Adaptive Group Is Global\n        owner_id: Adaptive Group Owner ID\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    is_global: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isGlobal\",\n            \"xml_read\": \"isGlobal\",\n            \"xml_update\": \"isGlobal\",\n            \"xml_delete\": \"isGlobal\",\n        },\n    )\n    owner_id: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"ownerId\",\n            \"xml_read\": \"ownerId\",\n            \"xml_update\": \"ownerId\",\n            \"xml_delete\": \"ownerId\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"groups\",\n        \"xml_create_tag\": \"group\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"groups\",\n        \"xml_read_tag\": \"group\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"groups\",\n        \"xml_update_tag\": \"group\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"groups\",\n        \"xml_delete_tag\": \"group\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/level/","title":"level","text":"<p>wdadaptivepy model for Adaptive's Levels.</p>"},{"location":"reference/wdadaptivepy/models/level/#wdadaptivepy.models.level.Level","title":"<code>Level</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierarchialAttributedMetadata</code></p> <p>wdadaptivepy model for Adaptive's Levels.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Level ID</p> <code>code</code> <code>str | None</code> <p>Adaptive Level Code</p> <code>name</code> <code>str | None</code> <p>Adaptive Level Name</p> <code>display_name</code> <code>str | None</code> <p>Adaptive Level Display Name</p> <code>currency</code> <code>str | None</code> <p>Adaptive Level Currency</p> <code>publish_currency</code> <code>str | None</code> <p>Adaptive Level Publish Currency</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Level Short Name</p> <code>available_start</code> <code>str | None</code> <p>Adaptive Level Available Start</p> <code>available_end</code> <code>str | None</code> <p>Adaptive Level Available End</p> <code>is_importable</code> <code>bool | None</code> <p>Adaptive Level Is Importable</p> <code>workflow_status</code> <code>str | None</code> <p>Adaptive Level Workfalow Status</p> <code>is_elimination</code> <code>bool | None</code> <p>Adaptive Level Is Elimination</p> <code>is_linked</code> <code>bool | None</code> <p>Adaptive Level Is Linked</p> <code>has_children</code> <code>bool | None</code> <p>Adaptive Level Has Children</p> <code>description</code> <code>str | None</code> <p>Adaptive Level Description</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/level.py</code> <pre><code>@dataclass(eq=False)\nclass Level(HierarchialAttributedMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Levels.\n\n    Attributes:\n        id: Adaptive Level ID\n        code: Adaptive Level Code\n        name: Adaptive Level Name\n        display_name: Adaptive Level Display Name\n        currency: Adaptive Level Currency\n        publish_currency: Adaptive Level Publish Currency\n        short_name: Adaptive Level Short Name\n        available_start: Adaptive Level Available Start\n        available_end: Adaptive Level Available End\n        is_importable: Adaptive Level Is Importable\n        workflow_status: Adaptive Level Workfalow Status\n        is_elimination: Adaptive Level Is Elimination\n        is_linked: Adaptive Level Is Linked\n        has_children: Adaptive Level Has Children\n        description: Adaptive Level Description\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    display_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"displayName\",\n            \"xml_read\": \"displayName\",\n            \"xml_update\": \"displayName\",\n            \"xml_delete\": \"displayName\",\n        },\n    )\n    currency: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"currency\",\n            \"xml_read\": \"currency\",\n            \"xml_update\": \"currency\",\n            \"xml_delete\": \"currency\",\n        },\n    )\n    publish_currency: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"publishCurrency\",\n            \"xml_read\": \"publishCurrency\",\n            \"xml_update\": \"publishCurrency\",\n            \"xml_delete\": \"publishCurrency\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    available_start: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"availableStart\",\n            \"xml_read\": \"availableStart\",\n            \"xml_update\": \"availableStart\",\n            \"xml_delete\": \"availableStart\",\n        },\n    )\n    available_end: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"availableEnd\",\n            \"xml_read\": \"availableEnd\",\n            \"xml_update\": \"availableEnd\",\n            \"xml_delete\": \"availableEnd\",\n        },\n    )\n    is_importable: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isImportable\",\n            \"xml_read\": \"isImportable\",\n            \"xml_update\": \"isImportable\",\n            \"xml_delete\": \"isImportable\",\n        },\n    )\n    workflow_status: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"workflowStatus\",\n            \"xml_read\": \"workflowStatus\",\n            \"xml_update\": \"workflowStatus\",\n            \"xml_delete\": \"workflowStatus\",\n        },\n    )\n    is_elimination: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isElimination\",\n            \"xml_read\": \"isElimination\",\n            \"xml_update\": \"isElimination\",\n            \"xml_delete\": \"isElimination\",\n        },\n    )\n    is_linked: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isLinked\",\n            \"xml_read\": \"isLinked\",\n            \"xml_update\": \"isLinked\",\n            \"xml_delete\": \"isLinked\",\n        },\n    )\n    has_children: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"hasChildren\",\n            \"xml_read\": \"hasChildren\",\n            \"xml_update\": \"hasChildren\",\n            \"xml_delete\": \"hasChildren\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"levels\",\n        \"xml_create_tag\": \"level\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"levels\",\n        \"xml_read_tag\": \"level\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"levels\",\n        \"xml_update_tag\": \"level\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"levels\",\n        \"xml_delete_tag\": \"level\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/list/","title":"list","text":"<p>wdadaptivepy model for list of Adaptive metadata.</p>"},{"location":"reference/wdadaptivepy/models/list/#wdadaptivepy.models.list.IsDataclass","title":"<code>IsDataclass</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Class to typehint for Data Class properties.</p> <p>Attributes:</p> Name Type Description <code>__dataclass_fields__</code> <code>dict[str, Any]</code> <p>Dataclass fields</p> Source code in <code>src/wdadaptivepy/models/list.py</code> <pre><code>class IsDataclass(Protocol):\n    \"\"\"Class to typehint for Data Class properties.\n\n    Attributes:\n        __dataclass_fields__: Dataclass fields\n\n    \"\"\"\n\n    __dataclass_fields__: ClassVar[dict[str, Any]]\n</code></pre>"},{"location":"reference/wdadaptivepy/models/list/#wdadaptivepy.models.list.MetadataList","title":"<code>MetadataList</code>","text":"<p>               Bases: <code>list[T]</code></p> <p>wdadaptivepy model for list of Adaptive metadata.</p> Source code in <code>src/wdadaptivepy/models/list.py</code> <pre><code>class MetadataList(list[T]):\n    \"\"\"wdadaptivepy model for list of Adaptive metadata.\"\"\"\n\n    def to_csv(self, file_path_and_name: str | PathLike) -&gt; None:\n        \"\"\"Convert MetadataList to CSV.\n\n        Args:\n            file_path_and_name: Full path of CSV\n\n        \"\"\"\n        if len(self) != 0:\n            headers = list(asdict(self[0]).keys())\n            if hasattr(self[0], \"adaptive_parent\"):\n                headers.extend([\"parent id\", \"parent code\", \"parent name\"])\n\n            attribute_titles: list[str] = []\n            all_data: list[dict[str, str | int | bool | None | datetime]] = []\n            for item in self:\n                data = asdict(item)\n                adaptive_parent = getattr(item, \"adaptive_parent\", None)\n                if adaptive_parent is not None:\n                    data = data | {\n                        \"parent id\": adaptive_parent.id,\n                        \"parent code\": adaptive_parent.code,\n                        \"parent name\": adaptive_parent.name,\n                    }\n\n                adaptive_attributes = getattr(item, \"adaptive_attributes\", None)\n                if adaptive_attributes is not None:\n                    for attribute in adaptive_attributes:\n                        if attribute.name + \" id (attribute)\" not in attribute_titles:\n                            attribute_titles.append(\n                                attribute.name + \" id (attribute)\",\n                            )\n                            attribute_titles.append(\n                                attribute.name + \" name (attribute)\",\n                            )\n                        data = data | {\n                            attribute.name + \" id (attribute)\": attribute.value_id,\n                            attribute.name + \" name (attribute)\": attribute.value,\n                        }\n                all_data.append(data)\n\n            headers += attribute_titles\n\n            with Path(file_path_and_name).open(\"w\") as csvfile:\n                csv_writer = csv.DictWriter(csvfile, fieldnames=headers)\n                csv_writer.writeheader()\n                csv_writer.writerows(all_data)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/list/#wdadaptivepy.models.list.MetadataList.to_csv","title":"<code>to_csv(file_path_and_name)</code>","text":"<p>Convert MetadataList to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>file_path_and_name</code> <code>str | PathLike</code> <p>Full path of CSV</p> required Source code in <code>src/wdadaptivepy/models/list.py</code> <pre><code>def to_csv(self, file_path_and_name: str | PathLike) -&gt; None:\n    \"\"\"Convert MetadataList to CSV.\n\n    Args:\n        file_path_and_name: Full path of CSV\n\n    \"\"\"\n    if len(self) != 0:\n        headers = list(asdict(self[0]).keys())\n        if hasattr(self[0], \"adaptive_parent\"):\n            headers.extend([\"parent id\", \"parent code\", \"parent name\"])\n\n        attribute_titles: list[str] = []\n        all_data: list[dict[str, str | int | bool | None | datetime]] = []\n        for item in self:\n            data = asdict(item)\n            adaptive_parent = getattr(item, \"adaptive_parent\", None)\n            if adaptive_parent is not None:\n                data = data | {\n                    \"parent id\": adaptive_parent.id,\n                    \"parent code\": adaptive_parent.code,\n                    \"parent name\": adaptive_parent.name,\n                }\n\n            adaptive_attributes = getattr(item, \"adaptive_attributes\", None)\n            if adaptive_attributes is not None:\n                for attribute in adaptive_attributes:\n                    if attribute.name + \" id (attribute)\" not in attribute_titles:\n                        attribute_titles.append(\n                            attribute.name + \" id (attribute)\",\n                        )\n                        attribute_titles.append(\n                            attribute.name + \" name (attribute)\",\n                        )\n                    data = data | {\n                        attribute.name + \" id (attribute)\": attribute.value_id,\n                        attribute.name + \" name (attribute)\": attribute.value,\n                    }\n            all_data.append(data)\n\n        headers += attribute_titles\n\n        with Path(file_path_and_name).open(\"w\") as csvfile:\n            csv_writer = csv.DictWriter(csvfile, fieldnames=headers)\n            csv_writer.writeheader()\n            csv_writer.writerows(all_data)\n</code></pre>"},{"location":"reference/wdadaptivepy/models/permission_set/","title":"permission_set","text":"<p>wdadaptivepy model for Adaptive's Permission Sets.</p>"},{"location":"reference/wdadaptivepy/models/permission_set/#wdadaptivepy.models.permission_set.PermissionSet","title":"<code>PermissionSet</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Permission Sets.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Permission Set ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Permission Set Name</p> <code>permissions</code> <code>str | None</code> <p>Adaptive Permission Set Permissions</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/permission_set.py</code> <pre><code>@dataclass(eq=False)\nclass PermissionSet(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Permission Sets.\n\n    Attributes:\n        id: Adaptive Permission Set ID\n        name: Adaptive Permission Set Name\n        permissions: Adaptive Permission Set Permissions\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    permissions: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"permissions\",\n            \"xml_read\": \"permissions\",\n            \"xml_update\": \"permissions\",\n            \"xml_delete\": \"permissions\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"permission_sets\",\n        \"xml_create_tag\": \"permission_set\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"permission_sets\",\n        \"xml_read_tag\": \"permission_set\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"permission_sets\",\n        \"xml_update_tag\": \"permission_set\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"permission_sets\",\n        \"xml_delete_tag\": \"permission_set\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/time/","title":"time","text":"<p>wdadaptivepy model for Adaptive's Time.</p>"},{"location":"reference/wdadaptivepy/models/time/#wdadaptivepy.models.time.Period","title":"<code>Period</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierchialMetadata</code></p> <p>wdadaptivepy model for Adaptive's Periods.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>Adaptive Period Code</p> <code>label</code> <code>str | None</code> <p>Adaptive Period Label</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Period Short Name</p> <code>stratum_id</code> <code>int | None</code> <p>Adaptive Period Stratum ID</p> <code>id</code> <code>int | None</code> <p>Adaptive Period ID</p> <code>start</code> <code>str | None</code> <p>Adaptive Period Start</p> <code>end</code> <code>str | None</code> <p>Adaptive Period End</p> <code>legacy_report_time_id</code> <code>int | None</code> <p>Adaptive Period Legacy Report Time ID</p> <code>legacy_sheet_time_id</code> <code>int | None</code> <p>Adaptive Period Legacy Sheet Time ID</p> <code>locales</code> <code>MetadataList[TimeLocale]</code> <p>Adaptive Period Locales</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/time.py</code> <pre><code>@dataclass(eq=False)\nclass Period(HierchialMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Periods.\n\n    Attributes:\n        code: Adaptive Period Code\n        label: Adaptive Period Label\n        short_name: Adaptive Period Short Name\n        stratum_id: Adaptive Period Stratum ID\n        id: Adaptive Period ID\n        start: Adaptive Period Start\n        end: Adaptive Period End\n        legacy_report_time_id: Adaptive Period Legacy Report Time ID\n        legacy_sheet_time_id: Adaptive Period Legacy Sheet Time ID\n        locales: Adaptive Period Locales\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    label: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"label\",\n            \"xml_read\": \"label\",\n            \"xml_update\": \"label\",\n            \"xml_delete\": \"label\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    stratum_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"stratumId\",\n            \"xml_read\": \"stratumId\",\n            \"xml_update\": \"stratumId\",\n            \"xml_delete\": \"stratumId\",\n        },\n    )\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    start: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"start\",\n            \"xml_read\": \"start\",\n            \"xml_update\": \"start\",\n            \"xml_delete\": \"start\",\n        },\n    )\n    end: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"end\",\n            \"xml_read\": \"end\",\n            \"xml_update\": \"end\",\n            \"xml_delete\": \"end\",\n        },\n    )\n    legacy_report_time_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"legacyReportTimeId\",\n            \"xml_read\": \"legacyReportTimeId\",\n            \"xml_update\": \"legacyReportTimeId\",\n            \"xml_delete\": \"legacyReportTimeId\",\n        },\n    )\n    legacy_sheet_time_id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"legacySheetTimeId\",\n            \"xml_read\": \"legacySheetTimeId\",\n            \"xml_update\": \"legacySheetTimeId\",\n            \"xml_delete\": \"legacySheetTimeId\",\n        },\n    )\n    locales: MetadataList[TimeLocale] = field(\n        default_factory=MetadataList[TimeLocale],\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"locales\",\n            \"xml_read\": \"locales\",\n            \"xml_update\": \"locales\",\n            \"xml_delete\": \"locales\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"periods\",\n        \"xml_create_tag\": \"period\",\n        \"xml_create_children\": {\"locales\": TimeLocale},\n        \"xml_read_parent_tag\": \"time\",\n        \"xml_read_tag\": \"period\",\n        \"xml_read_children\": {\"locales\": TimeLocale},\n        \"xml_update_parent_tag\": \"periods\",\n        \"xml_update_tag\": \"period\",\n        \"xml_update_children\": {\"locales\": TimeLocale},\n        \"xml_delete_parent_tag\": \"periods\",\n        \"xml_delete_tag\": \"period\",\n        \"xml_delete_children\": {\"locales\": TimeLocale},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/time/#wdadaptivepy.models.time.Stratum","title":"<code>Stratum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierchialMetadata</code></p> <p>wdadaptivepy model for Adaptive's Stratum.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>Adaptive Stratum Code</p> <code>label</code> <code>str | None</code> <p>Adaptive Stratum Label</p> <code>short_name</code> <code>str | None</code> <p>ADaptive Stratum Short Name</p> <code>id</code> <code>int | None</code> <p>Adaptive Stratum ID</p> <code>in_use</code> <code>bool | None</code> <p>Adaptive Stratum In Use</p> <code>is_default</code> <code>bool | None</code> <p>Adaptive Stratum Is Default</p> <code>locales</code> <code>MetadataList[TimeLocale]</code> <p>Adaptive Stratum Locales</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/time.py</code> <pre><code>@dataclass(eq=False)\nclass Stratum(HierchialMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Stratum.\n\n    Attributes:\n        code: Adaptive Stratum Code\n        label: Adaptive Stratum Label\n        short_name: ADaptive Stratum Short Name\n        id: Adaptive Stratum ID\n        in_use: Adaptive Stratum In Use\n        is_default: Adaptive Stratum Is Default\n        locales: Adaptive Stratum Locales\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    code: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"code\",\n            \"xml_read\": \"code\",\n            \"xml_update\": \"code\",\n            \"xml_delete\": \"code\",\n        },\n    )\n    label: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"label\",\n            \"xml_read\": \"label\",\n            \"xml_update\": \"label\",\n            \"xml_delete\": \"label\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    in_use: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"inUse\",\n            \"xml_read\": \"inUse\",\n            \"xml_update\": \"inUse\",\n            \"xml_delete\": \"inUse\",\n        },\n    )\n    is_default: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isDefault\",\n            \"xml_read\": \"isDefault\",\n            \"xml_update\": \"isDefault\",\n            \"xml_delete\": \"isDefault\",\n        },\n    )\n    locales: MetadataList[TimeLocale] = field(\n        default_factory=MetadataList[TimeLocale],\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"locales\",\n            \"xml_read\": \"locales\",\n            \"xml_update\": \"locales\",\n            \"xml_delete\": \"locales\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"stratums\",\n        \"xml_create_tag\": \"stratum\",\n        \"xml_create_children\": {\"locales\": TimeLocale},\n        \"xml_read_parent_tag\": \"time\",\n        \"xml_read_tag\": \"stratum\",\n        \"xml_read_children\": {\"locales\": TimeLocale},\n        \"xml_update_parent_tag\": \"stratums\",\n        \"xml_update_tag\": \"stratum\",\n        \"xml_update_children\": {\"locales\": TimeLocale},\n        \"xml_delete_parent_tag\": \"stratums\",\n        \"xml_delete_tag\": \"stratum\",\n        \"xml_delete_children\": {\"locales\": TimeLocale},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/time/#wdadaptivepy.models.time.Time","title":"<code>Time</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Time.</p> <p>Attributes:</p> Name Type Description <code>is_custom</code> <code>bool | None</code> <p>Adaptive Time Is Custom</p> <code>q_first_month</code> <code>int | None</code> <p>Adaptive Time Quarter First Month</p> <code>last_month_is_fy</code> <code>bool | None</code> <p>Adaptive Time Last Month Is Fiscal Year</p> <code>seq_no</code> <code>str | None</code> <p>Adaptive Time Sequence Number</p> <code>stratum</code> <code>MetadataList[Stratum]</code> <p>Adaptive Time Stratum</p> <code>period</code> <code>MetadataList[Period]</code> <p>Adaptive Time Period</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/time.py</code> <pre><code>@dataclass(eq=False)\nclass Time(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Time.\n\n    Attributes:\n        is_custom: Adaptive Time Is Custom\n        q_first_month: Adaptive Time Quarter First Month\n        last_month_is_fy: Adaptive Time Last Month Is Fiscal Year\n        seq_no: Adaptive Time Sequence Number\n        stratum: Adaptive Time Stratum\n        period: Adaptive Time Period\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    is_custom: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isCustom\",\n            \"xml_read\": \"isCustom\",\n            \"xml_update\": \"isCustom\",\n            \"xml_delete\": \"isCustom\",\n        },\n    )\n    q_first_month: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"qFirstMonth\",\n            \"xml_read\": \"qFirstMonth\",\n            \"xml_update\": \"qFirstMonth\",\n            \"xml_delete\": \"qFirstMonth\",\n        },\n    )\n    last_month_is_fy: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"lastMonthIsFy\",\n            \"xml_read\": \"lastMonthIsFy\",\n            \"xml_update\": \"lastMonthIsFy\",\n            \"xml_delete\": \"lastMonthIsFy\",\n        },\n    )\n    seq_no: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"seqNo\",\n            \"xml_read\": \"seqNo\",\n            \"xml_update\": \"seqNo\",\n            \"xml_delete\": \"seqNo\",\n        },\n    )\n    stratum: MetadataList[Stratum] = field(\n        default_factory=MetadataList[Stratum],\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"stratum\",\n            \"xml_read\": \"stratum\",\n            \"xml_update\": \"stratum\",\n            \"xml_delete\": \"stratum\",\n        },\n    )\n    period: MetadataList[Period] = field(\n        default_factory=MetadataList[Period],\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"period\",\n            \"xml_read\": \"period\",\n            \"xml_update\": \"period\",\n            \"xml_delete\": \"period\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"times\",\n        \"xml_create_tag\": \"time\",\n        \"xml_create_children\": {\"stratum\": Stratum, \"period\": Period},\n        \"xml_read_parent_tag\": \"times\",\n        \"xml_read_tag\": \"time\",\n        \"xml_read_children\": {\"stratum\": Stratum, \"period\": Period},\n        \"xml_update_parent_tag\": \"times\",\n        \"xml_update_tag\": \"time\",\n        \"xml_update_children\": {\"stratum\": Stratum, \"period\": Period},\n        \"xml_delete_parent_tag\": \"times\",\n        \"xml_delete_tag\": \"time\",\n        \"xml_delete_children\": {\"stratum\": Stratum, \"period\": Period},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/time/#wdadaptivepy.models.time.TimeLocale","title":"<code>TimeLocale</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Time Locale.</p> <p>Attributes:</p> Name Type Description <code>locale</code> <code>str | None</code> <p>Adaptive Time Locale Name</p> <code>label</code> <code>str | None</code> <p>Adaptive Time Locale Label</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Time Locale Short Name</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/time.py</code> <pre><code>@dataclass(eq=False)\nclass TimeLocale(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Time Locale.\n\n    Attributes:\n        locale: Adaptive Time Locale Name\n        label: Adaptive Time Locale Label\n        short_name: Adaptive Time Locale Short Name\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    locale: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"locale\",\n            \"xml_read\": \"locale\",\n            \"xml_update\": \"locale\",\n            \"xml_delete\": \"locale\",\n        },\n    )\n    label: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"label\",\n            \"xml_read\": \"label\",\n            \"xml_update\": \"label\",\n            \"xml_delete\": \"label\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"locales\",\n        \"xml_create_tag\": \"locale\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"locales\",\n        \"xml_read_tag\": \"locale\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"locales\",\n        \"xml_update_tag\": \"locale\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"locales\",\n        \"xml_delete_tag\": \"locale\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/user/","title":"user","text":"<p>wdadaptivepy model for Adaptive's Users.</p>"},{"location":"reference/wdadaptivepy/models/user/#wdadaptivepy.models.user.Subscription","title":"<code>Subscription</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Subscriptions.</p> <p>Attributes:</p> Name Type Description <code>no_subscriptions</code> <code>bool | None</code> <p>Adaptive Subscription No Subscriptions</p> <code>sysem_alerts_and_updates</code> <code>bool | None</code> <p>Adaptive Subscription System Alerts and Updates</p> <code>customer_news_letter</code> <code>bool | None</code> <p>Adaptive Subscription Custom News Letter</p> <code>local_event</code> <code>bool | None</code> <p>Adaptive Subscription Local Event</p> <code>education_training</code> <code>bool | None</code> <p>Adaptive Subscription Education Training</p> <code>customer_webinars</code> <code>bool | None</code> <p>Adaptive Subscription Customer Webinars</p> <code>new_products_and_enhancements</code> <code>bool | None</code> <p>Adaptive Subscription New Products / Enhancements</p> <code>partner_news_letter</code> <code>bool | None</code> <p>Adaptive Subscription Partner News Letter</p> <code>partner_webinars</code> <code>bool | None</code> <p>Adaptive Subscription Partner Webinars</p> <code>user_groups</code> <code>bool | None</code> <p>Adaptive Subscription User Groups</p> <code>surveys</code> <code>bool | None</code> <p>Adaptive Subscription Surveys</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/user.py</code> <pre><code>@dataclass(eq=False)\nclass Subscription(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Subscriptions.\n\n    Attributes:\n        no_subscriptions: Adaptive Subscription No Subscriptions\n        sysem_alerts_and_updates: Adaptive Subscription System Alerts and Updates\n        customer_news_letter: Adaptive Subscription Custom News Letter\n        local_event: Adaptive Subscription Local Event\n        education_training: Adaptive Subscription Education Training\n        customer_webinars: Adaptive Subscription Customer Webinars\n        new_products_and_enhancements: Adaptive Subscription New Products / Enhancements\n        partner_news_letter: Adaptive Subscription Partner News Letter\n        partner_webinars: Adaptive Subscription Partner Webinars\n        user_groups: Adaptive Subscription User Groups\n        surveys: Adaptive Subscription Surveys\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    no_subscriptions: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"noSubscriptions\",\n            \"xml_read\": \"noSubscriptions\",\n            \"xml_update\": \"noSubscriptions\",\n            \"xml_delete\": \"noSubscriptions\",\n        },\n    )\n    sysem_alerts_and_updates: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"systemAlertsAndUpdates\",\n            \"xml_read\": \"systemAlertsAndUpdates\",\n            \"xml_update\": \"systemAlertsAndUpdates\",\n            \"xml_delete\": \"systemAlertsAndUpdates\",\n        },\n    )\n    customer_news_letter: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"customerNewsLetter\",\n            \"xml_read\": \"customerNewsLetter\",\n            \"xml_update\": \"customerNewsLetter\",\n            \"xml_delete\": \"customerNewsLetter\",\n        },\n    )\n    local_event: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"localEvent\",\n            \"xml_read\": \"localEvent\",\n            \"xml_update\": \"localEvent\",\n            \"xml_delete\": \"localEvent\",\n        },\n    )\n    education_training: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"educationTraining\",\n            \"xml_read\": \"educationTraining\",\n            \"xml_update\": \"educationTraining\",\n            \"xml_delete\": \"educationTraining\",\n        },\n    )\n    customer_webinars: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"customerWebinars\",\n            \"xml_read\": \"customerWebinars\",\n            \"xml_update\": \"customerWebinars\",\n            \"xml_delete\": \"customerWebinars\",\n        },\n    )\n    new_products_and_enhancements: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"newProductsAndEnhancements\",\n            \"xml_read\": \"newProductsAndEnhancements\",\n            \"xml_update\": \"newProductsAndEnhancements\",\n            \"xml_delete\": \"newProductsAndEnhancements\",\n        },\n    )\n    partner_news_letter: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"partnerNewsLetter\",\n            \"xml_read\": \"partnerNewsLetter\",\n            \"xml_update\": \"partnerNewsLetter\",\n            \"xml_delete\": \"partnerNewsLetter\",\n        },\n    )\n    partner_webinars: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"partnerWebinars\",\n            \"xml_read\": \"partnerWebinars\",\n            \"xml_update\": \"partnerWebinars\",\n            \"xml_delete\": \"partnerWebinars\",\n        },\n    )\n    user_groups: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"userGroups\",\n            \"xml_read\": \"userGroups\",\n            \"xml_update\": \"userGroups\",\n            \"xml_delete\": \"userGroups\",\n        },\n    )\n    surveys: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"surveys\",\n            \"xml_read\": \"surveys\",\n            \"xml_update\": \"surveys\",\n            \"xml_delete\": \"surveys\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"subscriptions\",\n        \"xml_create_tag\": \"subscription\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"subscriptions\",\n        \"xml_read_tag\": \"subscription\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"subscriptions\",\n        \"xml_update_tag\": \"subscription\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"subscriptions\",\n        \"xml_delete_tag\": \"subscription\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/user/#wdadaptivepy.models.user.User","title":"<code>User</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>wdadaptivepy model for Adaptive's Users.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive User ID</p> <code>guid</code> <code>str | None</code> <p>Adaptive User GUID</p> <code>login</code> <code>str | None</code> <p>Adaptive User Login</p> <code>email</code> <code>str | None</code> <p>Adaptive User Email</p> <code>name</code> <code>str | None</code> <p>Adaptive User Name</p> <code>position</code> <code>str | None</code> <p>Adaptive User Position</p> <code>permission_set_ids</code> <code>list[int] | None</code> <p>Adaptive User Permission Set IDs</p> <code>alternate_email</code> <code>str | None</code> <p>Adaptive User Alternate Email</p> <code>saml_fed_id</code> <code>str | None</code> <p>Adaptive User SAML Federation ID</p> <code>time_zone</code> <code>str | None</code> <p>Adaptive User Time Zone</p> <code>homepage</code> <code>str | None</code> <p>Adaptive User Homepage</p> <code>country</code> <code>str | None</code> <p>Adaptive User Country</p> <code>us_state</code> <code>str | None</code> <p>Adaptive User US State</p> <code>perspective</code> <code>str | None</code> <p>Adaptive User Perspective</p> <code>perspective_name</code> <code>str | None</code> <p>Adaptive User Perspective Name</p> <code>dashboard</code> <code>str | None</code> <p>Adaptive User Dashboard</p> <code>dashboard_name</code> <code>str | None</code> <p>Adaptive User Dashboard Name</p> <code>netsuite_login</code> <code>str | None</code> <p>Adaptive User NetSuite Login</p> <code>salesforce_login</code> <code>str | None</code> <p>Adaptive User Salesforce Login</p> <code>created_date</code> <code>datetime | None</code> <p>Adaptive User Created Date</p> <code>last_login</code> <code>datetime | None</code> <p>Adaptive User Last Login</p> <code>failed_attempts</code> <code>int | None</code> <p>Adaptive User Failed Attempts</p> <code>locked</code> <code>bool | None</code> <p>Adaptive User Locked</p> <code>subscriptions</code> <code>Subscription | None</code> <p>Adaptive User Subscriptions</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/user.py</code> <pre><code>@dataclass(eq=False)\nclass User(Metadata):\n    \"\"\"wdadaptivepy model for Adaptive's Users.\n\n    Attributes:\n        id: Adaptive User ID\n        guid: Adaptive User GUID\n        login: Adaptive User Login\n        email: Adaptive User Email\n        name: Adaptive User Name\n        position: Adaptive User Position\n        permission_set_ids: Adaptive User Permission Set IDs\n        alternate_email: Adaptive User Alternate Email\n        saml_fed_id: Adaptive User SAML Federation ID\n        time_zone: Adaptive User Time Zone\n        homepage: Adaptive User Homepage\n        country: Adaptive User Country\n        us_state: Adaptive User US State\n        perspective: Adaptive User Perspective\n        perspective_name: Adaptive User Perspective Name\n        dashboard: Adaptive User Dashboard\n        dashboard_name:Adaptive User Dashboard Name\n        netsuite_login: Adaptive User NetSuite Login\n        salesforce_login: Adaptive User Salesforce Login\n        created_date: Adaptive User Created Date\n        last_login: Adaptive User Last Login\n        failed_attempts: Adaptive User Failed Attempts\n        locked: Adaptive User Locked\n        subscriptions: Adaptive User Subscriptions\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    guid: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"guid\",\n            \"xml_read\": \"guid\",\n            \"xml_update\": \"guid\",\n            \"xml_delete\": \"guid\",\n        },\n    )\n    login: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"login\",\n            \"xml_read\": \"login\",\n            \"xml_update\": \"login\",\n            \"xml_delete\": \"login\",\n        },\n    )\n    email: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"email\",\n            \"xml_read\": \"email\",\n            \"xml_update\": \"email\",\n            \"xml_delete\": \"email\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    position: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"position\",\n            \"xml_read\": \"position\",\n            \"xml_update\": \"position\",\n            \"xml_delete\": \"position\",\n        },\n    )\n    permission_set_ids: list[int] | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_list_or_none,\n            \"xml_parser\": int_list_to_str,\n            \"xml_create\": \"permissionSetIds\",\n            \"xml_read\": \"permissionSetIds\",\n            \"xml_update\": \"permissionSetIds\",\n            \"xml_delete\": \"permissionSetIds\",\n        },\n    )\n    alternate_email: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"alternateEmail\",\n            \"xml_read\": \"alternateEmail\",\n            \"xml_update\": \"alternateEmail\",\n            \"xml_delete\": \"alternateEmail\",\n        },\n    )\n    saml_fed_id: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"samlFedId\",\n            \"xml_read\": \"samlFedId\",\n            \"xml_update\": \"samlFedId\",\n            \"xml_delete\": \"samlFedId\",\n        },\n    )\n    time_zone: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"timeZone\",\n            \"xml_read\": \"timeZone\",\n            \"xml_update\": \"timeZone\",\n            \"xml_delete\": \"timeZone\",\n        },\n    )\n    homepage: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"homepage\",\n            \"xml_read\": \"homepage\",\n            \"xml_update\": \"homepage\",\n            \"xml_delete\": \"homepage\",\n        },\n    )\n    country: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"country\",\n            \"xml_read\": \"country\",\n            \"xml_update\": \"country\",\n            \"xml_delete\": \"country\",\n        },\n    )\n    us_state: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"usState\",\n            \"xml_read\": \"usState\",\n            \"xml_update\": \"usState\",\n            \"xml_delete\": \"usState\",\n        },\n    )\n    perspective: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"perspective\",\n            \"xml_read\": \"perspective\",\n            \"xml_update\": \"perspective\",\n            \"xml_delete\": \"perspective\",\n        },\n    )\n    perspective_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"perspectiveName\",\n            \"xml_read\": \"perspectiveName\",\n            \"xml_update\": \"perspectiveName\",\n            \"xml_delete\": \"perspectiveName\",\n        },\n    )\n    dashboard: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": nullable_int_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"dashboard\",\n            \"xml_read\": \"dashboard\",\n            \"xml_update\": \"dashboard\",\n            \"xml_delete\": \"dashboard\",\n        },\n    )\n    dashboard_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"dashboardName\",\n            \"xml_read\": \"dashboardName\",\n            \"xml_update\": \"dashboardName\",\n            \"xml_delete\": \"dashboardName\",\n        },\n    )\n    netsuite_login: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"netsuiteLogin\",\n            \"xml_read\": \"netsuiteLogin\",\n            \"xml_update\": \"netsuiteLogin\",\n            \"xml_delete\": \"netsuiteLogin\",\n        },\n    )\n    salesforce_login: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"salesforceLogin\",\n            \"xml_read\": \"salesforceLogin\",\n            \"xml_update\": \"salesforceLogin\",\n            \"xml_delete\": \"salesforceLogin\",\n        },\n    )\n    created_date: datetime | None = field(\n        default=None,\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"createdDate\",\n            \"xml_read\": \"createdDate\",\n            \"xml_update\": \"createdDate\",\n            \"xml_delete\": \"createdDate\",\n        },\n    )\n    last_login: datetime | None = field(\n        default=None,\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"lastLogin\",\n            \"xml_read\": \"lastLogin\",\n            \"xml_update\": \"lastLogin\",\n            \"xml_delete\": \"lastLogin\",\n        },\n    )\n    failed_attempts: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"failedAttempts\",\n            \"xml_read\": \"failedAttempts\",\n            \"xml_update\": \"failedAttempts\",\n            \"xml_delete\": \"failedAttempts\",\n        },\n    )\n    locked: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"locked\",\n            \"xml_read\": \"locked\",\n            \"xml_update\": \"locked\",\n            \"xml_delete\": \"locked\",\n        },\n    )\n    subscriptions: Subscription | None = field(\n        default=None,\n        metadata={\n            # \"validator\": ,\n            # \"xml_parser\": ,\n            \"xml_create\": \"subscriptions\",\n            \"xml_read\": \"subscriptions\",\n            \"xml_update\": \"subscriptions\",\n            \"xml_delete\": \"subscriptions\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"users\",\n        \"xml_create_tag\": \"user\",\n        \"xml_create_children\": {\"subscriptions\": Subscription},\n        \"xml_read_parent_tag\": \"users\",\n        \"xml_read_tag\": \"user\",\n        \"xml_read_children\": {\"subscriptions\": Subscription},\n        \"xml_update_parent_tag\": \"users\",\n        \"xml_update_tag\": \"user\",\n        \"xml_update_children\": {\"subscriptions\": Subscription},\n        \"xml_delete_parent_tag\": \"users\",\n        \"xml_delete_tag\": \"user\",\n        \"xml_delete_children\": {\"subscriptions\": Subscription},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/models/version/","title":"version","text":"<p>wdadaptivepy model for Adaptive's Versions.</p>"},{"location":"reference/wdadaptivepy/models/version/#wdadaptivepy.models.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HierchialMetadata</code></p> <p>wdadaptivepy model for Adaptive's Versions.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Adaptive Version ID</p> <code>name</code> <code>str | None</code> <p>Adaptive Version Name</p> <code>short_name</code> <code>str | None</code> <p>Adaptive Version Short Name</p> <code>version_type</code> <code>str | None</code> <p>Adaptive Version Type</p> <code>is_virtual</code> <code>bool | None</code> <p>Adaptive Version Is Virtual</p> <code>description</code> <code>str | None</code> <p>Adaptive Version Description</p> <code>is_default_version</code> <code>bool | None</code> <p>Adaptive Version Is Default Version</p> <code>is_locked</code> <code>bool | None</code> <p>Adaptive Version Is Locked</p> <code>has_audit_trail</code> <code>bool | None</code> <p>Adaptive Version Has Audit Trail</p> <code>enabled_for_workflow</code> <code>bool | None</code> <p>Adaptive Version Enabled for Workflow</p> <code>is_importable</code> <code>bool | None</code> <p>Adaptive Version Is Importable</p> <code>start_ver</code> <code>str | None</code> <p>Adaptive Version Start of Version</p> <code>end_ver</code> <code>str | None</code> <p>Adaptive Version End of Version</p> <code>start_scroll</code> <code>str | None</code> <p>Adaptive Version Start Scroll</p> <code>completed_values_thru</code> <code>str | None</code> <p>Adaptive Version Complted Values Through</p> <code>left_scroll</code> <code>str | None</code> <p>Adaptive Version Left Scroll</p> <code>start_plan</code> <code>str | None</code> <p>Adaptive Version Start Plan</p> <code>end_plan</code> <code>str | None</code> <p>ADaptive Version End Plan</p> <code>lock_leading</code> <code>str | None</code> <p>Adaptive Version Lock Leading</p> <code>is_predictive</code> <code>bool | None</code> <p>Adaptive Version Is Predictive</p> <code>__xml_tags</code> <code>dict[str, str | dict[str, type]]</code> <p>wdadaptivepy XML tags</p> Source code in <code>src/wdadaptivepy/models/version.py</code> <pre><code>@dataclass(eq=False)\nclass Version(HierchialMetadata):\n    \"\"\"wdadaptivepy model for Adaptive's Versions.\n\n    Attributes:\n        id: Adaptive Version ID\n        name: Adaptive Version Name\n        short_name: Adaptive Version Short Name\n        version_type: Adaptive Version Type\n        is_virtual: Adaptive Version Is Virtual\n        description: Adaptive Version Description\n        is_default_version: Adaptive Version Is Default Version\n        is_locked: Adaptive Version Is Locked\n        has_audit_trail: Adaptive Version Has Audit Trail\n        enabled_for_workflow: Adaptive Version Enabled for Workflow\n        is_importable: Adaptive Version Is Importable\n        start_ver: Adaptive Version Start of Version\n        end_ver: Adaptive Version End of Version\n        start_scroll: Adaptive Version Start Scroll\n        completed_values_thru: Adaptive Version Complted Values Through\n        left_scroll: Adaptive Version Left Scroll\n        start_plan: Adaptive Version Start Plan\n        end_plan: ADaptive Version End Plan\n        lock_leading: Adaptive Version Lock Leading\n        is_predictive: Adaptive Version Is Predictive\n        __xml_tags: wdadaptivepy XML tags\n\n    \"\"\"\n\n    id: int | None = field(\n        default=None,\n        metadata={\n            \"validator\": int_or_none,\n            \"xml_parser\": int_to_str,\n            \"xml_create\": \"\",\n            \"xml_read\": \"id\",\n            \"xml_update\": \"id\",\n            \"xml_delete\": \"id\",\n        },\n    )\n    name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"name\",\n            \"xml_read\": \"name\",\n            \"xml_update\": \"name\",\n            \"xml_delete\": \"name\",\n        },\n    )\n    short_name: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"shortName\",\n            \"xml_read\": \"shortName\",\n            \"xml_update\": \"shortName\",\n            \"xml_delete\": \"shortName\",\n        },\n    )\n    version_type: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"type\",\n            \"xml_read\": \"type\",\n            \"xml_update\": \"type\",\n            \"xml_delete\": \"type\",\n        },\n    )\n    is_virtual: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isVirtual\",\n            \"xml_read\": \"isVirtual\",\n            \"xml_update\": \"isVirtual\",\n            \"xml_delete\": \"isVirtual\",\n        },\n    )\n    description: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"description\",\n            \"xml_read\": \"description\",\n            \"xml_update\": \"description\",\n            \"xml_delete\": \"description\",\n        },\n    )\n    is_default_version: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isDefaultVersion\",\n            \"xml_read\": \"isDefaultVersion\",\n            \"xml_update\": \"isDefaultVersion\",\n            \"xml_delete\": \"isDefaultVersion\",\n        },\n    )\n    is_locked: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isLocked\",\n            \"xml_read\": \"isLocked\",\n            \"xml_update\": \"isLocked\",\n            \"xml_delete\": \"isLocked\",\n        },\n    )\n    has_audit_trail: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"hasAuditTrail\",\n            \"xml_read\": \"hasAuditTrail\",\n            \"xml_update\": \"hasAuditTrail\",\n            \"xml_delete\": \"hasAuditTrail\",\n        },\n    )\n    enabled_for_workflow: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"enabledForWorkflow\",\n            \"xml_read\": \"enabledForWorkflow\",\n            \"xml_update\": \"enabledForWorkflow\",\n            \"xml_delete\": \"enabledForWorkflow\",\n        },\n    )\n    is_importable: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_one_zero,\n            \"xml_create\": \"isImportable\",\n            \"xml_read\": \"isImportable\",\n            \"xml_update\": \"isImportable\",\n            \"xml_delete\": \"isImportable\",\n        },\n    )\n    start_ver: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"startVer\",\n            \"xml_read\": \"startVer\",\n            \"xml_update\": \"startVer\",\n            \"xml_delete\": \"startVer\",\n        },\n    )\n    end_ver: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"endVer\",\n            \"xml_read\": \"endVer\",\n            \"xml_update\": \"endVer\",\n            \"xml_delete\": \"endVer\",\n        },\n    )\n    start_scroll: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"startScroll\",\n            \"xml_read\": \"startScroll\",\n            \"xml_update\": \"startScroll\",\n            \"xml_delete\": \"startScroll\",\n        },\n    )\n    completed_values_thru: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"completedValuesThru\",\n            \"xml_read\": \"completedValuesThru\",\n            \"xml_update\": \"completedValuesThru\",\n            \"xml_delete\": \"completedValuesThru\",\n        },\n    )\n    left_scroll: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"leftScroll\",\n            \"xml_read\": \"leftScroll\",\n            \"xml_update\": \"leftScroll\",\n            \"xml_delete\": \"leftScroll\",\n        },\n    )\n    start_plan: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"startPlan\",\n            \"xml_read\": \"startPlan\",\n            \"xml_update\": \"startPlan\",\n            \"xml_delete\": \"startPlan\",\n        },\n    )\n    end_plan: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"endPlan\",\n            \"xml_read\": \"endPlan\",\n            \"xml_update\": \"endPlan\",\n            \"xml_delete\": \"endPlan\",\n        },\n    )\n    lock_leading: str | None = field(\n        default=None,\n        metadata={\n            \"validator\": str_or_none,\n            \"xml_parser\": str_to_str,\n            \"xml_create\": \"lockLeading\",\n            \"xml_read\": \"lockLeading\",\n            \"xml_update\": \"lockLeading\",\n            \"xml_delete\": \"lockLeading\",\n        },\n    )\n    is_predictive: bool | None = field(\n        default=None,\n        metadata={\n            \"validator\": bool_or_none,\n            \"xml_parser\": bool_to_str_true_false,\n            \"xml_create\": \"isPredictive\",\n            \"xml_read\": \"isPredictive\",\n            \"xml_update\": \"isPredictive\",\n            \"xml_delete\": \"isPredictive\",\n        },\n    )\n    __xml_tags: ClassVar[dict[str, str | dict[str, type]]] = {\n        \"xml_create_parent_tag\": \"versions\",\n        \"xml_create_tag\": \"version\",\n        \"xml_create_children\": {},\n        \"xml_read_parent_tag\": \"versions\",\n        \"xml_read_tag\": \"version\",\n        \"xml_read_children\": {},\n        \"xml_update_parent_tag\": \"versions\",\n        \"xml_update_tag\": \"version\",\n        \"xml_update_children\": {},\n        \"xml_delete_parent_tag\": \"versions\",\n        \"xml_delete_tag\": \"version\",\n        \"xml_delete_children\": {},\n    }\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/","title":"init","text":"<p>wdadaptivepy service for Adaptive's APIs.</p>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AccountService","title":"<code>AccountService</code>","text":"<p>Create, retrieve, and modify Adaptive Accounts.</p> <p>Attributes:</p> Name Type Description <code>Account</code> <p>wdadaptivepy Account</p> Source code in <code>src/wdadaptivepy/services/accounts.py</code> <pre><code>class AccountService:\n    \"\"\"Create, retrieve, and modify Adaptive Accounts.\n\n    Attributes:\n        Account: wdadaptivepy Account\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize Account Service.\n\n        Args:\n            xml_api: Adaptive XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Account = Account\n\n    def get_all(\n        self,\n        *,\n        attributes: bool = True,\n        include_attribute_value_names: bool = True,\n        include_attribute_value_display_names: bool = True,\n    ) -&gt; MetadataList[Account]:\n        \"\"\"Retrieve all Accounts from Adaptive.\n\n        Args:\n            attributes: Include Account Attributes for each Account\n            include_attribute_value_names: Include Name for each Account\n            include_attribute_value_display_names: Include Display Name for each Account\n\n        Returns:\n            wdadaptivepy Accounts\n\n        \"\"\"\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"attributes\": str(bool_to_str_true_false(attributes)),\n                \"include_attribute_value_names\": str(\n                    bool_to_str_true_false(include_attribute_value_names),\n                ),\n                \"include_attribute_value_display_names\": str(\n                    bool_to_str_true_false(include_attribute_value_display_names),\n                ),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportAccounts\",\n            payload=include,\n        )\n        return MetadataList[Account](Account.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        accounts: Sequence[Account],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Account update XML API call for review prior to sending to Adaptive.\n\n        Args:\n            accounts: wdadaptivepy Accounts to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_accounts = Account.to_xml(\"update\", accounts)\n        # ET.indent(updated_accounts)\n        # with open(\"test_accounts.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_accounts, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importAccounts\",\n            payload=updated_accounts,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[Account]:\n        \"\"\"Convert JSON data to MetadataList of Accounts.\n\n        Args:\n            data: JSON Data\n\n        Returns:\n            MetadataList of Accounts\n\n        \"\"\"\n        return MetadataList[Account](Account.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Account]:\n        \"\"\"Convert Python Dictionary to MetadataList of Accounts.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Accounts\n\n        \"\"\"\n        return MetadataList[Account](Account.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AccountService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize Account Service.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>Adaptive XMLApi</p> required Source code in <code>src/wdadaptivepy/services/accounts.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize Account Service.\n\n    Args:\n        xml_api: Adaptive XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Account = Account\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AccountService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Accounts.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Account]</code> <p>MetadataList of Accounts</p> Source code in <code>src/wdadaptivepy/services/accounts.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Account]:\n    \"\"\"Convert Python Dictionary to MetadataList of Accounts.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Accounts\n\n    \"\"\"\n    return MetadataList[Account](Account.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AccountService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON data to MetadataList of Accounts.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON Data</p> required <p>Returns:</p> Type Description <code>MetadataList[Account]</code> <p>MetadataList of Accounts</p> Source code in <code>src/wdadaptivepy/services/accounts.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Account]:\n    \"\"\"Convert JSON data to MetadataList of Accounts.\n\n    Args:\n        data: JSON Data\n\n    Returns:\n        MetadataList of Accounts\n\n    \"\"\"\n    return MetadataList[Account](Account.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AccountService.get_all","title":"<code>get_all(*, attributes=True, include_attribute_value_names=True, include_attribute_value_display_names=True)</code>","text":"<p>Retrieve all Accounts from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>bool</code> <p>Include Account Attributes for each Account</p> <code>True</code> <code>include_attribute_value_names</code> <code>bool</code> <p>Include Name for each Account</p> <code>True</code> <code>include_attribute_value_display_names</code> <code>bool</code> <p>Include Display Name for each Account</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[Account]</code> <p>wdadaptivepy Accounts</p> Source code in <code>src/wdadaptivepy/services/accounts.py</code> <pre><code>def get_all(\n    self,\n    *,\n    attributes: bool = True,\n    include_attribute_value_names: bool = True,\n    include_attribute_value_display_names: bool = True,\n) -&gt; MetadataList[Account]:\n    \"\"\"Retrieve all Accounts from Adaptive.\n\n    Args:\n        attributes: Include Account Attributes for each Account\n        include_attribute_value_names: Include Name for each Account\n        include_attribute_value_display_names: Include Display Name for each Account\n\n    Returns:\n        wdadaptivepy Accounts\n\n    \"\"\"\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"attributes\": str(bool_to_str_true_false(attributes)),\n            \"include_attribute_value_names\": str(\n                bool_to_str_true_false(include_attribute_value_names),\n            ),\n            \"include_attribute_value_display_names\": str(\n                bool_to_str_true_false(include_attribute_value_display_names),\n            ),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportAccounts\",\n        payload=include,\n    )\n    return MetadataList[Account](Account.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AccountService.preview_update","title":"<code>preview_update(accounts, *, hide_password=True)</code>","text":"<p>Generate Account update XML API call for review prior to sending to Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>accounts</code> <code>Sequence[Account]</code> <p>wdadaptivepy Accounts to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/accounts.py</code> <pre><code>def preview_update(\n    self,\n    accounts: Sequence[Account],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Account update XML API call for review prior to sending to Adaptive.\n\n    Args:\n        accounts: wdadaptivepy Accounts to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_accounts = Account.to_xml(\"update\", accounts)\n    # ET.indent(updated_accounts)\n    # with open(\"test_accounts.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_accounts, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importAccounts\",\n        payload=updated_accounts,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AttributeService","title":"<code>AttributeService</code>","text":"<p>Create, retrieve, and modify Adaptive Attributes.</p> <p>Attributes:</p> Name Type Description <code>Attribute</code> <p>wdadaptivepy Attribute</p> Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>class AttributeService:\n    \"\"\"Create, retrieve, and modify Adaptive Attributes.\n\n    Attributes:\n        Attribute: wdadaptivepy Attribute\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize Attribute Service.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Attribute = Attribute\n\n    def get_all(self, *, display_name_enabled: bool = True) -&gt; MetadataList[Attribute]:\n        \"\"\"Retreive all Attributes from Adaptive.\n\n        Args:\n            display_name_enabled: Include Display Name\n\n        Returns:\n            wdadaptivepy Attributes\n\n        \"\"\"\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportAttributes\",\n            payload=include,\n        )\n        return MetadataList[Attribute](Attribute.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        attributes: Sequence[Attribute],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Attribute update XML API call for review.\n\n        Args:\n            attributes: wdadaptivepy Attributes to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_attributes = Attribute.to_xml(\"update\", attributes)\n        # ET.indent(updated_attributes)\n        # with open(\"test_attributes.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_attributes, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importAttributes\",\n            payload=updated_attributes,\n            hide_password=hide_password,\n        )\n\n    def get(  # NOQA: PLR0912, PLR0913\n        self,\n        attributes: Sequence[Attribute] = [],\n        attribute_ids: Sequence[int] = [],\n        attribute_names: Sequence[str] = [],\n        attribute_types: Sequence[str] = [],\n        dimensions: Sequence[Dimension] = [],\n        dimension_ids: Sequence[int] = [],\n        *,\n        display_name_enabled: bool = True,\n    ) -&gt; MetadataList[Attribute]:\n        \"\"\"Retrieve Attributes from Adaptive based on parameters.\n\n        Args:\n            attributes: wdadaptivepy Attributes\n            attribute_ids: ID of Attributes\n            attribute_names: Name of Attributes\n            attribute_types: Type of Attribute (eg: Level, Account, Dimension)\n            dimensions: wdadaptivepy Dimensions\n            dimension_ids: ID of Dimensions\n            display_name_enabled: Include Display Name for each Attribute\n\n        Returns:\n            wdadaptivepy Attributes\n\n        \"\"\"\n        ids: list[int] = []\n        if attributes:\n            ids.extend(\n                [attribute.id for attribute in attributes if attribute.id is not None],\n            )\n        elif attribute_ids:\n            ids.extend(attribute_ids)\n        elif attribute_names:\n            all_attributes = self.get_all()\n            for name in attribute_names:\n                for attribute in all_attributes:\n                    if name == attribute.name and attribute.id is not None:\n                        ids.append(attribute.id)\n                        break\n        elif attribute_types:\n            all_attributes = self.get_all()\n            for attribute_type in attribute_types:\n                for attribute in all_attributes:\n                    if (\n                        attribute_type == attribute.attribute_type\n                        and attribute.id is not None\n                    ):\n                        ids.append(attribute.id)\n                        break\n        elif not (dimensions or dimension_ids):\n            all_attributes = self.get_all()\n            if dimensions:\n                for dimension in dimensions:\n                    for attribute in all_attributes:\n                        if (\n                            attribute.dimension_id == dimension.id\n                            and attribute.id is not None\n                        ):\n                            ids.append(attribute.id)\n                            break\n            elif dimension_ids:\n                for dimension_id in dimension_ids:\n                    for attribute in all_attributes:\n                        if (\n                            attribute.dimension_id == dimension_id\n                            and attribute.id is not None\n                        ):\n                            ids.append(attribute.id)\n                            break\n        else:\n            raise ValueError\n        if not ids:\n            raise ValueError\n\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"attributeIDs\": \",\".join(str(attribute_id) for attribute_id in ids),\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportAttributes\",\n            payload=include,\n        )\n        return MetadataList[Attribute](Attribute.from_xml(xml=response))\n\n    def from_json(self, data: str) -&gt; MetadataList[Attribute]:\n        \"\"\"Convert JSON to MetadataList of Attributes.\n\n        Args:\n            data: JSON data\n\n        Returns:\n            MetadataList of Attributes\n\n        \"\"\"\n        return MetadataList[Attribute](Attribute.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Attribute]:\n        \"\"\"Convert Python Dictionary to MetadataList of Attributes.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Attributes\n\n        \"\"\"\n        return MetadataList[Attribute](Attribute.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AttributeService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize Attribute Service.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize Attribute Service.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Attribute = Attribute\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AttributeService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Attributes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Attribute]</code> <p>MetadataList of Attributes</p> Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Attribute]:\n    \"\"\"Convert Python Dictionary to MetadataList of Attributes.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Attributes\n\n    \"\"\"\n    return MetadataList[Attribute](Attribute.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AttributeService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Attributes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON data</p> required <p>Returns:</p> Type Description <code>MetadataList[Attribute]</code> <p>MetadataList of Attributes</p> Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Attribute]:\n    \"\"\"Convert JSON to MetadataList of Attributes.\n\n    Args:\n        data: JSON data\n\n    Returns:\n        MetadataList of Attributes\n\n    \"\"\"\n    return MetadataList[Attribute](Attribute.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AttributeService.get","title":"<code>get(attributes=[], attribute_ids=[], attribute_names=[], attribute_types=[], dimensions=[], dimension_ids=[], *, display_name_enabled=True)</code>","text":"<p>Retrieve Attributes from Adaptive based on parameters.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Sequence[Attribute]</code> <p>wdadaptivepy Attributes</p> <code>[]</code> <code>attribute_ids</code> <code>Sequence[int]</code> <p>ID of Attributes</p> <code>[]</code> <code>attribute_names</code> <code>Sequence[str]</code> <p>Name of Attributes</p> <code>[]</code> <code>attribute_types</code> <code>Sequence[str]</code> <p>Type of Attribute (eg: Level, Account, Dimension)</p> <code>[]</code> <code>dimensions</code> <code>Sequence[Dimension]</code> <p>wdadaptivepy Dimensions</p> <code>[]</code> <code>dimension_ids</code> <code>Sequence[int]</code> <p>ID of Dimensions</p> <code>[]</code> <code>display_name_enabled</code> <code>bool</code> <p>Include Display Name for each Attribute</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[Attribute]</code> <p>wdadaptivepy Attributes</p> Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>def get(  # NOQA: PLR0912, PLR0913\n    self,\n    attributes: Sequence[Attribute] = [],\n    attribute_ids: Sequence[int] = [],\n    attribute_names: Sequence[str] = [],\n    attribute_types: Sequence[str] = [],\n    dimensions: Sequence[Dimension] = [],\n    dimension_ids: Sequence[int] = [],\n    *,\n    display_name_enabled: bool = True,\n) -&gt; MetadataList[Attribute]:\n    \"\"\"Retrieve Attributes from Adaptive based on parameters.\n\n    Args:\n        attributes: wdadaptivepy Attributes\n        attribute_ids: ID of Attributes\n        attribute_names: Name of Attributes\n        attribute_types: Type of Attribute (eg: Level, Account, Dimension)\n        dimensions: wdadaptivepy Dimensions\n        dimension_ids: ID of Dimensions\n        display_name_enabled: Include Display Name for each Attribute\n\n    Returns:\n        wdadaptivepy Attributes\n\n    \"\"\"\n    ids: list[int] = []\n    if attributes:\n        ids.extend(\n            [attribute.id for attribute in attributes if attribute.id is not None],\n        )\n    elif attribute_ids:\n        ids.extend(attribute_ids)\n    elif attribute_names:\n        all_attributes = self.get_all()\n        for name in attribute_names:\n            for attribute in all_attributes:\n                if name == attribute.name and attribute.id is not None:\n                    ids.append(attribute.id)\n                    break\n    elif attribute_types:\n        all_attributes = self.get_all()\n        for attribute_type in attribute_types:\n            for attribute in all_attributes:\n                if (\n                    attribute_type == attribute.attribute_type\n                    and attribute.id is not None\n                ):\n                    ids.append(attribute.id)\n                    break\n    elif not (dimensions or dimension_ids):\n        all_attributes = self.get_all()\n        if dimensions:\n            for dimension in dimensions:\n                for attribute in all_attributes:\n                    if (\n                        attribute.dimension_id == dimension.id\n                        and attribute.id is not None\n                    ):\n                        ids.append(attribute.id)\n                        break\n        elif dimension_ids:\n            for dimension_id in dimension_ids:\n                for attribute in all_attributes:\n                    if (\n                        attribute.dimension_id == dimension_id\n                        and attribute.id is not None\n                    ):\n                        ids.append(attribute.id)\n                        break\n    else:\n        raise ValueError\n    if not ids:\n        raise ValueError\n\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"attributeIDs\": \",\".join(str(attribute_id) for attribute_id in ids),\n            \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportAttributes\",\n        payload=include,\n    )\n    return MetadataList[Attribute](Attribute.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AttributeService.get_all","title":"<code>get_all(*, display_name_enabled=True)</code>","text":"<p>Retreive all Attributes from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>display_name_enabled</code> <code>bool</code> <p>Include Display Name</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[Attribute]</code> <p>wdadaptivepy Attributes</p> Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>def get_all(self, *, display_name_enabled: bool = True) -&gt; MetadataList[Attribute]:\n    \"\"\"Retreive all Attributes from Adaptive.\n\n    Args:\n        display_name_enabled: Include Display Name\n\n    Returns:\n        wdadaptivepy Attributes\n\n    \"\"\"\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportAttributes\",\n        payload=include,\n    )\n    return MetadataList[Attribute](Attribute.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AttributeService.preview_update","title":"<code>preview_update(attributes, *, hide_password=True)</code>","text":"<p>Generate Attribute update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Sequence[Attribute]</code> <p>wdadaptivepy Attributes to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>def preview_update(\n    self,\n    attributes: Sequence[Attribute],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Attribute update XML API call for review.\n\n    Args:\n        attributes: wdadaptivepy Attributes to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_attributes = Attribute.to_xml(\"update\", attributes)\n    # ET.indent(updated_attributes)\n    # with open(\"test_attributes.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_attributes, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importAttributes\",\n        payload=updated_attributes,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AttributeValueService","title":"<code>AttributeValueService</code>","text":"<p>Create, retrieve, and modify Adaptive Attribute Values.</p> <p>Attributes:</p> Name Type Description <code>AttributeValue</code> <p>wdadaptivepy AttributeValue</p> Source code in <code>src/wdadaptivepy/services/attribute_values.py</code> <pre><code>class AttributeValueService:\n    \"\"\"Create, retrieve, and modify Adaptive Attribute Values.\n\n    Attributes:\n        AttributeValue: wdadaptivepy AttributeValue\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize Attribute Service.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.AttributeValue = AttributeValue\n\n    def get_all(\n        self,\n        attribute: Attribute | str | int,\n        *,\n        display_name_enabled: bool = True,\n    ) -&gt; MetadataList[AttributeValue]:\n        \"\"\"Retreive all Attribute Values from Adaptive.\n\n        Args:\n            attribute: Adaptive Attribute\n            display_name_enabled: Include Display Name\n\n        Returns:\n            wdadaptivepy Attribute Values\n\n        \"\"\"\n        _, attribute_values = self.__find_attribute(\n            attribute,\n            display_name_enabled=display_name_enabled,\n        )\n        return attribute_values\n\n    def preview_update(\n        self,\n        attribute: Attribute | int | str,\n        attribute_values: Sequence[AttributeValue],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Attribute update XML API call for review.\n\n        Args:\n            attribute: adaptivepy Attribute\n            attribute_values: wdadaptivepy Attribute Values to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        method, payload = self.__build_update_payload(attribute, attribute_values)\n        # updated_attributes = Attribute.to_xml(\"update\", attributes)\n        # ET.indent(updated_attributes)\n        # with open(\"test_attributes.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_attributes, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=method,\n            payload=payload,\n            hide_password=hide_password,\n        )\n\n    def __build_update_payload(\n        self,\n        attribute: Attribute | int | str,\n        attribute_values: Sequence[AttributeValue],\n    ) -&gt; tuple[str, ET.Element]:\n        for attribute_value in attribute_values:\n            if attribute_value.id is None or attribute_value.id == 0:\n                raise ValueError\n        found_attribute, _ = self.__find_attribute(attribute=attribute)\n        update_attributes = Attribute.to_xml(\n            \"update\",\n            [Attribute(id=found_attribute.id)],\n        )\n        update_attribute = update_attributes.find(\"attribute\")\n        if update_attribute is None:\n            raise ValueError\n        update_attribute.extend(\n            AttributeValue.to_xml(\"update\", attribute_values),\n        )\n        return \"updateAttributes\", update_attributes\n\n    def __find_attribute(\n        self,\n        attribute: Attribute | int | str,\n        *,\n        display_name_enabled: bool = True,\n    ) -&gt; tuple[Attribute, MetadataList[AttributeValue]]:\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportAttributes\",\n            payload=include,\n        )\n\n        attributes = MetadataList[Attribute](Attribute.from_xml(xml=response))\n        attribute_check = Attribute()\n        if isinstance(attribute, Attribute):\n            attribute_check = attribute\n        elif isinstance(attribute, int):\n            attribute_check.id = attribute\n        elif isinstance(attribute, str):\n            attribute_check.name = attribute\n        else:\n            raise TypeError\n\n        found_attribute = None\n        for attr in attributes:\n            if attr.id == attribute_check.id or attr.name == attribute_check.name:\n                found_attribute = attr\n                break\n        if found_attribute is None:\n            raise ValueError\n\n        found_xml_elem = None\n        for elem in response.iter(\"attribute\"):\n            if elem.get(\"id\") == str(found_attribute.id):\n                found_xml_elem = elem\n                break\n        if found_xml_elem is None:\n            raise ValueError\n        found_attribute_values = AttributeValue.from_xml(found_xml_elem)\n\n        return found_attribute, found_attribute_values\n\n    def from_json(self, data: str) -&gt; MetadataList[AttributeValue]:\n        \"\"\"Convert JSON to MetadataList of Attribute Values.\n\n        Args:\n            data: JSON data\n\n        Returns:\n            MetadataList of Attribute Values\n\n        \"\"\"\n        return MetadataList[AttributeValue](AttributeValue.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[AttributeValue]:\n        \"\"\"Convert Python Dictionary to MetadataList of Attribute Values.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Attribute Value\n\n        \"\"\"\n        return MetadataList[AttributeValue](AttributeValue.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AttributeValueService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize Attribute Service.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/attribute_values.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize Attribute Service.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.AttributeValue = AttributeValue\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AttributeValueService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Attribute Values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[AttributeValue]</code> <p>MetadataList of Attribute Value</p> Source code in <code>src/wdadaptivepy/services/attribute_values.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[AttributeValue]:\n    \"\"\"Convert Python Dictionary to MetadataList of Attribute Values.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Attribute Value\n\n    \"\"\"\n    return MetadataList[AttributeValue](AttributeValue.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AttributeValueService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Attribute Values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON data</p> required <p>Returns:</p> Type Description <code>MetadataList[AttributeValue]</code> <p>MetadataList of Attribute Values</p> Source code in <code>src/wdadaptivepy/services/attribute_values.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[AttributeValue]:\n    \"\"\"Convert JSON to MetadataList of Attribute Values.\n\n    Args:\n        data: JSON data\n\n    Returns:\n        MetadataList of Attribute Values\n\n    \"\"\"\n    return MetadataList[AttributeValue](AttributeValue.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AttributeValueService.get_all","title":"<code>get_all(attribute, *, display_name_enabled=True)</code>","text":"<p>Retreive all Attribute Values from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>Attribute | str | int</code> <p>Adaptive Attribute</p> required <code>display_name_enabled</code> <code>bool</code> <p>Include Display Name</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[AttributeValue]</code> <p>wdadaptivepy Attribute Values</p> Source code in <code>src/wdadaptivepy/services/attribute_values.py</code> <pre><code>def get_all(\n    self,\n    attribute: Attribute | str | int,\n    *,\n    display_name_enabled: bool = True,\n) -&gt; MetadataList[AttributeValue]:\n    \"\"\"Retreive all Attribute Values from Adaptive.\n\n    Args:\n        attribute: Adaptive Attribute\n        display_name_enabled: Include Display Name\n\n    Returns:\n        wdadaptivepy Attribute Values\n\n    \"\"\"\n    _, attribute_values = self.__find_attribute(\n        attribute,\n        display_name_enabled=display_name_enabled,\n    )\n    return attribute_values\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.AttributeValueService.preview_update","title":"<code>preview_update(attribute, attribute_values, *, hide_password=True)</code>","text":"<p>Generate Attribute update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>Attribute | int | str</code> <p>adaptivepy Attribute</p> required <code>attribute_values</code> <code>Sequence[AttributeValue]</code> <p>wdadaptivepy Attribute Values to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/attribute_values.py</code> <pre><code>def preview_update(\n    self,\n    attribute: Attribute | int | str,\n    attribute_values: Sequence[AttributeValue],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Attribute update XML API call for review.\n\n    Args:\n        attribute: adaptivepy Attribute\n        attribute_values: wdadaptivepy Attribute Values to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    method, payload = self.__build_update_payload(attribute, attribute_values)\n    # updated_attributes = Attribute.to_xml(\"update\", attributes)\n    # ET.indent(updated_attributes)\n    # with open(\"test_attributes.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_attributes, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=method,\n        payload=payload,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.CurrencyService","title":"<code>CurrencyService</code>","text":"<p>Create, retrieve, and modify Adaptive Currencies.</p> <p>Attributes:</p> Name Type Description <code>Currency</code> <p>wdadaptivepy Currency</p> Source code in <code>src/wdadaptivepy/services/currencies.py</code> <pre><code>class CurrencyService:\n    \"\"\"Create, retrieve, and modify Adaptive Currencies.\n\n    Attributes:\n        Currency: wdadaptivepy Currency\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize CurrencyService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Currency = Currency\n\n    def get_all(self) -&gt; MetadataList[Currency]:\n        \"\"\"Retrieve all Currencies from Adaptive.\n\n        Returns:\n            adaptive Currencies\n\n        \"\"\"\n        response = self.__xml_api.make_xml_request(\n            method=\"exportActiveCurrencies\",\n            payload=None,\n        )\n        return MetadataList[Currency](Currency.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        currencies: Sequence[Currency],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Currency update XML API call for review.\n\n        Args:\n            currencies: wdadaptivepy Currencies to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_currencies = Currency.to_xml(\"update\", currencies)\n        # ET.indent(updated_currencies)\n        # with open(\"test_currencies.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_currencies, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importCurrencies\",\n            payload=updated_currencies,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[Currency]:\n        \"\"\"Convert JSON to MetadataList of Currencies.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Currencies\n\n        \"\"\"\n        return MetadataList[Currency](Currency.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Currency]:\n        \"\"\"Convert Python Dictionary to MetadataList of Currencies.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Currencies\n\n        \"\"\"\n        return MetadataList[Currency](Currency.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.CurrencyService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize CurrencyService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/currencies.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize CurrencyService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Currency = Currency\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.CurrencyService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Currencies.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Currency]</code> <p>MetadataList of Currencies</p> Source code in <code>src/wdadaptivepy/services/currencies.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Currency]:\n    \"\"\"Convert Python Dictionary to MetadataList of Currencies.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Currencies\n\n    \"\"\"\n    return MetadataList[Currency](Currency.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.CurrencyService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Currencies.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[Currency]</code> <p>MetadataList of Currencies</p> Source code in <code>src/wdadaptivepy/services/currencies.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Currency]:\n    \"\"\"Convert JSON to MetadataList of Currencies.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Currencies\n\n    \"\"\"\n    return MetadataList[Currency](Currency.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.CurrencyService.get_all","title":"<code>get_all()</code>","text":"<p>Retrieve all Currencies from Adaptive.</p> <p>Returns:</p> Type Description <code>MetadataList[Currency]</code> <p>adaptive Currencies</p> Source code in <code>src/wdadaptivepy/services/currencies.py</code> <pre><code>def get_all(self) -&gt; MetadataList[Currency]:\n    \"\"\"Retrieve all Currencies from Adaptive.\n\n    Returns:\n        adaptive Currencies\n\n    \"\"\"\n    response = self.__xml_api.make_xml_request(\n        method=\"exportActiveCurrencies\",\n        payload=None,\n    )\n    return MetadataList[Currency](Currency.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.CurrencyService.preview_update","title":"<code>preview_update(currencies, *, hide_password=True)</code>","text":"<p>Generate Currency update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>currencies</code> <code>Sequence[Currency]</code> <p>wdadaptivepy Currencies to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/currencies.py</code> <pre><code>def preview_update(\n    self,\n    currencies: Sequence[Currency],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Currency update XML API call for review.\n\n    Args:\n        currencies: wdadaptivepy Currencies to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_currencies = Currency.to_xml(\"update\", currencies)\n    # ET.indent(updated_currencies)\n    # with open(\"test_currencies.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_currencies, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importCurrencies\",\n        payload=updated_currencies,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DataService","title":"<code>DataService</code>","text":"<p>wdadaptivepy Service for Data.</p> <p>Attributes:</p> Name Type Description <code>ExportDataAccountsFilter</code> <p>Adaptive Accounts Filter</p> <code>ExportDataCurrencyFilter</code> <p>Adaptive Currency Filter</p> <code>ExportDataFilter</code> <p>Adaptive Data Filter</p> <code>ExportDataFormat</code> <p>Adaptive Data Format</p> <code>ExportDataRules</code> <p>Adaptive  Rules</p> <code>ExportDataLevelFilter</code> <p>Adaptive Level Filter</p> <code>ExportDataTimeFilter</code> <p>Adaptive Time Filter</p> Source code in <code>src/wdadaptivepy/services/data.py</code> <pre><code>class DataService:\n    \"\"\"wdadaptivepy Service for Data.\n\n    Attributes:\n        ExportDataAccountsFilter: Adaptive Accounts Filter\n        ExportDataCurrencyFilter: Adaptive Currency Filter\n        ExportDataFilter: Adaptive Data Filter\n        ExportDataFormat: Adaptive Data Format\n        ExportDataRules: Adaptive  Rules\n        ExportDataLevelFilter: Adaptive Level Filter\n        ExportDataTimeFilter: Adaptive Time Filter\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize DataService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.ExportDataAccountsFilter = AccountFilter\n        self.ExportDataCurrencyFilter = CurrencyFilter\n        self.ExportDataFilter = ExportDataFilter\n        self.ExportDataFormat = ExportDataFormat\n        self.ExportDataRules = ExportDataRules\n        self.ExportDataLevelFilter = LevelFilter\n        self.ExportDataTimeFilter = TimeFilter\n\n    def _create_dimension_element(self, dimension: Dimension) -&gt; ET.Element:\n        if dimension.name is None:\n            error_message = \"Dimension name cannot be None\"\n            raise ValueError(error_message)\n        return ET.Element(\"dimension\", attrib={\"name\": dimension.name})\n\n    def get_data(  # NOQA: PLR0915, PLR0912\n        self,\n        version: Version,\n        data_filter: ExportDataFilter,\n        data_format: ExportDataFormat | None = None,\n        dimensions: Dimension | list[Dimension] | None = None,\n        rules: ExportDataRules | None = None,\n    ) -&gt; list[dict[str, str | int | float]]:\n        \"\"\"Retrieve Data from Adaptive.\n\n        Args:\n            version: Adaptive Version\n            data_filter: Adaptive Filter\n            data_format: Adaptive Format\n            dimensions: Adaptive Dimensions\n            rules: Adaptive Rules\n\n        Returns:\n            List of rows of data\n\n        Raises:\n            ValueError: Unexpected value\n            RuntimeError: Unexpected error\n\n        \"\"\"\n        if data_format is None:\n            data_format = ExportDataFormat()\n\n        payload: list[ET.Element] = []\n\n        if version.name is None:\n            error_message = \"Expected Version name value\"\n            raise ValueError(error_message)\n        version_element = ET.Element(\"version\", attrib={\"name\": version.name})\n        payload.append(version_element)\n\n        format_element = data_format.to_xml_element()\n        payload.append(format_element)\n\n        filter_element = data_filter.to_xml_element()\n        payload.append(filter_element)\n\n        if dimensions is not None:\n            dimensions_element = ET.Element(\"dimensions\")\n            if isinstance(dimensions, list):\n                for dimension in dimensions:\n                    dimension_element = self._create_dimension_element(dimension)\n                    dimensions_element.append(dimension_element)\n            else:\n                dimension_element = self._create_dimension_element(dimensions)\n                dimensions_element.append(dimension_element)\n            payload.append(dimensions_element)\n        if rules is not None:\n            rules_element = rules.to_xml_element()\n            payload.append(rules_element)\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportData\",\n            payload=payload,\n        )\n\n        received_row_count = -1\n        status_element = response.find(\"status\")\n        if status_element:\n            row_count_sent = status_element.attrib[\"rowCountSent\"]\n            if row_count_sent:\n                received_row_count = int(row_count_sent)\n        data_element = response.find(\"output\")\n        data: list[dict[str, str | int | float]] = []\n        column_headers: Sequence[str] | None = None\n        if data_element is not None and data_element.text is not None:\n            rows = StringIO(data_element.text.lstrip(\"\\n\"))\n            csv_reader = DictReader(rows, lineterminator=\"\\n\")\n            column_headers = csv_reader.fieldnames\n            data = list(csv_reader)\n        if received_row_count &gt; -1 and received_row_count != len(data):\n            error_message = (\n                \"Inconsistent row counts: expected \"\n                f\"{received_row_count}, got {len(data)}\"\n            )\n            raise RuntimeError(error_message)\n\n        if column_headers is not None:\n            period_columns = [\n                period\n                for period in column_headers\n                if not (period.endswith((\" Name\", \" Code\")))\n            ]\n            parsed_data: list[dict[str, str | int | float]] = []\n            for data_row in data:\n                for period in period_columns:\n                    row: dict[str, str | int | float] = {}\n                    for column in column_headers:\n                        if column in period_columns:\n                            break\n                        row[column] = data_row[column]\n                    row[\"Period Code\"] = period\n                    try:\n                        row[\"Amount\"] = int(data_row[period])\n                    except ValueError:\n                        row[\"Amount\"] = float(data_row[period])\n\n                    parsed_data.append(row)\n            return parsed_data\n\n        return data\n\n    def from_modeled_sheet(  # NOQA: PLR0913\n        self,\n        version_name: str,\n        sheet_name: str,\n        *,\n        is_assumption_sheet: bool = False,\n        include_all_columns: bool = True,\n        get_all_rows: bool = True,\n        use_numeric_ids: bool = False,\n        display_name_enabled: bool = True,\n        include_codes: bool = False,\n        include_names: bool = False,\n        include_display_names: bool = False,\n        use_account_precision: bool = False,\n        use_actual_value: bool = False,\n    ) -&gt; list[dict[str, str | int | float | bool | datetime]]:\n        \"\"\"Retrieve Adaptive Data from a Modeled Sheet.\n\n        Args:\n            version_name: Adaptive Version Name\n            sheet_name: Adaptive Sheet Name\n            is_assumption_sheet: Adaptive Is Assumption Sheet\n            include_all_columns: Adaptive Include All Columns\n            get_all_rows: Adaptive Get All Rows\n            use_numeric_ids: Adaptive Use Numeric IDs\n            display_name_enabled: Adaptive Display Name Enabled\n            include_codes: Adaptive Include Codes\n            include_names: Adaptive Include Names\n            include_display_names: Adaptive Include Display Names\n            use_account_precision: Adaptive Use Account Precision\n            use_actual_value: Adaptive Use Actual Value\n\n        Returns:\n            List of rows of data\n\n        \"\"\"\n        version_element = ET.Element(\"version\", attrib={\"name\": version_name})\n        modeled_sheet_element = ET.Element(\n            \"modeled-sheet\",\n            attrib={\n                \"name\": sheet_name,\n                \"isGlobal\": str(bool_to_str_true_false(is_assumption_sheet)),\n                \"includeAllColumns\": str(bool_to_str_true_false(include_all_columns)),\n                \"isGetAllRows\": str(bool_to_str_true_false(get_all_rows)),\n                \"useNumericIDs\": str(bool_to_str_true_false(use_numeric_ids)),\n                \"diplsayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n                \"includeCodes\": str(bool_to_str_true_false(include_codes)),\n                \"includeNames\": str(bool_to_str_true_false(include_names)),\n                \"includeDisplayNames\": str(\n                    bool_to_str_true_false(include_display_names),\n                ),\n                \"useAccountPrecision\": str(\n                    bool_to_str_true_false(use_account_precision),\n                ),\n                \"useActualValue\": str(bool_to_str_true_false(use_actual_value)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportConfigurableModelData\",\n            payload=[version_element, modeled_sheet_element],\n        )\n        data = response.find(\"output/data\")\n        sheet_data: list[dict[str, str | int | float | datetime]] = []\n        if data is not None and data.text is not None:\n            rows = StringIO(data.text.lstrip(\"\\n\"))\n            csv_reader = DictReader(rows, lineterminator=\"\\n\")\n            sheet_data = list(csv_reader)\n\n        return sheet_data\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DataService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize DataService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/data.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize DataService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.ExportDataAccountsFilter = AccountFilter\n    self.ExportDataCurrencyFilter = CurrencyFilter\n    self.ExportDataFilter = ExportDataFilter\n    self.ExportDataFormat = ExportDataFormat\n    self.ExportDataRules = ExportDataRules\n    self.ExportDataLevelFilter = LevelFilter\n    self.ExportDataTimeFilter = TimeFilter\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DataService.from_modeled_sheet","title":"<code>from_modeled_sheet(version_name, sheet_name, *, is_assumption_sheet=False, include_all_columns=True, get_all_rows=True, use_numeric_ids=False, display_name_enabled=True, include_codes=False, include_names=False, include_display_names=False, use_account_precision=False, use_actual_value=False)</code>","text":"<p>Retrieve Adaptive Data from a Modeled Sheet.</p> <p>Parameters:</p> Name Type Description Default <code>version_name</code> <code>str</code> <p>Adaptive Version Name</p> required <code>sheet_name</code> <code>str</code> <p>Adaptive Sheet Name</p> required <code>is_assumption_sheet</code> <code>bool</code> <p>Adaptive Is Assumption Sheet</p> <code>False</code> <code>include_all_columns</code> <code>bool</code> <p>Adaptive Include All Columns</p> <code>True</code> <code>get_all_rows</code> <code>bool</code> <p>Adaptive Get All Rows</p> <code>True</code> <code>use_numeric_ids</code> <code>bool</code> <p>Adaptive Use Numeric IDs</p> <code>False</code> <code>display_name_enabled</code> <code>bool</code> <p>Adaptive Display Name Enabled</p> <code>True</code> <code>include_codes</code> <code>bool</code> <p>Adaptive Include Codes</p> <code>False</code> <code>include_names</code> <code>bool</code> <p>Adaptive Include Names</p> <code>False</code> <code>include_display_names</code> <code>bool</code> <p>Adaptive Include Display Names</p> <code>False</code> <code>use_account_precision</code> <code>bool</code> <p>Adaptive Use Account Precision</p> <code>False</code> <code>use_actual_value</code> <code>bool</code> <p>Adaptive Use Actual Value</p> <code>False</code> <p>Returns:</p> Type Description <code>list[dict[str, str | int | float | bool | datetime]]</code> <p>List of rows of data</p> Source code in <code>src/wdadaptivepy/services/data.py</code> <pre><code>def from_modeled_sheet(  # NOQA: PLR0913\n    self,\n    version_name: str,\n    sheet_name: str,\n    *,\n    is_assumption_sheet: bool = False,\n    include_all_columns: bool = True,\n    get_all_rows: bool = True,\n    use_numeric_ids: bool = False,\n    display_name_enabled: bool = True,\n    include_codes: bool = False,\n    include_names: bool = False,\n    include_display_names: bool = False,\n    use_account_precision: bool = False,\n    use_actual_value: bool = False,\n) -&gt; list[dict[str, str | int | float | bool | datetime]]:\n    \"\"\"Retrieve Adaptive Data from a Modeled Sheet.\n\n    Args:\n        version_name: Adaptive Version Name\n        sheet_name: Adaptive Sheet Name\n        is_assumption_sheet: Adaptive Is Assumption Sheet\n        include_all_columns: Adaptive Include All Columns\n        get_all_rows: Adaptive Get All Rows\n        use_numeric_ids: Adaptive Use Numeric IDs\n        display_name_enabled: Adaptive Display Name Enabled\n        include_codes: Adaptive Include Codes\n        include_names: Adaptive Include Names\n        include_display_names: Adaptive Include Display Names\n        use_account_precision: Adaptive Use Account Precision\n        use_actual_value: Adaptive Use Actual Value\n\n    Returns:\n        List of rows of data\n\n    \"\"\"\n    version_element = ET.Element(\"version\", attrib={\"name\": version_name})\n    modeled_sheet_element = ET.Element(\n        \"modeled-sheet\",\n        attrib={\n            \"name\": sheet_name,\n            \"isGlobal\": str(bool_to_str_true_false(is_assumption_sheet)),\n            \"includeAllColumns\": str(bool_to_str_true_false(include_all_columns)),\n            \"isGetAllRows\": str(bool_to_str_true_false(get_all_rows)),\n            \"useNumericIDs\": str(bool_to_str_true_false(use_numeric_ids)),\n            \"diplsayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            \"includeCodes\": str(bool_to_str_true_false(include_codes)),\n            \"includeNames\": str(bool_to_str_true_false(include_names)),\n            \"includeDisplayNames\": str(\n                bool_to_str_true_false(include_display_names),\n            ),\n            \"useAccountPrecision\": str(\n                bool_to_str_true_false(use_account_precision),\n            ),\n            \"useActualValue\": str(bool_to_str_true_false(use_actual_value)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportConfigurableModelData\",\n        payload=[version_element, modeled_sheet_element],\n    )\n    data = response.find(\"output/data\")\n    sheet_data: list[dict[str, str | int | float | datetime]] = []\n    if data is not None and data.text is not None:\n        rows = StringIO(data.text.lstrip(\"\\n\"))\n        csv_reader = DictReader(rows, lineterminator=\"\\n\")\n        sheet_data = list(csv_reader)\n\n    return sheet_data\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DataService.get_data","title":"<code>get_data(version, data_filter, data_format=None, dimensions=None, rules=None)</code>","text":"<p>Retrieve Data from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>Adaptive Version</p> required <code>data_filter</code> <code>ExportDataFilter</code> <p>Adaptive Filter</p> required <code>data_format</code> <code>ExportDataFormat | None</code> <p>Adaptive Format</p> <code>None</code> <code>dimensions</code> <code>Dimension | list[Dimension] | None</code> <p>Adaptive Dimensions</p> <code>None</code> <code>rules</code> <code>ExportDataRules | None</code> <p>Adaptive Rules</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, str | int | float]]</code> <p>List of rows of data</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Unexpected value</p> <code>RuntimeError</code> <p>Unexpected error</p> Source code in <code>src/wdadaptivepy/services/data.py</code> <pre><code>def get_data(  # NOQA: PLR0915, PLR0912\n    self,\n    version: Version,\n    data_filter: ExportDataFilter,\n    data_format: ExportDataFormat | None = None,\n    dimensions: Dimension | list[Dimension] | None = None,\n    rules: ExportDataRules | None = None,\n) -&gt; list[dict[str, str | int | float]]:\n    \"\"\"Retrieve Data from Adaptive.\n\n    Args:\n        version: Adaptive Version\n        data_filter: Adaptive Filter\n        data_format: Adaptive Format\n        dimensions: Adaptive Dimensions\n        rules: Adaptive Rules\n\n    Returns:\n        List of rows of data\n\n    Raises:\n        ValueError: Unexpected value\n        RuntimeError: Unexpected error\n\n    \"\"\"\n    if data_format is None:\n        data_format = ExportDataFormat()\n\n    payload: list[ET.Element] = []\n\n    if version.name is None:\n        error_message = \"Expected Version name value\"\n        raise ValueError(error_message)\n    version_element = ET.Element(\"version\", attrib={\"name\": version.name})\n    payload.append(version_element)\n\n    format_element = data_format.to_xml_element()\n    payload.append(format_element)\n\n    filter_element = data_filter.to_xml_element()\n    payload.append(filter_element)\n\n    if dimensions is not None:\n        dimensions_element = ET.Element(\"dimensions\")\n        if isinstance(dimensions, list):\n            for dimension in dimensions:\n                dimension_element = self._create_dimension_element(dimension)\n                dimensions_element.append(dimension_element)\n        else:\n            dimension_element = self._create_dimension_element(dimensions)\n            dimensions_element.append(dimension_element)\n        payload.append(dimensions_element)\n    if rules is not None:\n        rules_element = rules.to_xml_element()\n        payload.append(rules_element)\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportData\",\n        payload=payload,\n    )\n\n    received_row_count = -1\n    status_element = response.find(\"status\")\n    if status_element:\n        row_count_sent = status_element.attrib[\"rowCountSent\"]\n        if row_count_sent:\n            received_row_count = int(row_count_sent)\n    data_element = response.find(\"output\")\n    data: list[dict[str, str | int | float]] = []\n    column_headers: Sequence[str] | None = None\n    if data_element is not None and data_element.text is not None:\n        rows = StringIO(data_element.text.lstrip(\"\\n\"))\n        csv_reader = DictReader(rows, lineterminator=\"\\n\")\n        column_headers = csv_reader.fieldnames\n        data = list(csv_reader)\n    if received_row_count &gt; -1 and received_row_count != len(data):\n        error_message = (\n            \"Inconsistent row counts: expected \"\n            f\"{received_row_count}, got {len(data)}\"\n        )\n        raise RuntimeError(error_message)\n\n    if column_headers is not None:\n        period_columns = [\n            period\n            for period in column_headers\n            if not (period.endswith((\" Name\", \" Code\")))\n        ]\n        parsed_data: list[dict[str, str | int | float]] = []\n        for data_row in data:\n            for period in period_columns:\n                row: dict[str, str | int | float] = {}\n                for column in column_headers:\n                    if column in period_columns:\n                        break\n                    row[column] = data_row[column]\n                row[\"Period Code\"] = period\n                try:\n                    row[\"Amount\"] = int(data_row[period])\n                except ValueError:\n                    row[\"Amount\"] = float(data_row[period])\n\n                parsed_data.append(row)\n        return parsed_data\n\n    return data\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DimensionService","title":"<code>DimensionService</code>","text":"<p>Create, retrieve, and modify Adaptive Dimensions.</p> <p>Attributes:</p> Name Type Description <code>Dimension</code> <p>wdadaptivepy Dimension</p> Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>class DimensionService:\n    \"\"\"Create, retrieve, and modify Adaptive Dimensions.\n\n    Attributes:\n        Dimension: wdadaptivepy Dimension\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize DimensionService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Dimension = Dimension\n\n    def get_all(\n        self,\n        *,\n        attributes: bool = True,\n        dimension_values: bool = True,\n        display_name_enabled: bool = True,\n    ) -&gt; MetadataList[Dimension]:\n        \"\"\"Retrieve all Dimensions from Adaptive.\n\n        Args:\n            attributes: Adaptive Attributes\n            dimension_values: Adaptive Dimension Values\n            display_name_enabled: Adaptive Display Name Enabled\n\n        Returns:\n            adaptive Dimensions\n\n        \"\"\"\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"attributes\": str(bool_to_str_true_false(attributes)),\n                \"dimensionValues\": str(bool_to_str_true_false(dimension_values)),\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportDimensions\",\n            payload=include,\n        )\n        return MetadataList[Dimension](Dimension.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        dimensions: Sequence[Dimension],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Dimension update XML API call for review.\n\n        Args:\n            dimensions: wdadaptivepy Dimensions to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_dimensions = Dimension.to_xml(\"update\", dimensions)\n        # ET.indent(updated_dimensions)\n        # with open(\"test_dimensions.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_dimensions, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importDimensions\",\n            payload=updated_dimensions,\n            hide_password=hide_password,\n        )\n\n    def get(  # NOQA: PLR0913\n        self,\n        dimensions: Sequence[Dimension] = [],\n        dimension_ids: Sequence[int] = [],\n        dimension_names: Sequence[str] = [],\n        *,\n        attributes: bool = True,\n        dimension_values: bool = True,\n        display_name_enabled: bool = True,\n    ) -&gt; MetadataList[Dimension]:\n        \"\"\"Retrieve Dimensions from Adaptive with additional filters.\n\n        Args:\n            dimensions: Adaptive Dimensions\n            dimension_ids: Adaptive Dimension IDs\n            dimension_names: Adaptive Dimension Names\n            attributes: Adaptive Attributes\n            dimension_values: Adaptive Dimension Values\n            display_name_enabled: Adaptive Display Name Enabled\n\n        Returns:\n            adaptive Dimensions\n\n        \"\"\"\n        ids: list[int] = []\n        if dimensions:\n            ids.extend(\n                [dimension.id for dimension in dimensions if dimension.id is not None],\n            )\n        elif dimension_ids:\n            ids.extend(dimension_ids)\n        elif dimension_names:\n            all_dimensions = self.get_all(dimension_values=False)\n            for name in dimension_names:\n                ids.extend(\n                    [\n                        dimension.id\n                        for dimension in all_dimensions\n                        if dimension.name == name and dimension.id is not None\n                    ],\n                )\n        else:\n            raise ValueError\n        if not ids:\n            raise ValueError\n\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"dimensionIDs\": \",\".join(str(dimension_id) for dimension_id in ids),\n                \"attributes\": str(bool_to_str_true_false(attributes)),\n                \"dimensionValues\": str(bool_to_str_true_false(dimension_values)),\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportDimensions\",\n            payload=include,\n        )\n        return MetadataList[Dimension](Dimension.from_xml(xml=response))\n\n    def from_json(self, data: str) -&gt; MetadataList[Dimension]:\n        \"\"\"Convert JSON to MetadataList of Dimensions.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Dimensions\n\n        \"\"\"\n        return MetadataList[Dimension](Dimension.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Dimension]:\n        \"\"\"Convert Python Dictionary to MetadataList of Dimensions.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Dimensions\n\n        \"\"\"\n        return MetadataList[Dimension](Dimension.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DimensionService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize DimensionService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize DimensionService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Dimension = Dimension\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DimensionService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Dimension]</code> <p>MetadataList of Dimensions</p> Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Dimension]:\n    \"\"\"Convert Python Dictionary to MetadataList of Dimensions.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Dimensions\n\n    \"\"\"\n    return MetadataList[Dimension](Dimension.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DimensionService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[Dimension]</code> <p>MetadataList of Dimensions</p> Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Dimension]:\n    \"\"\"Convert JSON to MetadataList of Dimensions.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Dimensions\n\n    \"\"\"\n    return MetadataList[Dimension](Dimension.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DimensionService.get","title":"<code>get(dimensions=[], dimension_ids=[], dimension_names=[], *, attributes=True, dimension_values=True, display_name_enabled=True)</code>","text":"<p>Retrieve Dimensions from Adaptive with additional filters.</p> <p>Parameters:</p> Name Type Description Default <code>dimensions</code> <code>Sequence[Dimension]</code> <p>Adaptive Dimensions</p> <code>[]</code> <code>dimension_ids</code> <code>Sequence[int]</code> <p>Adaptive Dimension IDs</p> <code>[]</code> <code>dimension_names</code> <code>Sequence[str]</code> <p>Adaptive Dimension Names</p> <code>[]</code> <code>attributes</code> <code>bool</code> <p>Adaptive Attributes</p> <code>True</code> <code>dimension_values</code> <code>bool</code> <p>Adaptive Dimension Values</p> <code>True</code> <code>display_name_enabled</code> <code>bool</code> <p>Adaptive Display Name Enabled</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[Dimension]</code> <p>adaptive Dimensions</p> Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>def get(  # NOQA: PLR0913\n    self,\n    dimensions: Sequence[Dimension] = [],\n    dimension_ids: Sequence[int] = [],\n    dimension_names: Sequence[str] = [],\n    *,\n    attributes: bool = True,\n    dimension_values: bool = True,\n    display_name_enabled: bool = True,\n) -&gt; MetadataList[Dimension]:\n    \"\"\"Retrieve Dimensions from Adaptive with additional filters.\n\n    Args:\n        dimensions: Adaptive Dimensions\n        dimension_ids: Adaptive Dimension IDs\n        dimension_names: Adaptive Dimension Names\n        attributes: Adaptive Attributes\n        dimension_values: Adaptive Dimension Values\n        display_name_enabled: Adaptive Display Name Enabled\n\n    Returns:\n        adaptive Dimensions\n\n    \"\"\"\n    ids: list[int] = []\n    if dimensions:\n        ids.extend(\n            [dimension.id for dimension in dimensions if dimension.id is not None],\n        )\n    elif dimension_ids:\n        ids.extend(dimension_ids)\n    elif dimension_names:\n        all_dimensions = self.get_all(dimension_values=False)\n        for name in dimension_names:\n            ids.extend(\n                [\n                    dimension.id\n                    for dimension in all_dimensions\n                    if dimension.name == name and dimension.id is not None\n                ],\n            )\n    else:\n        raise ValueError\n    if not ids:\n        raise ValueError\n\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"dimensionIDs\": \",\".join(str(dimension_id) for dimension_id in ids),\n            \"attributes\": str(bool_to_str_true_false(attributes)),\n            \"dimensionValues\": str(bool_to_str_true_false(dimension_values)),\n            \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportDimensions\",\n        payload=include,\n    )\n    return MetadataList[Dimension](Dimension.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DimensionService.get_all","title":"<code>get_all(*, attributes=True, dimension_values=True, display_name_enabled=True)</code>","text":"<p>Retrieve all Dimensions from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>bool</code> <p>Adaptive Attributes</p> <code>True</code> <code>dimension_values</code> <code>bool</code> <p>Adaptive Dimension Values</p> <code>True</code> <code>display_name_enabled</code> <code>bool</code> <p>Adaptive Display Name Enabled</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[Dimension]</code> <p>adaptive Dimensions</p> Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>def get_all(\n    self,\n    *,\n    attributes: bool = True,\n    dimension_values: bool = True,\n    display_name_enabled: bool = True,\n) -&gt; MetadataList[Dimension]:\n    \"\"\"Retrieve all Dimensions from Adaptive.\n\n    Args:\n        attributes: Adaptive Attributes\n        dimension_values: Adaptive Dimension Values\n        display_name_enabled: Adaptive Display Name Enabled\n\n    Returns:\n        adaptive Dimensions\n\n    \"\"\"\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"attributes\": str(bool_to_str_true_false(attributes)),\n            \"dimensionValues\": str(bool_to_str_true_false(dimension_values)),\n            \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportDimensions\",\n        payload=include,\n    )\n    return MetadataList[Dimension](Dimension.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DimensionService.preview_update","title":"<code>preview_update(dimensions, *, hide_password=True)</code>","text":"<p>Generate Dimension update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>dimensions</code> <code>Sequence[Dimension]</code> <p>wdadaptivepy Dimensions to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>def preview_update(\n    self,\n    dimensions: Sequence[Dimension],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Dimension update XML API call for review.\n\n    Args:\n        dimensions: wdadaptivepy Dimensions to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_dimensions = Dimension.to_xml(\"update\", dimensions)\n    # ET.indent(updated_dimensions)\n    # with open(\"test_dimensions.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_dimensions, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importDimensions\",\n        payload=updated_dimensions,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DimensionValueService","title":"<code>DimensionValueService</code>","text":"<p>Create, retrieve, and modify Adaptive Dimensions.</p> <p>Attributes:</p> Name Type Description <code>Dimension</code> <p>wdadaptivepy Dimension</p> Source code in <code>src/wdadaptivepy/services/dimension_values.py</code> <pre><code>class DimensionValueService:\n    \"\"\"Create, retrieve, and modify Adaptive Dimensions.\n\n    Attributes:\n        Dimension: wdadaptivepy Dimension\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize DimensionService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.DimensionValue = DimensionValue\n\n    def get_all(\n        self,\n        dimension: Dimension | str | int,\n        *,\n        attributes: bool = True,\n        display_name_enabled: bool = True,\n    ) -&gt; MetadataList[DimensionValue]:\n        \"\"\"Retrieve all Dimension Values from Adaptive.\n\n        Args:\n            dimension: Adaptive Dimension\n            attributes: Adaptive Attributes\n            display_name_enabled: Adaptive Display Name Enabled\n\n        Returns:\n            adaptive Dimension Values\n\n        \"\"\"\n        get_dimension = self.__find_dimension(dimension)\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"dimensionIDs\": str(get_dimension.id),\n                \"attributes\": str(bool_to_str_true_false(attributes)),\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportDimensions\",\n            payload=include,\n        )\n        return MetadataList[DimensionValue](DimensionValue.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        dimension: Dimension | str | int,\n        dimension_values: Sequence[DimensionValue],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Dimension Value update XML API call for review.\n\n        Args:\n            dimension: wdadaptivepy Dimension to update\n            dimension_values: wdadaptivepy Dimension Values to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        method, payload = self.__build_update_payload(dimension, dimension_values)\n        # ET.indent(updated_dimensions)\n        # with open(\"test_dimensions.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(update_dimension, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=method,\n            payload=payload,\n            hide_password=hide_password,\n        )\n\n    def __build_update_payload(\n        self,\n        dimension: Dimension | int | str,\n        dimension_values: Sequence[DimensionValue],\n    ) -&gt; tuple[str, ET.Element]:\n        for dimension_value in dimension_values:\n            if dimension_value.id is None or dimension_value.id == 0:\n                raise ValueError\n        found_dimension = self.__find_dimension(dimension)\n        update_dimensions = Dimension.to_xml(\n            \"update\",\n            [Dimension(id=found_dimension.id)],\n        )\n        update_dimension = update_dimensions.find(\"dimension\")\n        if update_dimension is None:\n            raise ValueError\n        update_dimension.extend(DimensionValue.to_xml(\"update\", dimension_values))\n        return \"updateDimensions\", update_dimensions\n\n    def __find_dimension(self, dimension: Dimension | int | str) -&gt; Dimension:  # NOQA: PLR0912\n        search_dimension = None\n        if isinstance(dimension, Dimension):\n            search_dimension = dimension\n        elif isinstance(dimension, int):\n            search_dimension = Dimension(id=dimension)\n        elif isinstance(dimension, str):\n            search_dimension = Dimension(code=dimension, name=dimension)\n        else:\n            raise TypeError\n\n        dimensions_include = ET.Element(\n            \"include\",\n            attrib={\n                \"attributes\": str(bool_to_str_true_false(value=False)),\n                \"dimensionValues\": str(bool_to_str_true_false(value=False)),\n                \"displayNameEnabled\": str(bool_to_str_true_false(value=True)),\n            },\n        )\n        dimensions_response = self.__xml_api.make_xml_request(\n            method=\"exportDimensions\",\n            payload=dimensions_include,\n        )\n        all_dimensions = MetadataList[Dimension](\n            Dimension.from_xml(xml=dimensions_response),\n        )\n\n        found_dimension = None\n        if search_dimension.id is not None and search_dimension.id != 0:\n            for dim in all_dimensions:\n                if dim.id == search_dimension.id:\n                    found_dimension = dim\n                    break\n        else:\n            for dim in all_dimensions:\n                if dim.code == search_dimension.code:\n                    found_dimension = dim\n                    break\n            if search_dimension is None:\n                for dim in all_dimensions:\n                    if dim.name == search_dimension.name:\n                        found_dimension = dim\n                        break\n\n        if found_dimension is None:\n            raise ValueError\n\n        return found_dimension\n\n    def from_json(self, data: str) -&gt; MetadataList[DimensionValue]:\n        \"\"\"Convert JSON to MetadataList of Dimension Values.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Dimension Values\n\n        \"\"\"\n        return MetadataList[DimensionValue](DimensionValue.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[DimensionValue]:\n        \"\"\"Convert Python Dictionary to MetadataList of Dimension Values.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Dimension Values\n\n        \"\"\"\n        return MetadataList[DimensionValue](DimensionValue.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DimensionValueService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize DimensionService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/dimension_values.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize DimensionService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.DimensionValue = DimensionValue\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DimensionValueService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Dimension Values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[DimensionValue]</code> <p>MetadataList of Dimension Values</p> Source code in <code>src/wdadaptivepy/services/dimension_values.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[DimensionValue]:\n    \"\"\"Convert Python Dictionary to MetadataList of Dimension Values.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Dimension Values\n\n    \"\"\"\n    return MetadataList[DimensionValue](DimensionValue.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DimensionValueService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Dimension Values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[DimensionValue]</code> <p>MetadataList of Dimension Values</p> Source code in <code>src/wdadaptivepy/services/dimension_values.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[DimensionValue]:\n    \"\"\"Convert JSON to MetadataList of Dimension Values.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Dimension Values\n\n    \"\"\"\n    return MetadataList[DimensionValue](DimensionValue.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DimensionValueService.get_all","title":"<code>get_all(dimension, *, attributes=True, display_name_enabled=True)</code>","text":"<p>Retrieve all Dimension Values from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>Dimension | str | int</code> <p>Adaptive Dimension</p> required <code>attributes</code> <code>bool</code> <p>Adaptive Attributes</p> <code>True</code> <code>display_name_enabled</code> <code>bool</code> <p>Adaptive Display Name Enabled</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[DimensionValue]</code> <p>adaptive Dimension Values</p> Source code in <code>src/wdadaptivepy/services/dimension_values.py</code> <pre><code>def get_all(\n    self,\n    dimension: Dimension | str | int,\n    *,\n    attributes: bool = True,\n    display_name_enabled: bool = True,\n) -&gt; MetadataList[DimensionValue]:\n    \"\"\"Retrieve all Dimension Values from Adaptive.\n\n    Args:\n        dimension: Adaptive Dimension\n        attributes: Adaptive Attributes\n        display_name_enabled: Adaptive Display Name Enabled\n\n    Returns:\n        adaptive Dimension Values\n\n    \"\"\"\n    get_dimension = self.__find_dimension(dimension)\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"dimensionIDs\": str(get_dimension.id),\n            \"attributes\": str(bool_to_str_true_false(attributes)),\n            \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportDimensions\",\n        payload=include,\n    )\n    return MetadataList[DimensionValue](DimensionValue.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.DimensionValueService.preview_update","title":"<code>preview_update(dimension, dimension_values, *, hide_password=True)</code>","text":"<p>Generate Dimension Value update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>Dimension | str | int</code> <p>wdadaptivepy Dimension to update</p> required <code>dimension_values</code> <code>Sequence[DimensionValue]</code> <p>wdadaptivepy Dimension Values to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/dimension_values.py</code> <pre><code>def preview_update(\n    self,\n    dimension: Dimension | str | int,\n    dimension_values: Sequence[DimensionValue],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Dimension Value update XML API call for review.\n\n    Args:\n        dimension: wdadaptivepy Dimension to update\n        dimension_values: wdadaptivepy Dimension Values to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    method, payload = self.__build_update_payload(dimension, dimension_values)\n    # ET.indent(updated_dimensions)\n    # with open(\"test_dimensions.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(update_dimension, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=method,\n        payload=payload,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.GroupService","title":"<code>GroupService</code>","text":"<p>Create, retrieve, and modify Adaptive Grups.</p> <p>Attributes:</p> Name Type Description <code>Group</code> <p>wdadaptivepy Group</p> Source code in <code>src/wdadaptivepy/services/groups.py</code> <pre><code>class GroupService:\n    \"\"\"Create, retrieve, and modify Adaptive Grups.\n\n    Attributes:\n        Group: wdadaptivepy Group\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize GroupService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Group = Group\n\n    def get_all(self) -&gt; MetadataList[Group]:\n        \"\"\"Retrieve all Groups from Adaptive.\n\n        Returns:\n            adaptive Groups\n\n        \"\"\"\n        response = self.__xml_api.make_xml_request(method=\"exportGroups\", payload=None)\n        return MetadataList[Group](Group.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        groups: Sequence[Group],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Group update XML API call for review.\n\n        Args:\n            groups: wdadaptivepy Groups to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n           XML API body\n\n        \"\"\"\n        updated_groups = Group.to_xml(\"update\", groups)\n        # ET.indent(updated_groups)\n        # with open(\"test_groups.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_groups, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importGroups\",\n            payload=updated_groups,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[Group]:\n        \"\"\"Convert JSON to MetadataList of Groups.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Groups\n\n        \"\"\"\n        return MetadataList[Group](Group.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Group]:\n        \"\"\"Convert Python Dictionary to MetadataList of Groups.\n\n        Args:\n            data: Pytho Dictionary\n\n        Returns:\n            MetadataList of Groups\n\n        \"\"\"\n        return MetadataList[Group](Group.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.GroupService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize GroupService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/groups.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize GroupService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Group = Group\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.GroupService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Groups.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Pytho Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Group]</code> <p>MetadataList of Groups</p> Source code in <code>src/wdadaptivepy/services/groups.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Group]:\n    \"\"\"Convert Python Dictionary to MetadataList of Groups.\n\n    Args:\n        data: Pytho Dictionary\n\n    Returns:\n        MetadataList of Groups\n\n    \"\"\"\n    return MetadataList[Group](Group.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.GroupService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Groups.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[Group]</code> <p>MetadataList of Groups</p> Source code in <code>src/wdadaptivepy/services/groups.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Group]:\n    \"\"\"Convert JSON to MetadataList of Groups.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Groups\n\n    \"\"\"\n    return MetadataList[Group](Group.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.GroupService.get_all","title":"<code>get_all()</code>","text":"<p>Retrieve all Groups from Adaptive.</p> <p>Returns:</p> Type Description <code>MetadataList[Group]</code> <p>adaptive Groups</p> Source code in <code>src/wdadaptivepy/services/groups.py</code> <pre><code>def get_all(self) -&gt; MetadataList[Group]:\n    \"\"\"Retrieve all Groups from Adaptive.\n\n    Returns:\n        adaptive Groups\n\n    \"\"\"\n    response = self.__xml_api.make_xml_request(method=\"exportGroups\", payload=None)\n    return MetadataList[Group](Group.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.GroupService.preview_update","title":"<code>preview_update(groups, *, hide_password=True)</code>","text":"<p>Generate Group update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>Sequence[Group]</code> <p>wdadaptivepy Groups to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/groups.py</code> <pre><code>def preview_update(\n    self,\n    groups: Sequence[Group],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Group update XML API call for review.\n\n    Args:\n        groups: wdadaptivepy Groups to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n       XML API body\n\n    \"\"\"\n    updated_groups = Group.to_xml(\"update\", groups)\n    # ET.indent(updated_groups)\n    # with open(\"test_groups.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_groups, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importGroups\",\n        payload=updated_groups,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.LevelService","title":"<code>LevelService</code>","text":"<p>Create, retrieve, and modify Adaptive Levels.</p> <p>Attributes:</p> Name Type Description <code>Level</code> <p>wdadaptivepylevel</p> Source code in <code>src/wdadaptivepy/services/levels.py</code> <pre><code>class LevelService:\n    \"\"\"Create, retrieve, and modify Adaptive Levels.\n\n    Attributes:\n        Level: wdadaptivepylevel\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize LevelService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Level = Level\n\n    def get_all(self, *, display_name_enabled: bool = True) -&gt; MetadataList[Level]:\n        \"\"\"Retrieve all Levels from Adaptive.\n\n        Args:\n            display_name_enabled: Adaptive Display Name Enabled\n\n        Returns:\n            adaptive Levels\n\n        \"\"\"\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportLevels\",\n            payload=include,\n        )\n        return MetadataList[Level](Level.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        levels: Sequence[Level],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Level update XML API call for review.\n\n        Args:\n            levels: wdadaptivepy Levels to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_levels = Level.to_xml(\"update\", levels)\n        # ET.indent(updated_levels)\n        # with open(\"test_levels.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_levels, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importLevels\",\n            payload=updated_levels,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[Level]:\n        \"\"\"Convert JSON to MetadataList of Levels.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Levels\n\n        \"\"\"\n        return MetadataList[Level](Level.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Level]:\n        \"\"\"Convert Python Dictionary to MetadataList of Levels.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Levels\n\n        \"\"\"\n        return MetadataList[Level](Level.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.LevelService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize LevelService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/levels.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize LevelService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Level = Level\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.LevelService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Levels.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Level]</code> <p>MetadataList of Levels</p> Source code in <code>src/wdadaptivepy/services/levels.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Level]:\n    \"\"\"Convert Python Dictionary to MetadataList of Levels.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Levels\n\n    \"\"\"\n    return MetadataList[Level](Level.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.LevelService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Levels.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[Level]</code> <p>MetadataList of Levels</p> Source code in <code>src/wdadaptivepy/services/levels.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Level]:\n    \"\"\"Convert JSON to MetadataList of Levels.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Levels\n\n    \"\"\"\n    return MetadataList[Level](Level.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.LevelService.get_all","title":"<code>get_all(*, display_name_enabled=True)</code>","text":"<p>Retrieve all Levels from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>display_name_enabled</code> <code>bool</code> <p>Adaptive Display Name Enabled</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[Level]</code> <p>adaptive Levels</p> Source code in <code>src/wdadaptivepy/services/levels.py</code> <pre><code>def get_all(self, *, display_name_enabled: bool = True) -&gt; MetadataList[Level]:\n    \"\"\"Retrieve all Levels from Adaptive.\n\n    Args:\n        display_name_enabled: Adaptive Display Name Enabled\n\n    Returns:\n        adaptive Levels\n\n    \"\"\"\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportLevels\",\n        payload=include,\n    )\n    return MetadataList[Level](Level.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.LevelService.preview_update","title":"<code>preview_update(levels, *, hide_password=True)</code>","text":"<p>Generate Level update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>levels</code> <code>Sequence[Level]</code> <p>wdadaptivepy Levels to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/levels.py</code> <pre><code>def preview_update(\n    self,\n    levels: Sequence[Level],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Level update XML API call for review.\n\n    Args:\n        levels: wdadaptivepy Levels to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_levels = Level.to_xml(\"update\", levels)\n    # ET.indent(updated_levels)\n    # with open(\"test_levels.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_levels, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importLevels\",\n        payload=updated_levels,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.PermissionSetService","title":"<code>PermissionSetService</code>","text":"<p>Create, retrieve, and modify Adaptive Permission Sets.</p> <p>Attributes:</p> Name Type Description <code>PermissionSet</code> <p>wdadaptivepy Permission Set</p> Source code in <code>src/wdadaptivepy/services/permission_sets.py</code> <pre><code>class PermissionSetService:\n    \"\"\"Create, retrieve, and modify Adaptive Permission Sets.\n\n    Attributes:\n        PermissionSet: wdadaptivepy Permission Set\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize PermissionSetService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.PermissionSet = PermissionSet\n\n    def get_all(self) -&gt; MetadataList[PermissionSet]:\n        \"\"\"Retrieve all Permission Sets from Adaptive.\n\n        Returns:\n            adaptive Permission Sets\n\n        \"\"\"\n        response = self.__xml_api.make_xml_request(\n            method=\"exportPermissionSets\",\n            payload=None,\n        )\n        return MetadataList[PermissionSet](PermissionSet.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        permission_sets: Sequence[PermissionSet],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Permission Set update XML API call for review.\n\n        Args:\n            permission_sets: wdadaptivepy Permission Sets to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_permission_sets = PermissionSet.to_xml(\"update\", permission_sets)\n        # ET.indent(updated_permission_sets)\n        # with open(\"test_permission_sets.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_permission_sets, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importPermissionSets\",\n            payload=updated_permission_sets,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[PermissionSet]:\n        \"\"\"Convert JSON to MetadataList of Permission Sets.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Permission Sets\n\n        \"\"\"\n        return MetadataList[PermissionSet](PermissionSet.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[PermissionSet]:\n        \"\"\"Convert Python Dictionary to MetadataList of Permission Sets.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Permission Sets\n\n        \"\"\"\n        return MetadataList[PermissionSet](PermissionSet.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.PermissionSetService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize PermissionSetService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/permission_sets.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize PermissionSetService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.PermissionSet = PermissionSet\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.PermissionSetService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Permission Sets.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[PermissionSet]</code> <p>MetadataList of Permission Sets</p> Source code in <code>src/wdadaptivepy/services/permission_sets.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[PermissionSet]:\n    \"\"\"Convert Python Dictionary to MetadataList of Permission Sets.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Permission Sets\n\n    \"\"\"\n    return MetadataList[PermissionSet](PermissionSet.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.PermissionSetService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Permission Sets.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[PermissionSet]</code> <p>MetadataList of Permission Sets</p> Source code in <code>src/wdadaptivepy/services/permission_sets.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[PermissionSet]:\n    \"\"\"Convert JSON to MetadataList of Permission Sets.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Permission Sets\n\n    \"\"\"\n    return MetadataList[PermissionSet](PermissionSet.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.PermissionSetService.get_all","title":"<code>get_all()</code>","text":"<p>Retrieve all Permission Sets from Adaptive.</p> <p>Returns:</p> Type Description <code>MetadataList[PermissionSet]</code> <p>adaptive Permission Sets</p> Source code in <code>src/wdadaptivepy/services/permission_sets.py</code> <pre><code>def get_all(self) -&gt; MetadataList[PermissionSet]:\n    \"\"\"Retrieve all Permission Sets from Adaptive.\n\n    Returns:\n        adaptive Permission Sets\n\n    \"\"\"\n    response = self.__xml_api.make_xml_request(\n        method=\"exportPermissionSets\",\n        payload=None,\n    )\n    return MetadataList[PermissionSet](PermissionSet.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.PermissionSetService.preview_update","title":"<code>preview_update(permission_sets, *, hide_password=True)</code>","text":"<p>Generate Permission Set update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>permission_sets</code> <code>Sequence[PermissionSet]</code> <p>wdadaptivepy Permission Sets to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/permission_sets.py</code> <pre><code>def preview_update(\n    self,\n    permission_sets: Sequence[PermissionSet],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Permission Set update XML API call for review.\n\n    Args:\n        permission_sets: wdadaptivepy Permission Sets to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_permission_sets = PermissionSet.to_xml(\"update\", permission_sets)\n    # ET.indent(updated_permission_sets)\n    # with open(\"test_permission_sets.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_permission_sets, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importPermissionSets\",\n        payload=updated_permission_sets,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.TimeService","title":"<code>TimeService</code>","text":"<p>Create, retrieve, and modify Adaptive Time.</p> <p>Attributes:</p> Name Type Description <code>Time</code> <p>wdadaptivepy Time</p> <code>Period</code> <p>wdadaptivepy Period</p> <code>Stratum</code> <p>wdadaptivepy Stratum</p> Source code in <code>src/wdadaptivepy/services/time.py</code> <pre><code>class TimeService:\n    \"\"\"Create, retrieve, and modify Adaptive Time.\n\n    Attributes:\n        Time: wdadaptivepy Time\n        Period: wdadaptivepy Period\n        Stratum: wdadaptivepy Stratum\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize TimeService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Time = Time\n        self.Period = Period\n        self.Stratum = Stratum\n\n    def get_all(\n        self,\n        *,\n        include_all_locales: bool = False,\n        include_legacy_information: bool = False,\n    ) -&gt; MetadataList[Time]:\n        \"\"\"Retrieve all Time from Adaptive.\n\n        Args:\n            include_all_locales: Adaptive Include All Locales\n            include_legacy_information: Adaptive Include Legacy Information\n\n        Returns:\n            adaptive Time\n\n        \"\"\"\n        options = ET.Element(\n            \"options\",\n            attrib={\n                \"includeAllLocales\": str(bool_to_str_one_zero(include_all_locales)),\n                \"includeLegacyInformation\": str(\n                    bool_to_str_one_zero(include_legacy_information),\n                ),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(method=\"exportTime\", payload=options)\n        return MetadataList[Time](Time.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        times: Sequence[Time],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Time update XML API call for review.\n\n        Args:\n            times: wdadaptivepy Time to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_times = Time.to_xml(\"update\", times)\n        # ET.indent(updated_times)\n        # with open(\"test_time.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_times, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importTime\",\n            payload=updated_times,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[Time]:\n        \"\"\"Convert JSON to MetadataList of Time.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Time\n\n        \"\"\"\n        return MetadataList[Time](Time.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Time]:\n        \"\"\"Convert Python Dictionary to MetadataList of Time.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Time\n\n        \"\"\"\n        return MetadataList[Time](Time.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.TimeService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize TimeService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/time.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize TimeService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Time = Time\n    self.Period = Period\n    self.Stratum = Stratum\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.TimeService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Time.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Time]</code> <p>MetadataList of Time</p> Source code in <code>src/wdadaptivepy/services/time.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Time]:\n    \"\"\"Convert Python Dictionary to MetadataList of Time.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Time\n\n    \"\"\"\n    return MetadataList[Time](Time.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.TimeService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Time.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[Time]</code> <p>MetadataList of Time</p> Source code in <code>src/wdadaptivepy/services/time.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Time]:\n    \"\"\"Convert JSON to MetadataList of Time.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Time\n\n    \"\"\"\n    return MetadataList[Time](Time.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.TimeService.get_all","title":"<code>get_all(*, include_all_locales=False, include_legacy_information=False)</code>","text":"<p>Retrieve all Time from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>include_all_locales</code> <code>bool</code> <p>Adaptive Include All Locales</p> <code>False</code> <code>include_legacy_information</code> <code>bool</code> <p>Adaptive Include Legacy Information</p> <code>False</code> <p>Returns:</p> Type Description <code>MetadataList[Time]</code> <p>adaptive Time</p> Source code in <code>src/wdadaptivepy/services/time.py</code> <pre><code>def get_all(\n    self,\n    *,\n    include_all_locales: bool = False,\n    include_legacy_information: bool = False,\n) -&gt; MetadataList[Time]:\n    \"\"\"Retrieve all Time from Adaptive.\n\n    Args:\n        include_all_locales: Adaptive Include All Locales\n        include_legacy_information: Adaptive Include Legacy Information\n\n    Returns:\n        adaptive Time\n\n    \"\"\"\n    options = ET.Element(\n        \"options\",\n        attrib={\n            \"includeAllLocales\": str(bool_to_str_one_zero(include_all_locales)),\n            \"includeLegacyInformation\": str(\n                bool_to_str_one_zero(include_legacy_information),\n            ),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(method=\"exportTime\", payload=options)\n    return MetadataList[Time](Time.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.TimeService.preview_update","title":"<code>preview_update(times, *, hide_password=True)</code>","text":"<p>Generate Time update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>times</code> <code>Sequence[Time]</code> <p>wdadaptivepy Time to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/time.py</code> <pre><code>def preview_update(\n    self,\n    times: Sequence[Time],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Time update XML API call for review.\n\n    Args:\n        times: wdadaptivepy Time to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_times = Time.to_xml(\"update\", times)\n    # ET.indent(updated_times)\n    # with open(\"test_time.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_times, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importTime\",\n        payload=updated_times,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.UserService","title":"<code>UserService</code>","text":"<p>Create, retrieve, and modify Adaptive Users.</p> <p>Attributes:</p> Name Type Description <code>User</code> <p>wdadaptivepy User</p> Source code in <code>src/wdadaptivepy/services/users.py</code> <pre><code>class UserService:\n    \"\"\"Create, retrieve, and modify Adaptive Users.\n\n    Attributes:\n        User: wdadaptivepy User\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize UserService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.User = User\n\n    def get_all(\n        self,\n        *,\n        groups: bool = True,\n        owned_levels: bool = True,\n    ) -&gt; MetadataList[User]:\n        \"\"\"Retrieve all Users from Adaptive.\n\n        Args:\n            groups: Adaptive Groups\n            owned_levels: Adaptive Owned Levels\n\n        Returns:\n            adaptive Users\n\n        \"\"\"\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"groups\": str(bool_to_str_true_false(groups)),\n                \"ownedLevels\": str(bool_to_str_true_false(owned_levels)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportUsers\",\n            payload=include,\n        )\n        return MetadataList[User](User.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        users: Sequence[User],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate User update XML API call for review.\n\n        Args:\n            users: wdadaptivepy Users to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_users = User.to_xml(\"update\", users)\n        # ET.indent(updated_users)\n        # with open(\"test_users.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_users, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importUsers\",\n            payload=updated_users,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[User]:\n        \"\"\"Convert JSON to MetadataList of Users.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Users\n\n        \"\"\"\n        return MetadataList[User](User.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[User]:\n        \"\"\"Convert Python Dictionary to MetadataList of Users.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Users\n\n        \"\"\"\n        return MetadataList[User](User.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.UserService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize UserService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/users.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize UserService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.User = User\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.UserService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Users.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[User]</code> <p>MetadataList of Users</p> Source code in <code>src/wdadaptivepy/services/users.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[User]:\n    \"\"\"Convert Python Dictionary to MetadataList of Users.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Users\n\n    \"\"\"\n    return MetadataList[User](User.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.UserService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Users.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[User]</code> <p>MetadataList of Users</p> Source code in <code>src/wdadaptivepy/services/users.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[User]:\n    \"\"\"Convert JSON to MetadataList of Users.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Users\n\n    \"\"\"\n    return MetadataList[User](User.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.UserService.get_all","title":"<code>get_all(*, groups=True, owned_levels=True)</code>","text":"<p>Retrieve all Users from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>bool</code> <p>Adaptive Groups</p> <code>True</code> <code>owned_levels</code> <code>bool</code> <p>Adaptive Owned Levels</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[User]</code> <p>adaptive Users</p> Source code in <code>src/wdadaptivepy/services/users.py</code> <pre><code>def get_all(\n    self,\n    *,\n    groups: bool = True,\n    owned_levels: bool = True,\n) -&gt; MetadataList[User]:\n    \"\"\"Retrieve all Users from Adaptive.\n\n    Args:\n        groups: Adaptive Groups\n        owned_levels: Adaptive Owned Levels\n\n    Returns:\n        adaptive Users\n\n    \"\"\"\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"groups\": str(bool_to_str_true_false(groups)),\n            \"ownedLevels\": str(bool_to_str_true_false(owned_levels)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportUsers\",\n        payload=include,\n    )\n    return MetadataList[User](User.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.UserService.preview_update","title":"<code>preview_update(users, *, hide_password=True)</code>","text":"<p>Generate User update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>users</code> <code>Sequence[User]</code> <p>wdadaptivepy Users to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/users.py</code> <pre><code>def preview_update(\n    self,\n    users: Sequence[User],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate User update XML API call for review.\n\n    Args:\n        users: wdadaptivepy Users to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_users = User.to_xml(\"update\", users)\n    # ET.indent(updated_users)\n    # with open(\"test_users.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_users, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importUsers\",\n        payload=updated_users,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.VersionService","title":"<code>VersionService</code>","text":"<p>Create, retrieve, and modify Adaptive Versions.</p> <p>Attributes:</p> Name Type Description <code>Version</code> <p>wdadaptivepy Version</p> Source code in <code>src/wdadaptivepy/services/versions.py</code> <pre><code>class VersionService:\n    \"\"\"Create, retrieve, and modify Adaptive Versions.\n\n    Attributes:\n        Version: wdadaptivepy Version\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize VersionService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Version = Version\n\n    def get_all(\n        self,\n        *,\n        scenarios: bool = False,\n        currency_versions: bool = False,\n    ) -&gt; MetadataList[Version]:\n        \"\"\"Retrieve all Versions from Adaptive.\n\n        Args:\n            scenarios: Adaptive Scenarios\n            currency_versions: Adaptive Currency Versions\n\n        Returns:\n            adaptive Versions\n\n        \"\"\"\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"scenarios\": str(bool_to_str_true_false(scenarios)),\n                \"currencyVersions\": str(bool_to_str_true_false(currency_versions)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportVersions\",\n            payload=include,\n        )\n        return MetadataList[Version](Version.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        versions: Sequence[Version],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Currency update XML API call for review.\n\n        Args:\n            versions: wdadaptivepy Versions to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_versions = Version.to_xml(\"update\", versions)\n        # ET.indent(updated_versions)\n        # with open(\"test_versions.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_versions, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importVersions\",\n            payload=updated_versions,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[Version]:\n        \"\"\"Convert JSON to MetadataList of Versions.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Versions\n\n        \"\"\"\n        return MetadataList[Version](Version.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Version]:\n        \"\"\"Convert Python Dictionary to MetadataList of Versions.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Versions\n\n        \"\"\"\n        return MetadataList[Version](Version.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.VersionService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize VersionService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/versions.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize VersionService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Version = Version\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.VersionService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Versions.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Version]</code> <p>MetadataList of Versions</p> Source code in <code>src/wdadaptivepy/services/versions.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Version]:\n    \"\"\"Convert Python Dictionary to MetadataList of Versions.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Versions\n\n    \"\"\"\n    return MetadataList[Version](Version.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.VersionService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Versions.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[Version]</code> <p>MetadataList of Versions</p> Source code in <code>src/wdadaptivepy/services/versions.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Version]:\n    \"\"\"Convert JSON to MetadataList of Versions.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Versions\n\n    \"\"\"\n    return MetadataList[Version](Version.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.VersionService.get_all","title":"<code>get_all(*, scenarios=False, currency_versions=False)</code>","text":"<p>Retrieve all Versions from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>bool</code> <p>Adaptive Scenarios</p> <code>False</code> <code>currency_versions</code> <code>bool</code> <p>Adaptive Currency Versions</p> <code>False</code> <p>Returns:</p> Type Description <code>MetadataList[Version]</code> <p>adaptive Versions</p> Source code in <code>src/wdadaptivepy/services/versions.py</code> <pre><code>def get_all(\n    self,\n    *,\n    scenarios: bool = False,\n    currency_versions: bool = False,\n) -&gt; MetadataList[Version]:\n    \"\"\"Retrieve all Versions from Adaptive.\n\n    Args:\n        scenarios: Adaptive Scenarios\n        currency_versions: Adaptive Currency Versions\n\n    Returns:\n        adaptive Versions\n\n    \"\"\"\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"scenarios\": str(bool_to_str_true_false(scenarios)),\n            \"currencyVersions\": str(bool_to_str_true_false(currency_versions)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportVersions\",\n        payload=include,\n    )\n    return MetadataList[Version](Version.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/__init__/#wdadaptivepy.services.VersionService.preview_update","title":"<code>preview_update(versions, *, hide_password=True)</code>","text":"<p>Generate Currency update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[Version]</code> <p>wdadaptivepy Versions to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/versions.py</code> <pre><code>def preview_update(\n    self,\n    versions: Sequence[Version],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Currency update XML API call for review.\n\n    Args:\n        versions: wdadaptivepy Versions to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_versions = Version.to_xml(\"update\", versions)\n    # ET.indent(updated_versions)\n    # with open(\"test_versions.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_versions, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importVersions\",\n        payload=updated_versions,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/accounts/","title":"accounts","text":"<p>wdadaptivepy service for Adaptive's Accounts.</p>"},{"location":"reference/wdadaptivepy/services/accounts/#wdadaptivepy.services.accounts.AccountService","title":"<code>AccountService</code>","text":"<p>Create, retrieve, and modify Adaptive Accounts.</p> <p>Attributes:</p> Name Type Description <code>Account</code> <p>wdadaptivepy Account</p> Source code in <code>src/wdadaptivepy/services/accounts.py</code> <pre><code>class AccountService:\n    \"\"\"Create, retrieve, and modify Adaptive Accounts.\n\n    Attributes:\n        Account: wdadaptivepy Account\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize Account Service.\n\n        Args:\n            xml_api: Adaptive XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Account = Account\n\n    def get_all(\n        self,\n        *,\n        attributes: bool = True,\n        include_attribute_value_names: bool = True,\n        include_attribute_value_display_names: bool = True,\n    ) -&gt; MetadataList[Account]:\n        \"\"\"Retrieve all Accounts from Adaptive.\n\n        Args:\n            attributes: Include Account Attributes for each Account\n            include_attribute_value_names: Include Name for each Account\n            include_attribute_value_display_names: Include Display Name for each Account\n\n        Returns:\n            wdadaptivepy Accounts\n\n        \"\"\"\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"attributes\": str(bool_to_str_true_false(attributes)),\n                \"include_attribute_value_names\": str(\n                    bool_to_str_true_false(include_attribute_value_names),\n                ),\n                \"include_attribute_value_display_names\": str(\n                    bool_to_str_true_false(include_attribute_value_display_names),\n                ),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportAccounts\",\n            payload=include,\n        )\n        return MetadataList[Account](Account.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        accounts: Sequence[Account],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Account update XML API call for review prior to sending to Adaptive.\n\n        Args:\n            accounts: wdadaptivepy Accounts to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_accounts = Account.to_xml(\"update\", accounts)\n        # ET.indent(updated_accounts)\n        # with open(\"test_accounts.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_accounts, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importAccounts\",\n            payload=updated_accounts,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[Account]:\n        \"\"\"Convert JSON data to MetadataList of Accounts.\n\n        Args:\n            data: JSON Data\n\n        Returns:\n            MetadataList of Accounts\n\n        \"\"\"\n        return MetadataList[Account](Account.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Account]:\n        \"\"\"Convert Python Dictionary to MetadataList of Accounts.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Accounts\n\n        \"\"\"\n        return MetadataList[Account](Account.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/accounts/#wdadaptivepy.services.accounts.AccountService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize Account Service.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>Adaptive XMLApi</p> required Source code in <code>src/wdadaptivepy/services/accounts.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize Account Service.\n\n    Args:\n        xml_api: Adaptive XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Account = Account\n</code></pre>"},{"location":"reference/wdadaptivepy/services/accounts/#wdadaptivepy.services.accounts.AccountService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Accounts.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Account]</code> <p>MetadataList of Accounts</p> Source code in <code>src/wdadaptivepy/services/accounts.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Account]:\n    \"\"\"Convert Python Dictionary to MetadataList of Accounts.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Accounts\n\n    \"\"\"\n    return MetadataList[Account](Account.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/accounts/#wdadaptivepy.services.accounts.AccountService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON data to MetadataList of Accounts.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON Data</p> required <p>Returns:</p> Type Description <code>MetadataList[Account]</code> <p>MetadataList of Accounts</p> Source code in <code>src/wdadaptivepy/services/accounts.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Account]:\n    \"\"\"Convert JSON data to MetadataList of Accounts.\n\n    Args:\n        data: JSON Data\n\n    Returns:\n        MetadataList of Accounts\n\n    \"\"\"\n    return MetadataList[Account](Account.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/accounts/#wdadaptivepy.services.accounts.AccountService.get_all","title":"<code>get_all(*, attributes=True, include_attribute_value_names=True, include_attribute_value_display_names=True)</code>","text":"<p>Retrieve all Accounts from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>bool</code> <p>Include Account Attributes for each Account</p> <code>True</code> <code>include_attribute_value_names</code> <code>bool</code> <p>Include Name for each Account</p> <code>True</code> <code>include_attribute_value_display_names</code> <code>bool</code> <p>Include Display Name for each Account</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[Account]</code> <p>wdadaptivepy Accounts</p> Source code in <code>src/wdadaptivepy/services/accounts.py</code> <pre><code>def get_all(\n    self,\n    *,\n    attributes: bool = True,\n    include_attribute_value_names: bool = True,\n    include_attribute_value_display_names: bool = True,\n) -&gt; MetadataList[Account]:\n    \"\"\"Retrieve all Accounts from Adaptive.\n\n    Args:\n        attributes: Include Account Attributes for each Account\n        include_attribute_value_names: Include Name for each Account\n        include_attribute_value_display_names: Include Display Name for each Account\n\n    Returns:\n        wdadaptivepy Accounts\n\n    \"\"\"\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"attributes\": str(bool_to_str_true_false(attributes)),\n            \"include_attribute_value_names\": str(\n                bool_to_str_true_false(include_attribute_value_names),\n            ),\n            \"include_attribute_value_display_names\": str(\n                bool_to_str_true_false(include_attribute_value_display_names),\n            ),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportAccounts\",\n        payload=include,\n    )\n    return MetadataList[Account](Account.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/accounts/#wdadaptivepy.services.accounts.AccountService.preview_update","title":"<code>preview_update(accounts, *, hide_password=True)</code>","text":"<p>Generate Account update XML API call for review prior to sending to Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>accounts</code> <code>Sequence[Account]</code> <p>wdadaptivepy Accounts to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/accounts.py</code> <pre><code>def preview_update(\n    self,\n    accounts: Sequence[Account],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Account update XML API call for review prior to sending to Adaptive.\n\n    Args:\n        accounts: wdadaptivepy Accounts to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_accounts = Account.to_xml(\"update\", accounts)\n    # ET.indent(updated_accounts)\n    # with open(\"test_accounts.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_accounts, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importAccounts\",\n        payload=updated_accounts,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/attribute_values/","title":"attribute_values","text":"<p>wdadaptivepy service for Adaptive's Attribute Values.</p>"},{"location":"reference/wdadaptivepy/services/attribute_values/#wdadaptivepy.services.attribute_values.AttributeValueService","title":"<code>AttributeValueService</code>","text":"<p>Create, retrieve, and modify Adaptive Attribute Values.</p> <p>Attributes:</p> Name Type Description <code>AttributeValue</code> <p>wdadaptivepy AttributeValue</p> Source code in <code>src/wdadaptivepy/services/attribute_values.py</code> <pre><code>class AttributeValueService:\n    \"\"\"Create, retrieve, and modify Adaptive Attribute Values.\n\n    Attributes:\n        AttributeValue: wdadaptivepy AttributeValue\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize Attribute Service.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.AttributeValue = AttributeValue\n\n    def get_all(\n        self,\n        attribute: Attribute | str | int,\n        *,\n        display_name_enabled: bool = True,\n    ) -&gt; MetadataList[AttributeValue]:\n        \"\"\"Retreive all Attribute Values from Adaptive.\n\n        Args:\n            attribute: Adaptive Attribute\n            display_name_enabled: Include Display Name\n\n        Returns:\n            wdadaptivepy Attribute Values\n\n        \"\"\"\n        _, attribute_values = self.__find_attribute(\n            attribute,\n            display_name_enabled=display_name_enabled,\n        )\n        return attribute_values\n\n    def preview_update(\n        self,\n        attribute: Attribute | int | str,\n        attribute_values: Sequence[AttributeValue],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Attribute update XML API call for review.\n\n        Args:\n            attribute: adaptivepy Attribute\n            attribute_values: wdadaptivepy Attribute Values to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        method, payload = self.__build_update_payload(attribute, attribute_values)\n        # updated_attributes = Attribute.to_xml(\"update\", attributes)\n        # ET.indent(updated_attributes)\n        # with open(\"test_attributes.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_attributes, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=method,\n            payload=payload,\n            hide_password=hide_password,\n        )\n\n    def __build_update_payload(\n        self,\n        attribute: Attribute | int | str,\n        attribute_values: Sequence[AttributeValue],\n    ) -&gt; tuple[str, ET.Element]:\n        for attribute_value in attribute_values:\n            if attribute_value.id is None or attribute_value.id == 0:\n                raise ValueError\n        found_attribute, _ = self.__find_attribute(attribute=attribute)\n        update_attributes = Attribute.to_xml(\n            \"update\",\n            [Attribute(id=found_attribute.id)],\n        )\n        update_attribute = update_attributes.find(\"attribute\")\n        if update_attribute is None:\n            raise ValueError\n        update_attribute.extend(\n            AttributeValue.to_xml(\"update\", attribute_values),\n        )\n        return \"updateAttributes\", update_attributes\n\n    def __find_attribute(\n        self,\n        attribute: Attribute | int | str,\n        *,\n        display_name_enabled: bool = True,\n    ) -&gt; tuple[Attribute, MetadataList[AttributeValue]]:\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportAttributes\",\n            payload=include,\n        )\n\n        attributes = MetadataList[Attribute](Attribute.from_xml(xml=response))\n        attribute_check = Attribute()\n        if isinstance(attribute, Attribute):\n            attribute_check = attribute\n        elif isinstance(attribute, int):\n            attribute_check.id = attribute\n        elif isinstance(attribute, str):\n            attribute_check.name = attribute\n        else:\n            raise TypeError\n\n        found_attribute = None\n        for attr in attributes:\n            if attr.id == attribute_check.id or attr.name == attribute_check.name:\n                found_attribute = attr\n                break\n        if found_attribute is None:\n            raise ValueError\n\n        found_xml_elem = None\n        for elem in response.iter(\"attribute\"):\n            if elem.get(\"id\") == str(found_attribute.id):\n                found_xml_elem = elem\n                break\n        if found_xml_elem is None:\n            raise ValueError\n        found_attribute_values = AttributeValue.from_xml(found_xml_elem)\n\n        return found_attribute, found_attribute_values\n\n    def from_json(self, data: str) -&gt; MetadataList[AttributeValue]:\n        \"\"\"Convert JSON to MetadataList of Attribute Values.\n\n        Args:\n            data: JSON data\n\n        Returns:\n            MetadataList of Attribute Values\n\n        \"\"\"\n        return MetadataList[AttributeValue](AttributeValue.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[AttributeValue]:\n        \"\"\"Convert Python Dictionary to MetadataList of Attribute Values.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Attribute Value\n\n        \"\"\"\n        return MetadataList[AttributeValue](AttributeValue.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/attribute_values/#wdadaptivepy.services.attribute_values.AttributeValueService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize Attribute Service.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/attribute_values.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize Attribute Service.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.AttributeValue = AttributeValue\n</code></pre>"},{"location":"reference/wdadaptivepy/services/attribute_values/#wdadaptivepy.services.attribute_values.AttributeValueService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Attribute Values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[AttributeValue]</code> <p>MetadataList of Attribute Value</p> Source code in <code>src/wdadaptivepy/services/attribute_values.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[AttributeValue]:\n    \"\"\"Convert Python Dictionary to MetadataList of Attribute Values.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Attribute Value\n\n    \"\"\"\n    return MetadataList[AttributeValue](AttributeValue.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/attribute_values/#wdadaptivepy.services.attribute_values.AttributeValueService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Attribute Values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON data</p> required <p>Returns:</p> Type Description <code>MetadataList[AttributeValue]</code> <p>MetadataList of Attribute Values</p> Source code in <code>src/wdadaptivepy/services/attribute_values.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[AttributeValue]:\n    \"\"\"Convert JSON to MetadataList of Attribute Values.\n\n    Args:\n        data: JSON data\n\n    Returns:\n        MetadataList of Attribute Values\n\n    \"\"\"\n    return MetadataList[AttributeValue](AttributeValue.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/attribute_values/#wdadaptivepy.services.attribute_values.AttributeValueService.get_all","title":"<code>get_all(attribute, *, display_name_enabled=True)</code>","text":"<p>Retreive all Attribute Values from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>Attribute | str | int</code> <p>Adaptive Attribute</p> required <code>display_name_enabled</code> <code>bool</code> <p>Include Display Name</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[AttributeValue]</code> <p>wdadaptivepy Attribute Values</p> Source code in <code>src/wdadaptivepy/services/attribute_values.py</code> <pre><code>def get_all(\n    self,\n    attribute: Attribute | str | int,\n    *,\n    display_name_enabled: bool = True,\n) -&gt; MetadataList[AttributeValue]:\n    \"\"\"Retreive all Attribute Values from Adaptive.\n\n    Args:\n        attribute: Adaptive Attribute\n        display_name_enabled: Include Display Name\n\n    Returns:\n        wdadaptivepy Attribute Values\n\n    \"\"\"\n    _, attribute_values = self.__find_attribute(\n        attribute,\n        display_name_enabled=display_name_enabled,\n    )\n    return attribute_values\n</code></pre>"},{"location":"reference/wdadaptivepy/services/attribute_values/#wdadaptivepy.services.attribute_values.AttributeValueService.preview_update","title":"<code>preview_update(attribute, attribute_values, *, hide_password=True)</code>","text":"<p>Generate Attribute update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>Attribute | int | str</code> <p>adaptivepy Attribute</p> required <code>attribute_values</code> <code>Sequence[AttributeValue]</code> <p>wdadaptivepy Attribute Values to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/attribute_values.py</code> <pre><code>def preview_update(\n    self,\n    attribute: Attribute | int | str,\n    attribute_values: Sequence[AttributeValue],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Attribute update XML API call for review.\n\n    Args:\n        attribute: adaptivepy Attribute\n        attribute_values: wdadaptivepy Attribute Values to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    method, payload = self.__build_update_payload(attribute, attribute_values)\n    # updated_attributes = Attribute.to_xml(\"update\", attributes)\n    # ET.indent(updated_attributes)\n    # with open(\"test_attributes.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_attributes, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=method,\n        payload=payload,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/attributes/","title":"attributes","text":"<p>wdadaptivepy service for Adaptive's Attributes.</p>"},{"location":"reference/wdadaptivepy/services/attributes/#wdadaptivepy.services.attributes.AttributeService","title":"<code>AttributeService</code>","text":"<p>Create, retrieve, and modify Adaptive Attributes.</p> <p>Attributes:</p> Name Type Description <code>Attribute</code> <p>wdadaptivepy Attribute</p> Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>class AttributeService:\n    \"\"\"Create, retrieve, and modify Adaptive Attributes.\n\n    Attributes:\n        Attribute: wdadaptivepy Attribute\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize Attribute Service.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Attribute = Attribute\n\n    def get_all(self, *, display_name_enabled: bool = True) -&gt; MetadataList[Attribute]:\n        \"\"\"Retreive all Attributes from Adaptive.\n\n        Args:\n            display_name_enabled: Include Display Name\n\n        Returns:\n            wdadaptivepy Attributes\n\n        \"\"\"\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportAttributes\",\n            payload=include,\n        )\n        return MetadataList[Attribute](Attribute.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        attributes: Sequence[Attribute],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Attribute update XML API call for review.\n\n        Args:\n            attributes: wdadaptivepy Attributes to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_attributes = Attribute.to_xml(\"update\", attributes)\n        # ET.indent(updated_attributes)\n        # with open(\"test_attributes.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_attributes, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importAttributes\",\n            payload=updated_attributes,\n            hide_password=hide_password,\n        )\n\n    def get(  # NOQA: PLR0912, PLR0913\n        self,\n        attributes: Sequence[Attribute] = [],\n        attribute_ids: Sequence[int] = [],\n        attribute_names: Sequence[str] = [],\n        attribute_types: Sequence[str] = [],\n        dimensions: Sequence[Dimension] = [],\n        dimension_ids: Sequence[int] = [],\n        *,\n        display_name_enabled: bool = True,\n    ) -&gt; MetadataList[Attribute]:\n        \"\"\"Retrieve Attributes from Adaptive based on parameters.\n\n        Args:\n            attributes: wdadaptivepy Attributes\n            attribute_ids: ID of Attributes\n            attribute_names: Name of Attributes\n            attribute_types: Type of Attribute (eg: Level, Account, Dimension)\n            dimensions: wdadaptivepy Dimensions\n            dimension_ids: ID of Dimensions\n            display_name_enabled: Include Display Name for each Attribute\n\n        Returns:\n            wdadaptivepy Attributes\n\n        \"\"\"\n        ids: list[int] = []\n        if attributes:\n            ids.extend(\n                [attribute.id for attribute in attributes if attribute.id is not None],\n            )\n        elif attribute_ids:\n            ids.extend(attribute_ids)\n        elif attribute_names:\n            all_attributes = self.get_all()\n            for name in attribute_names:\n                for attribute in all_attributes:\n                    if name == attribute.name and attribute.id is not None:\n                        ids.append(attribute.id)\n                        break\n        elif attribute_types:\n            all_attributes = self.get_all()\n            for attribute_type in attribute_types:\n                for attribute in all_attributes:\n                    if (\n                        attribute_type == attribute.attribute_type\n                        and attribute.id is not None\n                    ):\n                        ids.append(attribute.id)\n                        break\n        elif not (dimensions or dimension_ids):\n            all_attributes = self.get_all()\n            if dimensions:\n                for dimension in dimensions:\n                    for attribute in all_attributes:\n                        if (\n                            attribute.dimension_id == dimension.id\n                            and attribute.id is not None\n                        ):\n                            ids.append(attribute.id)\n                            break\n            elif dimension_ids:\n                for dimension_id in dimension_ids:\n                    for attribute in all_attributes:\n                        if (\n                            attribute.dimension_id == dimension_id\n                            and attribute.id is not None\n                        ):\n                            ids.append(attribute.id)\n                            break\n        else:\n            raise ValueError\n        if not ids:\n            raise ValueError\n\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"attributeIDs\": \",\".join(str(attribute_id) for attribute_id in ids),\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportAttributes\",\n            payload=include,\n        )\n        return MetadataList[Attribute](Attribute.from_xml(xml=response))\n\n    def from_json(self, data: str) -&gt; MetadataList[Attribute]:\n        \"\"\"Convert JSON to MetadataList of Attributes.\n\n        Args:\n            data: JSON data\n\n        Returns:\n            MetadataList of Attributes\n\n        \"\"\"\n        return MetadataList[Attribute](Attribute.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Attribute]:\n        \"\"\"Convert Python Dictionary to MetadataList of Attributes.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Attributes\n\n        \"\"\"\n        return MetadataList[Attribute](Attribute.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/attributes/#wdadaptivepy.services.attributes.AttributeService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize Attribute Service.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize Attribute Service.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Attribute = Attribute\n</code></pre>"},{"location":"reference/wdadaptivepy/services/attributes/#wdadaptivepy.services.attributes.AttributeService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Attributes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Attribute]</code> <p>MetadataList of Attributes</p> Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Attribute]:\n    \"\"\"Convert Python Dictionary to MetadataList of Attributes.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Attributes\n\n    \"\"\"\n    return MetadataList[Attribute](Attribute.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/attributes/#wdadaptivepy.services.attributes.AttributeService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Attributes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON data</p> required <p>Returns:</p> Type Description <code>MetadataList[Attribute]</code> <p>MetadataList of Attributes</p> Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Attribute]:\n    \"\"\"Convert JSON to MetadataList of Attributes.\n\n    Args:\n        data: JSON data\n\n    Returns:\n        MetadataList of Attributes\n\n    \"\"\"\n    return MetadataList[Attribute](Attribute.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/attributes/#wdadaptivepy.services.attributes.AttributeService.get","title":"<code>get(attributes=[], attribute_ids=[], attribute_names=[], attribute_types=[], dimensions=[], dimension_ids=[], *, display_name_enabled=True)</code>","text":"<p>Retrieve Attributes from Adaptive based on parameters.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Sequence[Attribute]</code> <p>wdadaptivepy Attributes</p> <code>[]</code> <code>attribute_ids</code> <code>Sequence[int]</code> <p>ID of Attributes</p> <code>[]</code> <code>attribute_names</code> <code>Sequence[str]</code> <p>Name of Attributes</p> <code>[]</code> <code>attribute_types</code> <code>Sequence[str]</code> <p>Type of Attribute (eg: Level, Account, Dimension)</p> <code>[]</code> <code>dimensions</code> <code>Sequence[Dimension]</code> <p>wdadaptivepy Dimensions</p> <code>[]</code> <code>dimension_ids</code> <code>Sequence[int]</code> <p>ID of Dimensions</p> <code>[]</code> <code>display_name_enabled</code> <code>bool</code> <p>Include Display Name for each Attribute</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[Attribute]</code> <p>wdadaptivepy Attributes</p> Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>def get(  # NOQA: PLR0912, PLR0913\n    self,\n    attributes: Sequence[Attribute] = [],\n    attribute_ids: Sequence[int] = [],\n    attribute_names: Sequence[str] = [],\n    attribute_types: Sequence[str] = [],\n    dimensions: Sequence[Dimension] = [],\n    dimension_ids: Sequence[int] = [],\n    *,\n    display_name_enabled: bool = True,\n) -&gt; MetadataList[Attribute]:\n    \"\"\"Retrieve Attributes from Adaptive based on parameters.\n\n    Args:\n        attributes: wdadaptivepy Attributes\n        attribute_ids: ID of Attributes\n        attribute_names: Name of Attributes\n        attribute_types: Type of Attribute (eg: Level, Account, Dimension)\n        dimensions: wdadaptivepy Dimensions\n        dimension_ids: ID of Dimensions\n        display_name_enabled: Include Display Name for each Attribute\n\n    Returns:\n        wdadaptivepy Attributes\n\n    \"\"\"\n    ids: list[int] = []\n    if attributes:\n        ids.extend(\n            [attribute.id for attribute in attributes if attribute.id is not None],\n        )\n    elif attribute_ids:\n        ids.extend(attribute_ids)\n    elif attribute_names:\n        all_attributes = self.get_all()\n        for name in attribute_names:\n            for attribute in all_attributes:\n                if name == attribute.name and attribute.id is not None:\n                    ids.append(attribute.id)\n                    break\n    elif attribute_types:\n        all_attributes = self.get_all()\n        for attribute_type in attribute_types:\n            for attribute in all_attributes:\n                if (\n                    attribute_type == attribute.attribute_type\n                    and attribute.id is not None\n                ):\n                    ids.append(attribute.id)\n                    break\n    elif not (dimensions or dimension_ids):\n        all_attributes = self.get_all()\n        if dimensions:\n            for dimension in dimensions:\n                for attribute in all_attributes:\n                    if (\n                        attribute.dimension_id == dimension.id\n                        and attribute.id is not None\n                    ):\n                        ids.append(attribute.id)\n                        break\n        elif dimension_ids:\n            for dimension_id in dimension_ids:\n                for attribute in all_attributes:\n                    if (\n                        attribute.dimension_id == dimension_id\n                        and attribute.id is not None\n                    ):\n                        ids.append(attribute.id)\n                        break\n    else:\n        raise ValueError\n    if not ids:\n        raise ValueError\n\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"attributeIDs\": \",\".join(str(attribute_id) for attribute_id in ids),\n            \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportAttributes\",\n        payload=include,\n    )\n    return MetadataList[Attribute](Attribute.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/attributes/#wdadaptivepy.services.attributes.AttributeService.get_all","title":"<code>get_all(*, display_name_enabled=True)</code>","text":"<p>Retreive all Attributes from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>display_name_enabled</code> <code>bool</code> <p>Include Display Name</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[Attribute]</code> <p>wdadaptivepy Attributes</p> Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>def get_all(self, *, display_name_enabled: bool = True) -&gt; MetadataList[Attribute]:\n    \"\"\"Retreive all Attributes from Adaptive.\n\n    Args:\n        display_name_enabled: Include Display Name\n\n    Returns:\n        wdadaptivepy Attributes\n\n    \"\"\"\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportAttributes\",\n        payload=include,\n    )\n    return MetadataList[Attribute](Attribute.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/attributes/#wdadaptivepy.services.attributes.AttributeService.preview_update","title":"<code>preview_update(attributes, *, hide_password=True)</code>","text":"<p>Generate Attribute update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Sequence[Attribute]</code> <p>wdadaptivepy Attributes to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/attributes.py</code> <pre><code>def preview_update(\n    self,\n    attributes: Sequence[Attribute],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Attribute update XML API call for review.\n\n    Args:\n        attributes: wdadaptivepy Attributes to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_attributes = Attribute.to_xml(\"update\", attributes)\n    # ET.indent(updated_attributes)\n    # with open(\"test_attributes.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_attributes, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importAttributes\",\n        payload=updated_attributes,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/currencies/","title":"currencies","text":"<p>wdadaptivepy service for Adaptive's Currencies.</p>"},{"location":"reference/wdadaptivepy/services/currencies/#wdadaptivepy.services.currencies.CurrencyService","title":"<code>CurrencyService</code>","text":"<p>Create, retrieve, and modify Adaptive Currencies.</p> <p>Attributes:</p> Name Type Description <code>Currency</code> <p>wdadaptivepy Currency</p> Source code in <code>src/wdadaptivepy/services/currencies.py</code> <pre><code>class CurrencyService:\n    \"\"\"Create, retrieve, and modify Adaptive Currencies.\n\n    Attributes:\n        Currency: wdadaptivepy Currency\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize CurrencyService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Currency = Currency\n\n    def get_all(self) -&gt; MetadataList[Currency]:\n        \"\"\"Retrieve all Currencies from Adaptive.\n\n        Returns:\n            adaptive Currencies\n\n        \"\"\"\n        response = self.__xml_api.make_xml_request(\n            method=\"exportActiveCurrencies\",\n            payload=None,\n        )\n        return MetadataList[Currency](Currency.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        currencies: Sequence[Currency],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Currency update XML API call for review.\n\n        Args:\n            currencies: wdadaptivepy Currencies to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_currencies = Currency.to_xml(\"update\", currencies)\n        # ET.indent(updated_currencies)\n        # with open(\"test_currencies.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_currencies, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importCurrencies\",\n            payload=updated_currencies,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[Currency]:\n        \"\"\"Convert JSON to MetadataList of Currencies.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Currencies\n\n        \"\"\"\n        return MetadataList[Currency](Currency.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Currency]:\n        \"\"\"Convert Python Dictionary to MetadataList of Currencies.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Currencies\n\n        \"\"\"\n        return MetadataList[Currency](Currency.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/currencies/#wdadaptivepy.services.currencies.CurrencyService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize CurrencyService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/currencies.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize CurrencyService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Currency = Currency\n</code></pre>"},{"location":"reference/wdadaptivepy/services/currencies/#wdadaptivepy.services.currencies.CurrencyService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Currencies.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Currency]</code> <p>MetadataList of Currencies</p> Source code in <code>src/wdadaptivepy/services/currencies.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Currency]:\n    \"\"\"Convert Python Dictionary to MetadataList of Currencies.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Currencies\n\n    \"\"\"\n    return MetadataList[Currency](Currency.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/currencies/#wdadaptivepy.services.currencies.CurrencyService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Currencies.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[Currency]</code> <p>MetadataList of Currencies</p> Source code in <code>src/wdadaptivepy/services/currencies.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Currency]:\n    \"\"\"Convert JSON to MetadataList of Currencies.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Currencies\n\n    \"\"\"\n    return MetadataList[Currency](Currency.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/currencies/#wdadaptivepy.services.currencies.CurrencyService.get_all","title":"<code>get_all()</code>","text":"<p>Retrieve all Currencies from Adaptive.</p> <p>Returns:</p> Type Description <code>MetadataList[Currency]</code> <p>adaptive Currencies</p> Source code in <code>src/wdadaptivepy/services/currencies.py</code> <pre><code>def get_all(self) -&gt; MetadataList[Currency]:\n    \"\"\"Retrieve all Currencies from Adaptive.\n\n    Returns:\n        adaptive Currencies\n\n    \"\"\"\n    response = self.__xml_api.make_xml_request(\n        method=\"exportActiveCurrencies\",\n        payload=None,\n    )\n    return MetadataList[Currency](Currency.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/currencies/#wdadaptivepy.services.currencies.CurrencyService.preview_update","title":"<code>preview_update(currencies, *, hide_password=True)</code>","text":"<p>Generate Currency update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>currencies</code> <code>Sequence[Currency]</code> <p>wdadaptivepy Currencies to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/currencies.py</code> <pre><code>def preview_update(\n    self,\n    currencies: Sequence[Currency],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Currency update XML API call for review.\n\n    Args:\n        currencies: wdadaptivepy Currencies to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_currencies = Currency.to_xml(\"update\", currencies)\n    # ET.indent(updated_currencies)\n    # with open(\"test_currencies.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_currencies, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importCurrencies\",\n        payload=updated_currencies,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/data/","title":"data","text":"<p>wdadaptivepy service for Adaptive data.</p>"},{"location":"reference/wdadaptivepy/services/data/#wdadaptivepy.services.data.DataService","title":"<code>DataService</code>","text":"<p>wdadaptivepy Service for Data.</p> <p>Attributes:</p> Name Type Description <code>ExportDataAccountsFilter</code> <p>Adaptive Accounts Filter</p> <code>ExportDataCurrencyFilter</code> <p>Adaptive Currency Filter</p> <code>ExportDataFilter</code> <p>Adaptive Data Filter</p> <code>ExportDataFormat</code> <p>Adaptive Data Format</p> <code>ExportDataRules</code> <p>Adaptive  Rules</p> <code>ExportDataLevelFilter</code> <p>Adaptive Level Filter</p> <code>ExportDataTimeFilter</code> <p>Adaptive Time Filter</p> Source code in <code>src/wdadaptivepy/services/data.py</code> <pre><code>class DataService:\n    \"\"\"wdadaptivepy Service for Data.\n\n    Attributes:\n        ExportDataAccountsFilter: Adaptive Accounts Filter\n        ExportDataCurrencyFilter: Adaptive Currency Filter\n        ExportDataFilter: Adaptive Data Filter\n        ExportDataFormat: Adaptive Data Format\n        ExportDataRules: Adaptive  Rules\n        ExportDataLevelFilter: Adaptive Level Filter\n        ExportDataTimeFilter: Adaptive Time Filter\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize DataService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.ExportDataAccountsFilter = AccountFilter\n        self.ExportDataCurrencyFilter = CurrencyFilter\n        self.ExportDataFilter = ExportDataFilter\n        self.ExportDataFormat = ExportDataFormat\n        self.ExportDataRules = ExportDataRules\n        self.ExportDataLevelFilter = LevelFilter\n        self.ExportDataTimeFilter = TimeFilter\n\n    def _create_dimension_element(self, dimension: Dimension) -&gt; ET.Element:\n        if dimension.name is None:\n            error_message = \"Dimension name cannot be None\"\n            raise ValueError(error_message)\n        return ET.Element(\"dimension\", attrib={\"name\": dimension.name})\n\n    def get_data(  # NOQA: PLR0915, PLR0912\n        self,\n        version: Version,\n        data_filter: ExportDataFilter,\n        data_format: ExportDataFormat | None = None,\n        dimensions: Dimension | list[Dimension] | None = None,\n        rules: ExportDataRules | None = None,\n    ) -&gt; list[dict[str, str | int | float]]:\n        \"\"\"Retrieve Data from Adaptive.\n\n        Args:\n            version: Adaptive Version\n            data_filter: Adaptive Filter\n            data_format: Adaptive Format\n            dimensions: Adaptive Dimensions\n            rules: Adaptive Rules\n\n        Returns:\n            List of rows of data\n\n        Raises:\n            ValueError: Unexpected value\n            RuntimeError: Unexpected error\n\n        \"\"\"\n        if data_format is None:\n            data_format = ExportDataFormat()\n\n        payload: list[ET.Element] = []\n\n        if version.name is None:\n            error_message = \"Expected Version name value\"\n            raise ValueError(error_message)\n        version_element = ET.Element(\"version\", attrib={\"name\": version.name})\n        payload.append(version_element)\n\n        format_element = data_format.to_xml_element()\n        payload.append(format_element)\n\n        filter_element = data_filter.to_xml_element()\n        payload.append(filter_element)\n\n        if dimensions is not None:\n            dimensions_element = ET.Element(\"dimensions\")\n            if isinstance(dimensions, list):\n                for dimension in dimensions:\n                    dimension_element = self._create_dimension_element(dimension)\n                    dimensions_element.append(dimension_element)\n            else:\n                dimension_element = self._create_dimension_element(dimensions)\n                dimensions_element.append(dimension_element)\n            payload.append(dimensions_element)\n        if rules is not None:\n            rules_element = rules.to_xml_element()\n            payload.append(rules_element)\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportData\",\n            payload=payload,\n        )\n\n        received_row_count = -1\n        status_element = response.find(\"status\")\n        if status_element:\n            row_count_sent = status_element.attrib[\"rowCountSent\"]\n            if row_count_sent:\n                received_row_count = int(row_count_sent)\n        data_element = response.find(\"output\")\n        data: list[dict[str, str | int | float]] = []\n        column_headers: Sequence[str] | None = None\n        if data_element is not None and data_element.text is not None:\n            rows = StringIO(data_element.text.lstrip(\"\\n\"))\n            csv_reader = DictReader(rows, lineterminator=\"\\n\")\n            column_headers = csv_reader.fieldnames\n            data = list(csv_reader)\n        if received_row_count &gt; -1 and received_row_count != len(data):\n            error_message = (\n                \"Inconsistent row counts: expected \"\n                f\"{received_row_count}, got {len(data)}\"\n            )\n            raise RuntimeError(error_message)\n\n        if column_headers is not None:\n            period_columns = [\n                period\n                for period in column_headers\n                if not (period.endswith((\" Name\", \" Code\")))\n            ]\n            parsed_data: list[dict[str, str | int | float]] = []\n            for data_row in data:\n                for period in period_columns:\n                    row: dict[str, str | int | float] = {}\n                    for column in column_headers:\n                        if column in period_columns:\n                            break\n                        row[column] = data_row[column]\n                    row[\"Period Code\"] = period\n                    try:\n                        row[\"Amount\"] = int(data_row[period])\n                    except ValueError:\n                        row[\"Amount\"] = float(data_row[period])\n\n                    parsed_data.append(row)\n            return parsed_data\n\n        return data\n\n    def from_modeled_sheet(  # NOQA: PLR0913\n        self,\n        version_name: str,\n        sheet_name: str,\n        *,\n        is_assumption_sheet: bool = False,\n        include_all_columns: bool = True,\n        get_all_rows: bool = True,\n        use_numeric_ids: bool = False,\n        display_name_enabled: bool = True,\n        include_codes: bool = False,\n        include_names: bool = False,\n        include_display_names: bool = False,\n        use_account_precision: bool = False,\n        use_actual_value: bool = False,\n    ) -&gt; list[dict[str, str | int | float | bool | datetime]]:\n        \"\"\"Retrieve Adaptive Data from a Modeled Sheet.\n\n        Args:\n            version_name: Adaptive Version Name\n            sheet_name: Adaptive Sheet Name\n            is_assumption_sheet: Adaptive Is Assumption Sheet\n            include_all_columns: Adaptive Include All Columns\n            get_all_rows: Adaptive Get All Rows\n            use_numeric_ids: Adaptive Use Numeric IDs\n            display_name_enabled: Adaptive Display Name Enabled\n            include_codes: Adaptive Include Codes\n            include_names: Adaptive Include Names\n            include_display_names: Adaptive Include Display Names\n            use_account_precision: Adaptive Use Account Precision\n            use_actual_value: Adaptive Use Actual Value\n\n        Returns:\n            List of rows of data\n\n        \"\"\"\n        version_element = ET.Element(\"version\", attrib={\"name\": version_name})\n        modeled_sheet_element = ET.Element(\n            \"modeled-sheet\",\n            attrib={\n                \"name\": sheet_name,\n                \"isGlobal\": str(bool_to_str_true_false(is_assumption_sheet)),\n                \"includeAllColumns\": str(bool_to_str_true_false(include_all_columns)),\n                \"isGetAllRows\": str(bool_to_str_true_false(get_all_rows)),\n                \"useNumericIDs\": str(bool_to_str_true_false(use_numeric_ids)),\n                \"diplsayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n                \"includeCodes\": str(bool_to_str_true_false(include_codes)),\n                \"includeNames\": str(bool_to_str_true_false(include_names)),\n                \"includeDisplayNames\": str(\n                    bool_to_str_true_false(include_display_names),\n                ),\n                \"useAccountPrecision\": str(\n                    bool_to_str_true_false(use_account_precision),\n                ),\n                \"useActualValue\": str(bool_to_str_true_false(use_actual_value)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportConfigurableModelData\",\n            payload=[version_element, modeled_sheet_element],\n        )\n        data = response.find(\"output/data\")\n        sheet_data: list[dict[str, str | int | float | datetime]] = []\n        if data is not None and data.text is not None:\n            rows = StringIO(data.text.lstrip(\"\\n\"))\n            csv_reader = DictReader(rows, lineterminator=\"\\n\")\n            sheet_data = list(csv_reader)\n\n        return sheet_data\n</code></pre>"},{"location":"reference/wdadaptivepy/services/data/#wdadaptivepy.services.data.DataService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize DataService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/data.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize DataService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.ExportDataAccountsFilter = AccountFilter\n    self.ExportDataCurrencyFilter = CurrencyFilter\n    self.ExportDataFilter = ExportDataFilter\n    self.ExportDataFormat = ExportDataFormat\n    self.ExportDataRules = ExportDataRules\n    self.ExportDataLevelFilter = LevelFilter\n    self.ExportDataTimeFilter = TimeFilter\n</code></pre>"},{"location":"reference/wdadaptivepy/services/data/#wdadaptivepy.services.data.DataService.from_modeled_sheet","title":"<code>from_modeled_sheet(version_name, sheet_name, *, is_assumption_sheet=False, include_all_columns=True, get_all_rows=True, use_numeric_ids=False, display_name_enabled=True, include_codes=False, include_names=False, include_display_names=False, use_account_precision=False, use_actual_value=False)</code>","text":"<p>Retrieve Adaptive Data from a Modeled Sheet.</p> <p>Parameters:</p> Name Type Description Default <code>version_name</code> <code>str</code> <p>Adaptive Version Name</p> required <code>sheet_name</code> <code>str</code> <p>Adaptive Sheet Name</p> required <code>is_assumption_sheet</code> <code>bool</code> <p>Adaptive Is Assumption Sheet</p> <code>False</code> <code>include_all_columns</code> <code>bool</code> <p>Adaptive Include All Columns</p> <code>True</code> <code>get_all_rows</code> <code>bool</code> <p>Adaptive Get All Rows</p> <code>True</code> <code>use_numeric_ids</code> <code>bool</code> <p>Adaptive Use Numeric IDs</p> <code>False</code> <code>display_name_enabled</code> <code>bool</code> <p>Adaptive Display Name Enabled</p> <code>True</code> <code>include_codes</code> <code>bool</code> <p>Adaptive Include Codes</p> <code>False</code> <code>include_names</code> <code>bool</code> <p>Adaptive Include Names</p> <code>False</code> <code>include_display_names</code> <code>bool</code> <p>Adaptive Include Display Names</p> <code>False</code> <code>use_account_precision</code> <code>bool</code> <p>Adaptive Use Account Precision</p> <code>False</code> <code>use_actual_value</code> <code>bool</code> <p>Adaptive Use Actual Value</p> <code>False</code> <p>Returns:</p> Type Description <code>list[dict[str, str | int | float | bool | datetime]]</code> <p>List of rows of data</p> Source code in <code>src/wdadaptivepy/services/data.py</code> <pre><code>def from_modeled_sheet(  # NOQA: PLR0913\n    self,\n    version_name: str,\n    sheet_name: str,\n    *,\n    is_assumption_sheet: bool = False,\n    include_all_columns: bool = True,\n    get_all_rows: bool = True,\n    use_numeric_ids: bool = False,\n    display_name_enabled: bool = True,\n    include_codes: bool = False,\n    include_names: bool = False,\n    include_display_names: bool = False,\n    use_account_precision: bool = False,\n    use_actual_value: bool = False,\n) -&gt; list[dict[str, str | int | float | bool | datetime]]:\n    \"\"\"Retrieve Adaptive Data from a Modeled Sheet.\n\n    Args:\n        version_name: Adaptive Version Name\n        sheet_name: Adaptive Sheet Name\n        is_assumption_sheet: Adaptive Is Assumption Sheet\n        include_all_columns: Adaptive Include All Columns\n        get_all_rows: Adaptive Get All Rows\n        use_numeric_ids: Adaptive Use Numeric IDs\n        display_name_enabled: Adaptive Display Name Enabled\n        include_codes: Adaptive Include Codes\n        include_names: Adaptive Include Names\n        include_display_names: Adaptive Include Display Names\n        use_account_precision: Adaptive Use Account Precision\n        use_actual_value: Adaptive Use Actual Value\n\n    Returns:\n        List of rows of data\n\n    \"\"\"\n    version_element = ET.Element(\"version\", attrib={\"name\": version_name})\n    modeled_sheet_element = ET.Element(\n        \"modeled-sheet\",\n        attrib={\n            \"name\": sheet_name,\n            \"isGlobal\": str(bool_to_str_true_false(is_assumption_sheet)),\n            \"includeAllColumns\": str(bool_to_str_true_false(include_all_columns)),\n            \"isGetAllRows\": str(bool_to_str_true_false(get_all_rows)),\n            \"useNumericIDs\": str(bool_to_str_true_false(use_numeric_ids)),\n            \"diplsayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            \"includeCodes\": str(bool_to_str_true_false(include_codes)),\n            \"includeNames\": str(bool_to_str_true_false(include_names)),\n            \"includeDisplayNames\": str(\n                bool_to_str_true_false(include_display_names),\n            ),\n            \"useAccountPrecision\": str(\n                bool_to_str_true_false(use_account_precision),\n            ),\n            \"useActualValue\": str(bool_to_str_true_false(use_actual_value)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportConfigurableModelData\",\n        payload=[version_element, modeled_sheet_element],\n    )\n    data = response.find(\"output/data\")\n    sheet_data: list[dict[str, str | int | float | datetime]] = []\n    if data is not None and data.text is not None:\n        rows = StringIO(data.text.lstrip(\"\\n\"))\n        csv_reader = DictReader(rows, lineterminator=\"\\n\")\n        sheet_data = list(csv_reader)\n\n    return sheet_data\n</code></pre>"},{"location":"reference/wdadaptivepy/services/data/#wdadaptivepy.services.data.DataService.get_data","title":"<code>get_data(version, data_filter, data_format=None, dimensions=None, rules=None)</code>","text":"<p>Retrieve Data from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>Adaptive Version</p> required <code>data_filter</code> <code>ExportDataFilter</code> <p>Adaptive Filter</p> required <code>data_format</code> <code>ExportDataFormat | None</code> <p>Adaptive Format</p> <code>None</code> <code>dimensions</code> <code>Dimension | list[Dimension] | None</code> <p>Adaptive Dimensions</p> <code>None</code> <code>rules</code> <code>ExportDataRules | None</code> <p>Adaptive Rules</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, str | int | float]]</code> <p>List of rows of data</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Unexpected value</p> <code>RuntimeError</code> <p>Unexpected error</p> Source code in <code>src/wdadaptivepy/services/data.py</code> <pre><code>def get_data(  # NOQA: PLR0915, PLR0912\n    self,\n    version: Version,\n    data_filter: ExportDataFilter,\n    data_format: ExportDataFormat | None = None,\n    dimensions: Dimension | list[Dimension] | None = None,\n    rules: ExportDataRules | None = None,\n) -&gt; list[dict[str, str | int | float]]:\n    \"\"\"Retrieve Data from Adaptive.\n\n    Args:\n        version: Adaptive Version\n        data_filter: Adaptive Filter\n        data_format: Adaptive Format\n        dimensions: Adaptive Dimensions\n        rules: Adaptive Rules\n\n    Returns:\n        List of rows of data\n\n    Raises:\n        ValueError: Unexpected value\n        RuntimeError: Unexpected error\n\n    \"\"\"\n    if data_format is None:\n        data_format = ExportDataFormat()\n\n    payload: list[ET.Element] = []\n\n    if version.name is None:\n        error_message = \"Expected Version name value\"\n        raise ValueError(error_message)\n    version_element = ET.Element(\"version\", attrib={\"name\": version.name})\n    payload.append(version_element)\n\n    format_element = data_format.to_xml_element()\n    payload.append(format_element)\n\n    filter_element = data_filter.to_xml_element()\n    payload.append(filter_element)\n\n    if dimensions is not None:\n        dimensions_element = ET.Element(\"dimensions\")\n        if isinstance(dimensions, list):\n            for dimension in dimensions:\n                dimension_element = self._create_dimension_element(dimension)\n                dimensions_element.append(dimension_element)\n        else:\n            dimension_element = self._create_dimension_element(dimensions)\n            dimensions_element.append(dimension_element)\n        payload.append(dimensions_element)\n    if rules is not None:\n        rules_element = rules.to_xml_element()\n        payload.append(rules_element)\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportData\",\n        payload=payload,\n    )\n\n    received_row_count = -1\n    status_element = response.find(\"status\")\n    if status_element:\n        row_count_sent = status_element.attrib[\"rowCountSent\"]\n        if row_count_sent:\n            received_row_count = int(row_count_sent)\n    data_element = response.find(\"output\")\n    data: list[dict[str, str | int | float]] = []\n    column_headers: Sequence[str] | None = None\n    if data_element is not None and data_element.text is not None:\n        rows = StringIO(data_element.text.lstrip(\"\\n\"))\n        csv_reader = DictReader(rows, lineterminator=\"\\n\")\n        column_headers = csv_reader.fieldnames\n        data = list(csv_reader)\n    if received_row_count &gt; -1 and received_row_count != len(data):\n        error_message = (\n            \"Inconsistent row counts: expected \"\n            f\"{received_row_count}, got {len(data)}\"\n        )\n        raise RuntimeError(error_message)\n\n    if column_headers is not None:\n        period_columns = [\n            period\n            for period in column_headers\n            if not (period.endswith((\" Name\", \" Code\")))\n        ]\n        parsed_data: list[dict[str, str | int | float]] = []\n        for data_row in data:\n            for period in period_columns:\n                row: dict[str, str | int | float] = {}\n                for column in column_headers:\n                    if column in period_columns:\n                        break\n                    row[column] = data_row[column]\n                row[\"Period Code\"] = period\n                try:\n                    row[\"Amount\"] = int(data_row[period])\n                except ValueError:\n                    row[\"Amount\"] = float(data_row[period])\n\n                parsed_data.append(row)\n        return parsed_data\n\n    return data\n</code></pre>"},{"location":"reference/wdadaptivepy/services/dimension_values/","title":"dimension_values","text":"<p>wdadaptivepy service for Adaptive's Dimension Values.</p>"},{"location":"reference/wdadaptivepy/services/dimension_values/#wdadaptivepy.services.dimension_values.DimensionValueService","title":"<code>DimensionValueService</code>","text":"<p>Create, retrieve, and modify Adaptive Dimensions.</p> <p>Attributes:</p> Name Type Description <code>Dimension</code> <p>wdadaptivepy Dimension</p> Source code in <code>src/wdadaptivepy/services/dimension_values.py</code> <pre><code>class DimensionValueService:\n    \"\"\"Create, retrieve, and modify Adaptive Dimensions.\n\n    Attributes:\n        Dimension: wdadaptivepy Dimension\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize DimensionService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.DimensionValue = DimensionValue\n\n    def get_all(\n        self,\n        dimension: Dimension | str | int,\n        *,\n        attributes: bool = True,\n        display_name_enabled: bool = True,\n    ) -&gt; MetadataList[DimensionValue]:\n        \"\"\"Retrieve all Dimension Values from Adaptive.\n\n        Args:\n            dimension: Adaptive Dimension\n            attributes: Adaptive Attributes\n            display_name_enabled: Adaptive Display Name Enabled\n\n        Returns:\n            adaptive Dimension Values\n\n        \"\"\"\n        get_dimension = self.__find_dimension(dimension)\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"dimensionIDs\": str(get_dimension.id),\n                \"attributes\": str(bool_to_str_true_false(attributes)),\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportDimensions\",\n            payload=include,\n        )\n        return MetadataList[DimensionValue](DimensionValue.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        dimension: Dimension | str | int,\n        dimension_values: Sequence[DimensionValue],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Dimension Value update XML API call for review.\n\n        Args:\n            dimension: wdadaptivepy Dimension to update\n            dimension_values: wdadaptivepy Dimension Values to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        method, payload = self.__build_update_payload(dimension, dimension_values)\n        # ET.indent(updated_dimensions)\n        # with open(\"test_dimensions.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(update_dimension, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=method,\n            payload=payload,\n            hide_password=hide_password,\n        )\n\n    def __build_update_payload(\n        self,\n        dimension: Dimension | int | str,\n        dimension_values: Sequence[DimensionValue],\n    ) -&gt; tuple[str, ET.Element]:\n        for dimension_value in dimension_values:\n            if dimension_value.id is None or dimension_value.id == 0:\n                raise ValueError\n        found_dimension = self.__find_dimension(dimension)\n        update_dimensions = Dimension.to_xml(\n            \"update\",\n            [Dimension(id=found_dimension.id)],\n        )\n        update_dimension = update_dimensions.find(\"dimension\")\n        if update_dimension is None:\n            raise ValueError\n        update_dimension.extend(DimensionValue.to_xml(\"update\", dimension_values))\n        return \"updateDimensions\", update_dimensions\n\n    def __find_dimension(self, dimension: Dimension | int | str) -&gt; Dimension:  # NOQA: PLR0912\n        search_dimension = None\n        if isinstance(dimension, Dimension):\n            search_dimension = dimension\n        elif isinstance(dimension, int):\n            search_dimension = Dimension(id=dimension)\n        elif isinstance(dimension, str):\n            search_dimension = Dimension(code=dimension, name=dimension)\n        else:\n            raise TypeError\n\n        dimensions_include = ET.Element(\n            \"include\",\n            attrib={\n                \"attributes\": str(bool_to_str_true_false(value=False)),\n                \"dimensionValues\": str(bool_to_str_true_false(value=False)),\n                \"displayNameEnabled\": str(bool_to_str_true_false(value=True)),\n            },\n        )\n        dimensions_response = self.__xml_api.make_xml_request(\n            method=\"exportDimensions\",\n            payload=dimensions_include,\n        )\n        all_dimensions = MetadataList[Dimension](\n            Dimension.from_xml(xml=dimensions_response),\n        )\n\n        found_dimension = None\n        if search_dimension.id is not None and search_dimension.id != 0:\n            for dim in all_dimensions:\n                if dim.id == search_dimension.id:\n                    found_dimension = dim\n                    break\n        else:\n            for dim in all_dimensions:\n                if dim.code == search_dimension.code:\n                    found_dimension = dim\n                    break\n            if search_dimension is None:\n                for dim in all_dimensions:\n                    if dim.name == search_dimension.name:\n                        found_dimension = dim\n                        break\n\n        if found_dimension is None:\n            raise ValueError\n\n        return found_dimension\n\n    def from_json(self, data: str) -&gt; MetadataList[DimensionValue]:\n        \"\"\"Convert JSON to MetadataList of Dimension Values.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Dimension Values\n\n        \"\"\"\n        return MetadataList[DimensionValue](DimensionValue.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[DimensionValue]:\n        \"\"\"Convert Python Dictionary to MetadataList of Dimension Values.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Dimension Values\n\n        \"\"\"\n        return MetadataList[DimensionValue](DimensionValue.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/dimension_values/#wdadaptivepy.services.dimension_values.DimensionValueService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize DimensionService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/dimension_values.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize DimensionService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.DimensionValue = DimensionValue\n</code></pre>"},{"location":"reference/wdadaptivepy/services/dimension_values/#wdadaptivepy.services.dimension_values.DimensionValueService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Dimension Values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[DimensionValue]</code> <p>MetadataList of Dimension Values</p> Source code in <code>src/wdadaptivepy/services/dimension_values.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[DimensionValue]:\n    \"\"\"Convert Python Dictionary to MetadataList of Dimension Values.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Dimension Values\n\n    \"\"\"\n    return MetadataList[DimensionValue](DimensionValue.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/dimension_values/#wdadaptivepy.services.dimension_values.DimensionValueService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Dimension Values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[DimensionValue]</code> <p>MetadataList of Dimension Values</p> Source code in <code>src/wdadaptivepy/services/dimension_values.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[DimensionValue]:\n    \"\"\"Convert JSON to MetadataList of Dimension Values.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Dimension Values\n\n    \"\"\"\n    return MetadataList[DimensionValue](DimensionValue.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/dimension_values/#wdadaptivepy.services.dimension_values.DimensionValueService.get_all","title":"<code>get_all(dimension, *, attributes=True, display_name_enabled=True)</code>","text":"<p>Retrieve all Dimension Values from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>Dimension | str | int</code> <p>Adaptive Dimension</p> required <code>attributes</code> <code>bool</code> <p>Adaptive Attributes</p> <code>True</code> <code>display_name_enabled</code> <code>bool</code> <p>Adaptive Display Name Enabled</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[DimensionValue]</code> <p>adaptive Dimension Values</p> Source code in <code>src/wdadaptivepy/services/dimension_values.py</code> <pre><code>def get_all(\n    self,\n    dimension: Dimension | str | int,\n    *,\n    attributes: bool = True,\n    display_name_enabled: bool = True,\n) -&gt; MetadataList[DimensionValue]:\n    \"\"\"Retrieve all Dimension Values from Adaptive.\n\n    Args:\n        dimension: Adaptive Dimension\n        attributes: Adaptive Attributes\n        display_name_enabled: Adaptive Display Name Enabled\n\n    Returns:\n        adaptive Dimension Values\n\n    \"\"\"\n    get_dimension = self.__find_dimension(dimension)\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"dimensionIDs\": str(get_dimension.id),\n            \"attributes\": str(bool_to_str_true_false(attributes)),\n            \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportDimensions\",\n        payload=include,\n    )\n    return MetadataList[DimensionValue](DimensionValue.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/dimension_values/#wdadaptivepy.services.dimension_values.DimensionValueService.preview_update","title":"<code>preview_update(dimension, dimension_values, *, hide_password=True)</code>","text":"<p>Generate Dimension Value update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>Dimension | str | int</code> <p>wdadaptivepy Dimension to update</p> required <code>dimension_values</code> <code>Sequence[DimensionValue]</code> <p>wdadaptivepy Dimension Values to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/dimension_values.py</code> <pre><code>def preview_update(\n    self,\n    dimension: Dimension | str | int,\n    dimension_values: Sequence[DimensionValue],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Dimension Value update XML API call for review.\n\n    Args:\n        dimension: wdadaptivepy Dimension to update\n        dimension_values: wdadaptivepy Dimension Values to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    method, payload = self.__build_update_payload(dimension, dimension_values)\n    # ET.indent(updated_dimensions)\n    # with open(\"test_dimensions.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(update_dimension, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=method,\n        payload=payload,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/dimensions/","title":"dimensions","text":"<p>wdadaptivepy service for Adaptive's Dimensions.</p>"},{"location":"reference/wdadaptivepy/services/dimensions/#wdadaptivepy.services.dimensions.DimensionService","title":"<code>DimensionService</code>","text":"<p>Create, retrieve, and modify Adaptive Dimensions.</p> <p>Attributes:</p> Name Type Description <code>Dimension</code> <p>wdadaptivepy Dimension</p> Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>class DimensionService:\n    \"\"\"Create, retrieve, and modify Adaptive Dimensions.\n\n    Attributes:\n        Dimension: wdadaptivepy Dimension\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize DimensionService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Dimension = Dimension\n\n    def get_all(\n        self,\n        *,\n        attributes: bool = True,\n        dimension_values: bool = True,\n        display_name_enabled: bool = True,\n    ) -&gt; MetadataList[Dimension]:\n        \"\"\"Retrieve all Dimensions from Adaptive.\n\n        Args:\n            attributes: Adaptive Attributes\n            dimension_values: Adaptive Dimension Values\n            display_name_enabled: Adaptive Display Name Enabled\n\n        Returns:\n            adaptive Dimensions\n\n        \"\"\"\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"attributes\": str(bool_to_str_true_false(attributes)),\n                \"dimensionValues\": str(bool_to_str_true_false(dimension_values)),\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportDimensions\",\n            payload=include,\n        )\n        return MetadataList[Dimension](Dimension.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        dimensions: Sequence[Dimension],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Dimension update XML API call for review.\n\n        Args:\n            dimensions: wdadaptivepy Dimensions to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_dimensions = Dimension.to_xml(\"update\", dimensions)\n        # ET.indent(updated_dimensions)\n        # with open(\"test_dimensions.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_dimensions, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importDimensions\",\n            payload=updated_dimensions,\n            hide_password=hide_password,\n        )\n\n    def get(  # NOQA: PLR0913\n        self,\n        dimensions: Sequence[Dimension] = [],\n        dimension_ids: Sequence[int] = [],\n        dimension_names: Sequence[str] = [],\n        *,\n        attributes: bool = True,\n        dimension_values: bool = True,\n        display_name_enabled: bool = True,\n    ) -&gt; MetadataList[Dimension]:\n        \"\"\"Retrieve Dimensions from Adaptive with additional filters.\n\n        Args:\n            dimensions: Adaptive Dimensions\n            dimension_ids: Adaptive Dimension IDs\n            dimension_names: Adaptive Dimension Names\n            attributes: Adaptive Attributes\n            dimension_values: Adaptive Dimension Values\n            display_name_enabled: Adaptive Display Name Enabled\n\n        Returns:\n            adaptive Dimensions\n\n        \"\"\"\n        ids: list[int] = []\n        if dimensions:\n            ids.extend(\n                [dimension.id for dimension in dimensions if dimension.id is not None],\n            )\n        elif dimension_ids:\n            ids.extend(dimension_ids)\n        elif dimension_names:\n            all_dimensions = self.get_all(dimension_values=False)\n            for name in dimension_names:\n                ids.extend(\n                    [\n                        dimension.id\n                        for dimension in all_dimensions\n                        if dimension.name == name and dimension.id is not None\n                    ],\n                )\n        else:\n            raise ValueError\n        if not ids:\n            raise ValueError\n\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"dimensionIDs\": \",\".join(str(dimension_id) for dimension_id in ids),\n                \"attributes\": str(bool_to_str_true_false(attributes)),\n                \"dimensionValues\": str(bool_to_str_true_false(dimension_values)),\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportDimensions\",\n            payload=include,\n        )\n        return MetadataList[Dimension](Dimension.from_xml(xml=response))\n\n    def from_json(self, data: str) -&gt; MetadataList[Dimension]:\n        \"\"\"Convert JSON to MetadataList of Dimensions.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Dimensions\n\n        \"\"\"\n        return MetadataList[Dimension](Dimension.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Dimension]:\n        \"\"\"Convert Python Dictionary to MetadataList of Dimensions.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Dimensions\n\n        \"\"\"\n        return MetadataList[Dimension](Dimension.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/dimensions/#wdadaptivepy.services.dimensions.DimensionService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize DimensionService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize DimensionService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Dimension = Dimension\n</code></pre>"},{"location":"reference/wdadaptivepy/services/dimensions/#wdadaptivepy.services.dimensions.DimensionService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Dimension]</code> <p>MetadataList of Dimensions</p> Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Dimension]:\n    \"\"\"Convert Python Dictionary to MetadataList of Dimensions.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Dimensions\n\n    \"\"\"\n    return MetadataList[Dimension](Dimension.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/dimensions/#wdadaptivepy.services.dimensions.DimensionService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[Dimension]</code> <p>MetadataList of Dimensions</p> Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Dimension]:\n    \"\"\"Convert JSON to MetadataList of Dimensions.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Dimensions\n\n    \"\"\"\n    return MetadataList[Dimension](Dimension.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/dimensions/#wdadaptivepy.services.dimensions.DimensionService.get","title":"<code>get(dimensions=[], dimension_ids=[], dimension_names=[], *, attributes=True, dimension_values=True, display_name_enabled=True)</code>","text":"<p>Retrieve Dimensions from Adaptive with additional filters.</p> <p>Parameters:</p> Name Type Description Default <code>dimensions</code> <code>Sequence[Dimension]</code> <p>Adaptive Dimensions</p> <code>[]</code> <code>dimension_ids</code> <code>Sequence[int]</code> <p>Adaptive Dimension IDs</p> <code>[]</code> <code>dimension_names</code> <code>Sequence[str]</code> <p>Adaptive Dimension Names</p> <code>[]</code> <code>attributes</code> <code>bool</code> <p>Adaptive Attributes</p> <code>True</code> <code>dimension_values</code> <code>bool</code> <p>Adaptive Dimension Values</p> <code>True</code> <code>display_name_enabled</code> <code>bool</code> <p>Adaptive Display Name Enabled</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[Dimension]</code> <p>adaptive Dimensions</p> Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>def get(  # NOQA: PLR0913\n    self,\n    dimensions: Sequence[Dimension] = [],\n    dimension_ids: Sequence[int] = [],\n    dimension_names: Sequence[str] = [],\n    *,\n    attributes: bool = True,\n    dimension_values: bool = True,\n    display_name_enabled: bool = True,\n) -&gt; MetadataList[Dimension]:\n    \"\"\"Retrieve Dimensions from Adaptive with additional filters.\n\n    Args:\n        dimensions: Adaptive Dimensions\n        dimension_ids: Adaptive Dimension IDs\n        dimension_names: Adaptive Dimension Names\n        attributes: Adaptive Attributes\n        dimension_values: Adaptive Dimension Values\n        display_name_enabled: Adaptive Display Name Enabled\n\n    Returns:\n        adaptive Dimensions\n\n    \"\"\"\n    ids: list[int] = []\n    if dimensions:\n        ids.extend(\n            [dimension.id for dimension in dimensions if dimension.id is not None],\n        )\n    elif dimension_ids:\n        ids.extend(dimension_ids)\n    elif dimension_names:\n        all_dimensions = self.get_all(dimension_values=False)\n        for name in dimension_names:\n            ids.extend(\n                [\n                    dimension.id\n                    for dimension in all_dimensions\n                    if dimension.name == name and dimension.id is not None\n                ],\n            )\n    else:\n        raise ValueError\n    if not ids:\n        raise ValueError\n\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"dimensionIDs\": \",\".join(str(dimension_id) for dimension_id in ids),\n            \"attributes\": str(bool_to_str_true_false(attributes)),\n            \"dimensionValues\": str(bool_to_str_true_false(dimension_values)),\n            \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportDimensions\",\n        payload=include,\n    )\n    return MetadataList[Dimension](Dimension.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/dimensions/#wdadaptivepy.services.dimensions.DimensionService.get_all","title":"<code>get_all(*, attributes=True, dimension_values=True, display_name_enabled=True)</code>","text":"<p>Retrieve all Dimensions from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>bool</code> <p>Adaptive Attributes</p> <code>True</code> <code>dimension_values</code> <code>bool</code> <p>Adaptive Dimension Values</p> <code>True</code> <code>display_name_enabled</code> <code>bool</code> <p>Adaptive Display Name Enabled</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[Dimension]</code> <p>adaptive Dimensions</p> Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>def get_all(\n    self,\n    *,\n    attributes: bool = True,\n    dimension_values: bool = True,\n    display_name_enabled: bool = True,\n) -&gt; MetadataList[Dimension]:\n    \"\"\"Retrieve all Dimensions from Adaptive.\n\n    Args:\n        attributes: Adaptive Attributes\n        dimension_values: Adaptive Dimension Values\n        display_name_enabled: Adaptive Display Name Enabled\n\n    Returns:\n        adaptive Dimensions\n\n    \"\"\"\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"attributes\": str(bool_to_str_true_false(attributes)),\n            \"dimensionValues\": str(bool_to_str_true_false(dimension_values)),\n            \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportDimensions\",\n        payload=include,\n    )\n    return MetadataList[Dimension](Dimension.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/dimensions/#wdadaptivepy.services.dimensions.DimensionService.preview_update","title":"<code>preview_update(dimensions, *, hide_password=True)</code>","text":"<p>Generate Dimension update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>dimensions</code> <code>Sequence[Dimension]</code> <p>wdadaptivepy Dimensions to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/dimensions.py</code> <pre><code>def preview_update(\n    self,\n    dimensions: Sequence[Dimension],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Dimension update XML API call for review.\n\n    Args:\n        dimensions: wdadaptivepy Dimensions to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_dimensions = Dimension.to_xml(\"update\", dimensions)\n    # ET.indent(updated_dimensions)\n    # with open(\"test_dimensions.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_dimensions, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importDimensions\",\n        payload=updated_dimensions,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/groups/","title":"groups","text":"<p>wdadaptivepy service for Adaptive's Groups.</p>"},{"location":"reference/wdadaptivepy/services/groups/#wdadaptivepy.services.groups.GroupService","title":"<code>GroupService</code>","text":"<p>Create, retrieve, and modify Adaptive Grups.</p> <p>Attributes:</p> Name Type Description <code>Group</code> <p>wdadaptivepy Group</p> Source code in <code>src/wdadaptivepy/services/groups.py</code> <pre><code>class GroupService:\n    \"\"\"Create, retrieve, and modify Adaptive Grups.\n\n    Attributes:\n        Group: wdadaptivepy Group\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize GroupService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Group = Group\n\n    def get_all(self) -&gt; MetadataList[Group]:\n        \"\"\"Retrieve all Groups from Adaptive.\n\n        Returns:\n            adaptive Groups\n\n        \"\"\"\n        response = self.__xml_api.make_xml_request(method=\"exportGroups\", payload=None)\n        return MetadataList[Group](Group.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        groups: Sequence[Group],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Group update XML API call for review.\n\n        Args:\n            groups: wdadaptivepy Groups to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n           XML API body\n\n        \"\"\"\n        updated_groups = Group.to_xml(\"update\", groups)\n        # ET.indent(updated_groups)\n        # with open(\"test_groups.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_groups, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importGroups\",\n            payload=updated_groups,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[Group]:\n        \"\"\"Convert JSON to MetadataList of Groups.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Groups\n\n        \"\"\"\n        return MetadataList[Group](Group.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Group]:\n        \"\"\"Convert Python Dictionary to MetadataList of Groups.\n\n        Args:\n            data: Pytho Dictionary\n\n        Returns:\n            MetadataList of Groups\n\n        \"\"\"\n        return MetadataList[Group](Group.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/groups/#wdadaptivepy.services.groups.GroupService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize GroupService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/groups.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize GroupService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Group = Group\n</code></pre>"},{"location":"reference/wdadaptivepy/services/groups/#wdadaptivepy.services.groups.GroupService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Groups.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Pytho Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Group]</code> <p>MetadataList of Groups</p> Source code in <code>src/wdadaptivepy/services/groups.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Group]:\n    \"\"\"Convert Python Dictionary to MetadataList of Groups.\n\n    Args:\n        data: Pytho Dictionary\n\n    Returns:\n        MetadataList of Groups\n\n    \"\"\"\n    return MetadataList[Group](Group.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/groups/#wdadaptivepy.services.groups.GroupService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Groups.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[Group]</code> <p>MetadataList of Groups</p> Source code in <code>src/wdadaptivepy/services/groups.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Group]:\n    \"\"\"Convert JSON to MetadataList of Groups.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Groups\n\n    \"\"\"\n    return MetadataList[Group](Group.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/groups/#wdadaptivepy.services.groups.GroupService.get_all","title":"<code>get_all()</code>","text":"<p>Retrieve all Groups from Adaptive.</p> <p>Returns:</p> Type Description <code>MetadataList[Group]</code> <p>adaptive Groups</p> Source code in <code>src/wdadaptivepy/services/groups.py</code> <pre><code>def get_all(self) -&gt; MetadataList[Group]:\n    \"\"\"Retrieve all Groups from Adaptive.\n\n    Returns:\n        adaptive Groups\n\n    \"\"\"\n    response = self.__xml_api.make_xml_request(method=\"exportGroups\", payload=None)\n    return MetadataList[Group](Group.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/groups/#wdadaptivepy.services.groups.GroupService.preview_update","title":"<code>preview_update(groups, *, hide_password=True)</code>","text":"<p>Generate Group update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>Sequence[Group]</code> <p>wdadaptivepy Groups to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/groups.py</code> <pre><code>def preview_update(\n    self,\n    groups: Sequence[Group],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Group update XML API call for review.\n\n    Args:\n        groups: wdadaptivepy Groups to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n       XML API body\n\n    \"\"\"\n    updated_groups = Group.to_xml(\"update\", groups)\n    # ET.indent(updated_groups)\n    # with open(\"test_groups.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_groups, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importGroups\",\n        payload=updated_groups,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/levels/","title":"levels","text":"<p>wdadaptivepy service for Adaptive's Levels.</p>"},{"location":"reference/wdadaptivepy/services/levels/#wdadaptivepy.services.levels.LevelService","title":"<code>LevelService</code>","text":"<p>Create, retrieve, and modify Adaptive Levels.</p> <p>Attributes:</p> Name Type Description <code>Level</code> <p>wdadaptivepylevel</p> Source code in <code>src/wdadaptivepy/services/levels.py</code> <pre><code>class LevelService:\n    \"\"\"Create, retrieve, and modify Adaptive Levels.\n\n    Attributes:\n        Level: wdadaptivepylevel\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize LevelService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Level = Level\n\n    def get_all(self, *, display_name_enabled: bool = True) -&gt; MetadataList[Level]:\n        \"\"\"Retrieve all Levels from Adaptive.\n\n        Args:\n            display_name_enabled: Adaptive Display Name Enabled\n\n        Returns:\n            adaptive Levels\n\n        \"\"\"\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportLevels\",\n            payload=include,\n        )\n        return MetadataList[Level](Level.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        levels: Sequence[Level],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Level update XML API call for review.\n\n        Args:\n            levels: wdadaptivepy Levels to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_levels = Level.to_xml(\"update\", levels)\n        # ET.indent(updated_levels)\n        # with open(\"test_levels.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_levels, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importLevels\",\n            payload=updated_levels,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[Level]:\n        \"\"\"Convert JSON to MetadataList of Levels.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Levels\n\n        \"\"\"\n        return MetadataList[Level](Level.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Level]:\n        \"\"\"Convert Python Dictionary to MetadataList of Levels.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Levels\n\n        \"\"\"\n        return MetadataList[Level](Level.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/levels/#wdadaptivepy.services.levels.LevelService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize LevelService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/levels.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize LevelService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Level = Level\n</code></pre>"},{"location":"reference/wdadaptivepy/services/levels/#wdadaptivepy.services.levels.LevelService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Levels.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Level]</code> <p>MetadataList of Levels</p> Source code in <code>src/wdadaptivepy/services/levels.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Level]:\n    \"\"\"Convert Python Dictionary to MetadataList of Levels.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Levels\n\n    \"\"\"\n    return MetadataList[Level](Level.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/levels/#wdadaptivepy.services.levels.LevelService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Levels.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[Level]</code> <p>MetadataList of Levels</p> Source code in <code>src/wdadaptivepy/services/levels.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Level]:\n    \"\"\"Convert JSON to MetadataList of Levels.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Levels\n\n    \"\"\"\n    return MetadataList[Level](Level.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/levels/#wdadaptivepy.services.levels.LevelService.get_all","title":"<code>get_all(*, display_name_enabled=True)</code>","text":"<p>Retrieve all Levels from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>display_name_enabled</code> <code>bool</code> <p>Adaptive Display Name Enabled</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[Level]</code> <p>adaptive Levels</p> Source code in <code>src/wdadaptivepy/services/levels.py</code> <pre><code>def get_all(self, *, display_name_enabled: bool = True) -&gt; MetadataList[Level]:\n    \"\"\"Retrieve all Levels from Adaptive.\n\n    Args:\n        display_name_enabled: Adaptive Display Name Enabled\n\n    Returns:\n        adaptive Levels\n\n    \"\"\"\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"displayNameEnabled\": str(bool_to_str_true_false(display_name_enabled)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportLevels\",\n        payload=include,\n    )\n    return MetadataList[Level](Level.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/levels/#wdadaptivepy.services.levels.LevelService.preview_update","title":"<code>preview_update(levels, *, hide_password=True)</code>","text":"<p>Generate Level update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>levels</code> <code>Sequence[Level]</code> <p>wdadaptivepy Levels to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/levels.py</code> <pre><code>def preview_update(\n    self,\n    levels: Sequence[Level],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Level update XML API call for review.\n\n    Args:\n        levels: wdadaptivepy Levels to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_levels = Level.to_xml(\"update\", levels)\n    # ET.indent(updated_levels)\n    # with open(\"test_levels.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_levels, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importLevels\",\n        payload=updated_levels,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/permission_sets/","title":"permission_sets","text":"<p>wdadaptivepy service for Adaptive's Permission Sets.</p>"},{"location":"reference/wdadaptivepy/services/permission_sets/#wdadaptivepy.services.permission_sets.PermissionSetService","title":"<code>PermissionSetService</code>","text":"<p>Create, retrieve, and modify Adaptive Permission Sets.</p> <p>Attributes:</p> Name Type Description <code>PermissionSet</code> <p>wdadaptivepy Permission Set</p> Source code in <code>src/wdadaptivepy/services/permission_sets.py</code> <pre><code>class PermissionSetService:\n    \"\"\"Create, retrieve, and modify Adaptive Permission Sets.\n\n    Attributes:\n        PermissionSet: wdadaptivepy Permission Set\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize PermissionSetService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.PermissionSet = PermissionSet\n\n    def get_all(self) -&gt; MetadataList[PermissionSet]:\n        \"\"\"Retrieve all Permission Sets from Adaptive.\n\n        Returns:\n            adaptive Permission Sets\n\n        \"\"\"\n        response = self.__xml_api.make_xml_request(\n            method=\"exportPermissionSets\",\n            payload=None,\n        )\n        return MetadataList[PermissionSet](PermissionSet.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        permission_sets: Sequence[PermissionSet],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Permission Set update XML API call for review.\n\n        Args:\n            permission_sets: wdadaptivepy Permission Sets to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_permission_sets = PermissionSet.to_xml(\"update\", permission_sets)\n        # ET.indent(updated_permission_sets)\n        # with open(\"test_permission_sets.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_permission_sets, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importPermissionSets\",\n            payload=updated_permission_sets,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[PermissionSet]:\n        \"\"\"Convert JSON to MetadataList of Permission Sets.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Permission Sets\n\n        \"\"\"\n        return MetadataList[PermissionSet](PermissionSet.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[PermissionSet]:\n        \"\"\"Convert Python Dictionary to MetadataList of Permission Sets.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Permission Sets\n\n        \"\"\"\n        return MetadataList[PermissionSet](PermissionSet.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/permission_sets/#wdadaptivepy.services.permission_sets.PermissionSetService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize PermissionSetService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/permission_sets.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize PermissionSetService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.PermissionSet = PermissionSet\n</code></pre>"},{"location":"reference/wdadaptivepy/services/permission_sets/#wdadaptivepy.services.permission_sets.PermissionSetService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Permission Sets.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[PermissionSet]</code> <p>MetadataList of Permission Sets</p> Source code in <code>src/wdadaptivepy/services/permission_sets.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[PermissionSet]:\n    \"\"\"Convert Python Dictionary to MetadataList of Permission Sets.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Permission Sets\n\n    \"\"\"\n    return MetadataList[PermissionSet](PermissionSet.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/permission_sets/#wdadaptivepy.services.permission_sets.PermissionSetService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Permission Sets.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[PermissionSet]</code> <p>MetadataList of Permission Sets</p> Source code in <code>src/wdadaptivepy/services/permission_sets.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[PermissionSet]:\n    \"\"\"Convert JSON to MetadataList of Permission Sets.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Permission Sets\n\n    \"\"\"\n    return MetadataList[PermissionSet](PermissionSet.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/permission_sets/#wdadaptivepy.services.permission_sets.PermissionSetService.get_all","title":"<code>get_all()</code>","text":"<p>Retrieve all Permission Sets from Adaptive.</p> <p>Returns:</p> Type Description <code>MetadataList[PermissionSet]</code> <p>adaptive Permission Sets</p> Source code in <code>src/wdadaptivepy/services/permission_sets.py</code> <pre><code>def get_all(self) -&gt; MetadataList[PermissionSet]:\n    \"\"\"Retrieve all Permission Sets from Adaptive.\n\n    Returns:\n        adaptive Permission Sets\n\n    \"\"\"\n    response = self.__xml_api.make_xml_request(\n        method=\"exportPermissionSets\",\n        payload=None,\n    )\n    return MetadataList[PermissionSet](PermissionSet.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/permission_sets/#wdadaptivepy.services.permission_sets.PermissionSetService.preview_update","title":"<code>preview_update(permission_sets, *, hide_password=True)</code>","text":"<p>Generate Permission Set update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>permission_sets</code> <code>Sequence[PermissionSet]</code> <p>wdadaptivepy Permission Sets to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/permission_sets.py</code> <pre><code>def preview_update(\n    self,\n    permission_sets: Sequence[PermissionSet],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Permission Set update XML API call for review.\n\n    Args:\n        permission_sets: wdadaptivepy Permission Sets to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_permission_sets = PermissionSet.to_xml(\"update\", permission_sets)\n    # ET.indent(updated_permission_sets)\n    # with open(\"test_permission_sets.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_permission_sets, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importPermissionSets\",\n        payload=updated_permission_sets,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/time/","title":"time","text":"<p>wdadaptivepy service for Adaptive's Time.</p>"},{"location":"reference/wdadaptivepy/services/time/#wdadaptivepy.services.time.TimeService","title":"<code>TimeService</code>","text":"<p>Create, retrieve, and modify Adaptive Time.</p> <p>Attributes:</p> Name Type Description <code>Time</code> <p>wdadaptivepy Time</p> <code>Period</code> <p>wdadaptivepy Period</p> <code>Stratum</code> <p>wdadaptivepy Stratum</p> Source code in <code>src/wdadaptivepy/services/time.py</code> <pre><code>class TimeService:\n    \"\"\"Create, retrieve, and modify Adaptive Time.\n\n    Attributes:\n        Time: wdadaptivepy Time\n        Period: wdadaptivepy Period\n        Stratum: wdadaptivepy Stratum\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize TimeService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Time = Time\n        self.Period = Period\n        self.Stratum = Stratum\n\n    def get_all(\n        self,\n        *,\n        include_all_locales: bool = False,\n        include_legacy_information: bool = False,\n    ) -&gt; MetadataList[Time]:\n        \"\"\"Retrieve all Time from Adaptive.\n\n        Args:\n            include_all_locales: Adaptive Include All Locales\n            include_legacy_information: Adaptive Include Legacy Information\n\n        Returns:\n            adaptive Time\n\n        \"\"\"\n        options = ET.Element(\n            \"options\",\n            attrib={\n                \"includeAllLocales\": str(bool_to_str_one_zero(include_all_locales)),\n                \"includeLegacyInformation\": str(\n                    bool_to_str_one_zero(include_legacy_information),\n                ),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(method=\"exportTime\", payload=options)\n        return MetadataList[Time](Time.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        times: Sequence[Time],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Time update XML API call for review.\n\n        Args:\n            times: wdadaptivepy Time to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_times = Time.to_xml(\"update\", times)\n        # ET.indent(updated_times)\n        # with open(\"test_time.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_times, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importTime\",\n            payload=updated_times,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[Time]:\n        \"\"\"Convert JSON to MetadataList of Time.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Time\n\n        \"\"\"\n        return MetadataList[Time](Time.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Time]:\n        \"\"\"Convert Python Dictionary to MetadataList of Time.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Time\n\n        \"\"\"\n        return MetadataList[Time](Time.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/time/#wdadaptivepy.services.time.TimeService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize TimeService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/time.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize TimeService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Time = Time\n    self.Period = Period\n    self.Stratum = Stratum\n</code></pre>"},{"location":"reference/wdadaptivepy/services/time/#wdadaptivepy.services.time.TimeService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Time.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Time]</code> <p>MetadataList of Time</p> Source code in <code>src/wdadaptivepy/services/time.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Time]:\n    \"\"\"Convert Python Dictionary to MetadataList of Time.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Time\n\n    \"\"\"\n    return MetadataList[Time](Time.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/time/#wdadaptivepy.services.time.TimeService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Time.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[Time]</code> <p>MetadataList of Time</p> Source code in <code>src/wdadaptivepy/services/time.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Time]:\n    \"\"\"Convert JSON to MetadataList of Time.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Time\n\n    \"\"\"\n    return MetadataList[Time](Time.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/time/#wdadaptivepy.services.time.TimeService.get_all","title":"<code>get_all(*, include_all_locales=False, include_legacy_information=False)</code>","text":"<p>Retrieve all Time from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>include_all_locales</code> <code>bool</code> <p>Adaptive Include All Locales</p> <code>False</code> <code>include_legacy_information</code> <code>bool</code> <p>Adaptive Include Legacy Information</p> <code>False</code> <p>Returns:</p> Type Description <code>MetadataList[Time]</code> <p>adaptive Time</p> Source code in <code>src/wdadaptivepy/services/time.py</code> <pre><code>def get_all(\n    self,\n    *,\n    include_all_locales: bool = False,\n    include_legacy_information: bool = False,\n) -&gt; MetadataList[Time]:\n    \"\"\"Retrieve all Time from Adaptive.\n\n    Args:\n        include_all_locales: Adaptive Include All Locales\n        include_legacy_information: Adaptive Include Legacy Information\n\n    Returns:\n        adaptive Time\n\n    \"\"\"\n    options = ET.Element(\n        \"options\",\n        attrib={\n            \"includeAllLocales\": str(bool_to_str_one_zero(include_all_locales)),\n            \"includeLegacyInformation\": str(\n                bool_to_str_one_zero(include_legacy_information),\n            ),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(method=\"exportTime\", payload=options)\n    return MetadataList[Time](Time.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/time/#wdadaptivepy.services.time.TimeService.preview_update","title":"<code>preview_update(times, *, hide_password=True)</code>","text":"<p>Generate Time update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>times</code> <code>Sequence[Time]</code> <p>wdadaptivepy Time to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/time.py</code> <pre><code>def preview_update(\n    self,\n    times: Sequence[Time],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Time update XML API call for review.\n\n    Args:\n        times: wdadaptivepy Time to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_times = Time.to_xml(\"update\", times)\n    # ET.indent(updated_times)\n    # with open(\"test_time.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_times, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importTime\",\n        payload=updated_times,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/users/","title":"users","text":"<p>wdadaptivepy service for Adaptive's Users.</p>"},{"location":"reference/wdadaptivepy/services/users/#wdadaptivepy.services.users.UserService","title":"<code>UserService</code>","text":"<p>Create, retrieve, and modify Adaptive Users.</p> <p>Attributes:</p> Name Type Description <code>User</code> <p>wdadaptivepy User</p> Source code in <code>src/wdadaptivepy/services/users.py</code> <pre><code>class UserService:\n    \"\"\"Create, retrieve, and modify Adaptive Users.\n\n    Attributes:\n        User: wdadaptivepy User\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize UserService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.User = User\n\n    def get_all(\n        self,\n        *,\n        groups: bool = True,\n        owned_levels: bool = True,\n    ) -&gt; MetadataList[User]:\n        \"\"\"Retrieve all Users from Adaptive.\n\n        Args:\n            groups: Adaptive Groups\n            owned_levels: Adaptive Owned Levels\n\n        Returns:\n            adaptive Users\n\n        \"\"\"\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"groups\": str(bool_to_str_true_false(groups)),\n                \"ownedLevels\": str(bool_to_str_true_false(owned_levels)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportUsers\",\n            payload=include,\n        )\n        return MetadataList[User](User.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        users: Sequence[User],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate User update XML API call for review.\n\n        Args:\n            users: wdadaptivepy Users to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_users = User.to_xml(\"update\", users)\n        # ET.indent(updated_users)\n        # with open(\"test_users.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_users, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importUsers\",\n            payload=updated_users,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[User]:\n        \"\"\"Convert JSON to MetadataList of Users.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Users\n\n        \"\"\"\n        return MetadataList[User](User.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[User]:\n        \"\"\"Convert Python Dictionary to MetadataList of Users.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Users\n\n        \"\"\"\n        return MetadataList[User](User.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/users/#wdadaptivepy.services.users.UserService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize UserService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/users.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize UserService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.User = User\n</code></pre>"},{"location":"reference/wdadaptivepy/services/users/#wdadaptivepy.services.users.UserService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Users.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[User]</code> <p>MetadataList of Users</p> Source code in <code>src/wdadaptivepy/services/users.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[User]:\n    \"\"\"Convert Python Dictionary to MetadataList of Users.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Users\n\n    \"\"\"\n    return MetadataList[User](User.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/users/#wdadaptivepy.services.users.UserService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Users.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[User]</code> <p>MetadataList of Users</p> Source code in <code>src/wdadaptivepy/services/users.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[User]:\n    \"\"\"Convert JSON to MetadataList of Users.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Users\n\n    \"\"\"\n    return MetadataList[User](User.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/users/#wdadaptivepy.services.users.UserService.get_all","title":"<code>get_all(*, groups=True, owned_levels=True)</code>","text":"<p>Retrieve all Users from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>bool</code> <p>Adaptive Groups</p> <code>True</code> <code>owned_levels</code> <code>bool</code> <p>Adaptive Owned Levels</p> <code>True</code> <p>Returns:</p> Type Description <code>MetadataList[User]</code> <p>adaptive Users</p> Source code in <code>src/wdadaptivepy/services/users.py</code> <pre><code>def get_all(\n    self,\n    *,\n    groups: bool = True,\n    owned_levels: bool = True,\n) -&gt; MetadataList[User]:\n    \"\"\"Retrieve all Users from Adaptive.\n\n    Args:\n        groups: Adaptive Groups\n        owned_levels: Adaptive Owned Levels\n\n    Returns:\n        adaptive Users\n\n    \"\"\"\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"groups\": str(bool_to_str_true_false(groups)),\n            \"ownedLevels\": str(bool_to_str_true_false(owned_levels)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportUsers\",\n        payload=include,\n    )\n    return MetadataList[User](User.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/users/#wdadaptivepy.services.users.UserService.preview_update","title":"<code>preview_update(users, *, hide_password=True)</code>","text":"<p>Generate User update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>users</code> <code>Sequence[User]</code> <p>wdadaptivepy Users to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/users.py</code> <pre><code>def preview_update(\n    self,\n    users: Sequence[User],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate User update XML API call for review.\n\n    Args:\n        users: wdadaptivepy Users to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_users = User.to_xml(\"update\", users)\n    # ET.indent(updated_users)\n    # with open(\"test_users.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_users, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importUsers\",\n        payload=updated_users,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"reference/wdadaptivepy/services/versions/","title":"versions","text":"<p>wdadaptivepy service for Adaptive's Versions.</p>"},{"location":"reference/wdadaptivepy/services/versions/#wdadaptivepy.services.versions.VersionService","title":"<code>VersionService</code>","text":"<p>Create, retrieve, and modify Adaptive Versions.</p> <p>Attributes:</p> Name Type Description <code>Version</code> <p>wdadaptivepy Version</p> Source code in <code>src/wdadaptivepy/services/versions.py</code> <pre><code>class VersionService:\n    \"\"\"Create, retrieve, and modify Adaptive Versions.\n\n    Attributes:\n        Version: wdadaptivepy Version\n\n    \"\"\"\n\n    def __init__(self, xml_api: XMLApi) -&gt; None:\n        \"\"\"Initialize VersionService.\n\n        Args:\n            xml_api: wdadaptivepy XMLApi\n\n        \"\"\"\n        self.__xml_api = xml_api\n        self.Version = Version\n\n    def get_all(\n        self,\n        *,\n        scenarios: bool = False,\n        currency_versions: bool = False,\n    ) -&gt; MetadataList[Version]:\n        \"\"\"Retrieve all Versions from Adaptive.\n\n        Args:\n            scenarios: Adaptive Scenarios\n            currency_versions: Adaptive Currency Versions\n\n        Returns:\n            adaptive Versions\n\n        \"\"\"\n        include = ET.Element(\n            \"include\",\n            attrib={\n                \"scenarios\": str(bool_to_str_true_false(scenarios)),\n                \"currencyVersions\": str(bool_to_str_true_false(currency_versions)),\n            },\n        )\n\n        response = self.__xml_api.make_xml_request(\n            method=\"exportVersions\",\n            payload=include,\n        )\n        return MetadataList[Version](Version.from_xml(xml=response))\n\n    def preview_update(\n        self,\n        versions: Sequence[Version],\n        *,\n        hide_password: bool = True,\n    ) -&gt; ET.Element:\n        \"\"\"Generate Currency update XML API call for review.\n\n        Args:\n            versions: wdadaptivepy Versions to update\n            hide_password: Prevent password from being displayed\n\n        Returns:\n            XML API body\n\n        \"\"\"\n        updated_versions = Version.to_xml(\"update\", versions)\n        # ET.indent(updated_versions)\n        # with open(\"test_versions.xml\", \"w\", encoding=\"utf-8\") as fp:\n        #     fp.write(ET.tostring(updated_versions, encoding=\"unicode\"))\n        return self.__xml_api.preview_xml_request(\n            method=\"importVersions\",\n            payload=updated_versions,\n            hide_password=hide_password,\n        )\n\n    def from_json(self, data: str) -&gt; MetadataList[Version]:\n        \"\"\"Convert JSON to MetadataList of Versions.\n\n        Args:\n            data: JSON string\n\n        Returns:\n            MetadataList of Versions\n\n        \"\"\"\n        return MetadataList[Version](Version.from_json(data=data))\n\n    def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Version]:\n        \"\"\"Convert Python Dictionary to MetadataList of Versions.\n\n        Args:\n            data: Python Dictionary\n\n        Returns:\n            MetadataList of Versions\n\n        \"\"\"\n        return MetadataList[Version](Version.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/versions/#wdadaptivepy.services.versions.VersionService.__init__","title":"<code>__init__(xml_api)</code>","text":"<p>Initialize VersionService.</p> <p>Parameters:</p> Name Type Description Default <code>xml_api</code> <code>XMLApi</code> <p>wdadaptivepy XMLApi</p> required Source code in <code>src/wdadaptivepy/services/versions.py</code> <pre><code>def __init__(self, xml_api: XMLApi) -&gt; None:\n    \"\"\"Initialize VersionService.\n\n    Args:\n        xml_api: wdadaptivepy XMLApi\n\n    \"\"\"\n    self.__xml_api = xml_api\n    self.Version = Version\n</code></pre>"},{"location":"reference/wdadaptivepy/services/versions/#wdadaptivepy.services.versions.VersionService.from_dict","title":"<code>from_dict(data)</code>","text":"<p>Convert Python Dictionary to MetadataList of Versions.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict] | dict</code> <p>Python Dictionary</p> required <p>Returns:</p> Type Description <code>MetadataList[Version]</code> <p>MetadataList of Versions</p> Source code in <code>src/wdadaptivepy/services/versions.py</code> <pre><code>def from_dict(self, data: Sequence[dict] | dict) -&gt; MetadataList[Version]:\n    \"\"\"Convert Python Dictionary to MetadataList of Versions.\n\n    Args:\n        data: Python Dictionary\n\n    Returns:\n        MetadataList of Versions\n\n    \"\"\"\n    return MetadataList[Version](Version.from_dict(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/versions/#wdadaptivepy.services.versions.VersionService.from_json","title":"<code>from_json(data)</code>","text":"<p>Convert JSON to MetadataList of Versions.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>MetadataList[Version]</code> <p>MetadataList of Versions</p> Source code in <code>src/wdadaptivepy/services/versions.py</code> <pre><code>def from_json(self, data: str) -&gt; MetadataList[Version]:\n    \"\"\"Convert JSON to MetadataList of Versions.\n\n    Args:\n        data: JSON string\n\n    Returns:\n        MetadataList of Versions\n\n    \"\"\"\n    return MetadataList[Version](Version.from_json(data=data))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/versions/#wdadaptivepy.services.versions.VersionService.get_all","title":"<code>get_all(*, scenarios=False, currency_versions=False)</code>","text":"<p>Retrieve all Versions from Adaptive.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>bool</code> <p>Adaptive Scenarios</p> <code>False</code> <code>currency_versions</code> <code>bool</code> <p>Adaptive Currency Versions</p> <code>False</code> <p>Returns:</p> Type Description <code>MetadataList[Version]</code> <p>adaptive Versions</p> Source code in <code>src/wdadaptivepy/services/versions.py</code> <pre><code>def get_all(\n    self,\n    *,\n    scenarios: bool = False,\n    currency_versions: bool = False,\n) -&gt; MetadataList[Version]:\n    \"\"\"Retrieve all Versions from Adaptive.\n\n    Args:\n        scenarios: Adaptive Scenarios\n        currency_versions: Adaptive Currency Versions\n\n    Returns:\n        adaptive Versions\n\n    \"\"\"\n    include = ET.Element(\n        \"include\",\n        attrib={\n            \"scenarios\": str(bool_to_str_true_false(scenarios)),\n            \"currencyVersions\": str(bool_to_str_true_false(currency_versions)),\n        },\n    )\n\n    response = self.__xml_api.make_xml_request(\n        method=\"exportVersions\",\n        payload=include,\n    )\n    return MetadataList[Version](Version.from_xml(xml=response))\n</code></pre>"},{"location":"reference/wdadaptivepy/services/versions/#wdadaptivepy.services.versions.VersionService.preview_update","title":"<code>preview_update(versions, *, hide_password=True)</code>","text":"<p>Generate Currency update XML API call for review.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[Version]</code> <p>wdadaptivepy Versions to update</p> required <code>hide_password</code> <code>bool</code> <p>Prevent password from being displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>Element</code> <p>XML API body</p> Source code in <code>src/wdadaptivepy/services/versions.py</code> <pre><code>def preview_update(\n    self,\n    versions: Sequence[Version],\n    *,\n    hide_password: bool = True,\n) -&gt; ET.Element:\n    \"\"\"Generate Currency update XML API call for review.\n\n    Args:\n        versions: wdadaptivepy Versions to update\n        hide_password: Prevent password from being displayed\n\n    Returns:\n        XML API body\n\n    \"\"\"\n    updated_versions = Version.to_xml(\"update\", versions)\n    # ET.indent(updated_versions)\n    # with open(\"test_versions.xml\", \"w\", encoding=\"utf-8\") as fp:\n    #     fp.write(ET.tostring(updated_versions, encoding=\"unicode\"))\n    return self.__xml_api.preview_xml_request(\n        method=\"importVersions\",\n        payload=updated_versions,\n        hide_password=hide_password,\n    )\n</code></pre>"},{"location":"news/archive/2025/","title":"2025","text":""},{"location":"news/category/release/","title":"Release","text":""},{"location":"news/category/roadmap/","title":"Roadmap","text":""}]}